/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var physics_1 = __webpack_require__(1);
	var display_1 = __webpack_require__(63);
	var controls_1 = __webpack_require__(76);
	var ellermaze_1 = __webpack_require__(77);
	function fullscreen(el) {
	    if (el.requestFullscreen) {
	        el.requestFullscreen();
	    }
	    else if (el.msRequestFullscreen) {
	        el.msRequestFullscreen();
	    }
	    else if (el.mozRequestFullScreen) {
	        el.mozRequestFullScreen();
	    }
	    else if (el.webkitRequestFullscreen) {
	        el.webkitRequestFullscreen();
	    }
	}
	function InitUI() {
	    var fsIcon = document.getElementById("fullscreen");
	    if (fsIcon)
	        fsIcon.addEventListener("click", function () { return fullscreen(document.body); }, false);
	}
	var WorldObject = (function () {
	    function WorldObject(view, body) {
	        this.view = view;
	        this.body = body;
	    }
	    WorldObject.prototype.up = function (display) { display.moveObject(this.view, this.body); };
	    return WorldObject;
	})();
	var Player = (function (_super) {
	    __extends(Player, _super);
	    function Player(view, body, pos) {
	        _super.call(this, view, body);
	        this.keyb = new controls_1.Controls();
	        this.angle = 0;
	        this.body.position = pos;
	    }
	    Player.prototype.move = function (dt) {
	        this.angle += dt * this.keyb.turn / 500;
	        this.body.force[0] = Math.cos(this.angle) * 10 * this.keyb.up;
	        this.body.force[1] = Math.sin(this.angle) * 10 * this.keyb.up;
	    };
	    return Player;
	})(WorldObject);
	var World = (function () {
	    function World() {
	        var _this = this;
	        this.msg = ["Reality", " doesnâ€™t", " exist", " until", " you", " look", " at&nbsp;it"];
	        this.msgDisplay = document.getElementById("msg");
	        this.phys = new physics_1.Physics();
	        this.display = new display_1.Display3D();
	        this.maze = ellermaze_1.EllerMaze(10, 10);
	        var ppos = this.getRandomPosition();
	        this.me = new Player(this.display.player, this.phys.player, [ppos.x, ppos.y]);
	        this.worldObjects = [this.me];
	        this.hitCounter = 0;
	        this.buildWallsAndFloor();
	        this.addTarget(this.getRandomPosition());
	        this.mainLoop();
	        this.fin = false;
	        this.timer = 0;
	        this.display.animator.play({
	            func: function (_) {
	                _this.display.moreDust();
	                if (++_this.timer >= 20)
	                    _this.display.animator.stop(_this.display.dustMaterial);
	            },
	            duration: 10000,
	            loop: true,
	            timer: true,
	            object: this.display.dustMaterial
	        });
	    }
	    World.prototype.mainLoop = function (ts) {
	        var _this = this;
	        if (ts === void 0) { ts = null; }
	        var dt = this.prevLoopTS ? ts - this.prevLoopTS : 1000 / 60;
	        if (dt > 100)
	            dt = 100;
	        if (!this.fin) {
	            this.phys.world.step(dt / 1000);
	            this.me.move(dt);
	            this.worldObjects.forEach(function (g) { return g.up(_this.display); });
	            this.display.moveCamera(this.me.angle, this.me.keyb.up > 0);
	        }
	        this.display.render(dt);
	        this.prevLoopTS = ts;
	        requestAnimationFrame(function (ts) { return _this.mainLoop(ts); });
	    };
	    World.prototype.getRandomPosition = function () {
	        var w = this.maze[0].length, h = this.maze.length, x, y;
	        do {
	            x = Math.floor(Math.random() * w);
	            y = Math.floor(Math.random() * h);
	        } while (this.maze[y][x]);
	        return { x: x, y: y };
	    };
	    World.prototype.buildWallsAndFloor = function () {
	        var w = this.maze[0].length, h = this.maze.length;
	        for (var y = 0; y < h; y++)
	            for (var x = 0; x < w; x++)
	                if (this.maze[y][x]) {
	                    this.phys.addWall(x, y);
	                    this.display.addWall(x, y);
	                }
	        this.display.addEnvironment(w, h);
	    };
	    World.prototype.addTarget = function (_a) {
	        var x = _a.x, y = _a.y;
	        var p = this.phys.addTarget(x, y);
	        var o = this.display.addMorphingSphere(x, y);
	        this.worldObjects.push(new WorldObject(o, p));
	        this.destroyOnHit(p, o);
	    };
	    World.prototype.destroyOnHit = function (p, d) {
	        var _this = this;
	        this.phys.onHit({
	            obj1: p,
	            obj2: this.phys.player,
	            once: true,
	            func: function () {
	                var pos = d.position.clone();
	                var physPos = [p.position[0], p.position[1]];
	                var i = _this.worldObjects.map(function (o) { return o.view.id; }).indexOf(d.id);
	                if (i >= 0)
	                    _this.worldObjects.splice(i, 1);
	                _this.phys.world.removeBody(p);
	                _this.display.mazeHolder.remove(d);
	                _this.display.animator.stop(d);
	                if (_this.msgDisplay)
	                    _this.msgDisplay.innerHTML += _this.msg[_this.hitCounter++];
	                _this.display.glitchMe(100).then(function () {
	                    var _a = _this.display.createGalaxy(pos), animation = _a.animation, view = _a.view;
	                    return animation.then(function () {
	                        var body = _this.phys.createGalaxy(physPos);
	                        _this.worldObjects.push(new WorldObject(view, body));
	                    });
	                }).then(function () {
	                    if (_this.hitCounter < _this.msg.length)
	                        _this.addTarget(_this.getRandomPosition());
	                    else
	                        _this.display.playFinal(function () { _this.fin = true; }, _this.me.angle);
	                });
	            } });
	    };
	    return World;
	})();
	InitUI();
	new World();
	//# sourceMappingURL=main.js.map

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var p2 = __webpack_require__(2);
	var Physics = (function () {
	    function Physics() {
	        var _this = this;
	        this.world = new p2.World({ gravity: [0, 0] });
	        this.interact = [];
	        var playerShape = new p2.Circle({ radius: 1 / 3 });
	        this.player = new p2.Body({ mass: 1, position: [0, 0] });
	        this.player.addShape(playerShape);
	        this.player.damping = .5;
	        this.world.addBody(this.player);
	        var playerMaterial = new p2.Material();
	        this.wallMaterial = new p2.Material();
	        this.galaxyMaterial = new p2.Material();
	        this.targetMaterial = new p2.Material();
	        playerShape.material = playerMaterial;
	        this.world.addContactMaterial(new p2.ContactMaterial(this.wallMaterial, playerMaterial, { restitution: 1, stiffness: 500 }));
	        this.world.addContactMaterial(new p2.ContactMaterial(this.wallMaterial, this.galaxyMaterial, { restitution: 1, stiffness: 100 }));
	        this.world.addContactMaterial(new p2.ContactMaterial(playerMaterial, this.galaxyMaterial, { restitution: 1, stiffness: 7 }));
	        this.world.addContactMaterial(new p2.ContactMaterial(this.targetMaterial, playerMaterial, { restitution: 2, stiffness: Number.MAX_VALUE }));
	        this.world.on("impact", function (evt) {
	            for (var i = 0, len = _this.interact.length; i < len; i++)
	                if ((evt.bodyA.id == _this.interact[i].obj1.id && evt.bodyB.id == _this.interact[i].obj2.id) ||
	                    (evt.bodyA.id == _this.interact[i].obj2.id && evt.bodyB.id == _this.interact[i].obj1.id)) {
	                    _this.interact[i].func();
	                    if (_this.interact[i].once)
	                        _this.interact.splice(i, 1);
	                    break;
	                }
	        });
	    }
	    Physics.prototype.addWall = function (x, y) {
	        var wall = new p2.Body({ mass: 0, position: [x, y] });
	        var wallShape = new p2.Box({ width: 1, height: 1 });
	        wallShape.material = this.wallMaterial;
	        wall.addShape(wallShape);
	        this.world.addBody(wall);
	        return wall;
	    };
	    Physics.prototype.addTarget = function (x, y) {
	        var t = new p2.Body({ mass: 50, position: [x, y] });
	        var tShape = new p2.Circle({ radius: .5 });
	        tShape.material = this.targetMaterial;
	        t.addShape(tShape);
	        this.world.addBody(t);
	        return t;
	    };
	    Physics.prototype.onHit = function (_a) {
	        var obj1 = _a.obj1, obj2 = _a.obj2, func = _a.func, _b = _a.once, once = _b === void 0 ? false : _b;
	        return this.interact.push({ obj1: obj1, obj2: obj2, func: func, once: once }) - 1;
	    };
	    Physics.prototype.createGalaxy = function (pos) {
	        var shape = new p2.Circle({ radius: 1 / 1.25 });
	        var g = new p2.Body({ mass: 25, position: pos });
	        shape.material = this.galaxyMaterial;
	        g.addShape(shape);
	        g.damping = 0;
	        this.world.addBody(g);
	        return g;
	    };
	    return Physics;
	})();
	exports.Physics = Physics;
	//# sourceMappingURL=physics.js.map

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// Export p2 classes
	var p2 = module.exports = {
	    AABB :                          __webpack_require__(20),
	    AngleLockEquation :             __webpack_require__(28),
	    Body :                          __webpack_require__(9),
	    Broadphase :                    __webpack_require__(29),
	    Capsule :                       __webpack_require__(30),
	    Circle :                        __webpack_require__(26),
	    Constraint :                    __webpack_require__(31),
	    ContactEquation :               __webpack_require__(7),
	    ContactEquationPool :           __webpack_require__(6),
	    ContactMaterial :               __webpack_require__(32),
	    Convex :                        __webpack_require__(15),
	    DistanceConstraint :            __webpack_require__(34),
	    Equation :                      __webpack_require__(8),
	    EventEmitter :                  __webpack_require__(21),
	    FrictionEquation :              __webpack_require__(24),
	    FrictionEquationPool :          __webpack_require__(23),
	    GearConstraint :                __webpack_require__(35),
	    GSSolver :                      __webpack_require__(36),
	    Heightfield :                   __webpack_require__(38),
	    Line :                          __webpack_require__(39),
	    LockConstraint :                __webpack_require__(40),
	    Material :                      __webpack_require__(33),
	    Narrowphase :                   __webpack_require__(3),
	    NaiveBroadphase :               __webpack_require__(41),
	    Particle :                      __webpack_require__(42),
	    Plane :                         __webpack_require__(43),
	    Pool :                          __webpack_require__(22),
	    RevoluteConstraint :            __webpack_require__(44),
	    PrismaticConstraint :           __webpack_require__(47),
	    Ray :                           __webpack_require__(19),
	    RaycastResult :                 __webpack_require__(18),
	    Box :                           __webpack_require__(27),
	    RotationalVelocityEquation :    __webpack_require__(45),
	    SAPBroadphase :                 __webpack_require__(48),
	    Shape :                         __webpack_require__(16),
	    Solver :                        __webpack_require__(37),
	    Spring :                        __webpack_require__(49),
	    TopDownVehicle :                __webpack_require__(50),
	    LinearSpring :                  __webpack_require__(51),
	    RotationalSpring :              __webpack_require__(52),
	    Utils :                         __webpack_require__(5),
	    World :                         __webpack_require__(53),
	    vec2 :                          __webpack_require__(4),
	    version :                       __webpack_require__(54).version,
	};
	
	Object.defineProperty(p2, 'Rectangle', {
	    get: function() {
	        console.warn('The Rectangle class has been renamed to Box.');
	        return this.Box;
	    }
	});

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4)
	,   sub = vec2.sub
	,   add = vec2.add
	,   dot = vec2.dot
	,   Utils = __webpack_require__(5)
	,   ContactEquationPool = __webpack_require__(6)
	,   FrictionEquationPool = __webpack_require__(23)
	,   TupleDictionary = __webpack_require__(25)
	,   Equation = __webpack_require__(8)
	,   ContactEquation = __webpack_require__(7)
	,   FrictionEquation = __webpack_require__(24)
	,   Circle = __webpack_require__(26)
	,   Convex = __webpack_require__(15)
	,   Shape = __webpack_require__(16)
	,   Body = __webpack_require__(9)
	,   Box = __webpack_require__(27);
	
	module.exports = Narrowphase;
	
	// Temp things
	var yAxis = vec2.fromValues(0,1);
	
	var tmp1 = vec2.fromValues(0,0)
	,   tmp2 = vec2.fromValues(0,0)
	,   tmp3 = vec2.fromValues(0,0)
	,   tmp4 = vec2.fromValues(0,0)
	,   tmp5 = vec2.fromValues(0,0)
	,   tmp6 = vec2.fromValues(0,0)
	,   tmp7 = vec2.fromValues(0,0)
	,   tmp8 = vec2.fromValues(0,0)
	,   tmp9 = vec2.fromValues(0,0)
	,   tmp10 = vec2.fromValues(0,0)
	,   tmp11 = vec2.fromValues(0,0)
	,   tmp12 = vec2.fromValues(0,0)
	,   tmp13 = vec2.fromValues(0,0)
	,   tmp14 = vec2.fromValues(0,0)
	,   tmp15 = vec2.fromValues(0,0)
	,   tmp16 = vec2.fromValues(0,0)
	,   tmp17 = vec2.fromValues(0,0)
	,   tmp18 = vec2.fromValues(0,0)
	,   tmpArray = [];
	
	/**
	 * Narrowphase. Creates contacts and friction given shapes and transforms.
	 * @class Narrowphase
	 * @constructor
	 */
	function Narrowphase(){
	
	    /**
	     * @property contactEquations
	     * @type {Array}
	     */
	    this.contactEquations = [];
	
	    /**
	     * @property frictionEquations
	     * @type {Array}
	     */
	    this.frictionEquations = [];
	
	    /**
	     * Whether to make friction equations in the upcoming contacts.
	     * @property enableFriction
	     * @type {Boolean}
	     */
	    this.enableFriction = true;
	
	    /**
	     * Whether to make equations enabled in upcoming contacts.
	     * @property enabledEquations
	     * @type {Boolean}
	     */
	    this.enabledEquations = true;
	
	    /**
	     * The friction slip force to use when creating friction equations.
	     * @property slipForce
	     * @type {Number}
	     */
	    this.slipForce = 10.0;
	
	    /**
	     * The friction value to use in the upcoming friction equations.
	     * @property frictionCoefficient
	     * @type {Number}
	     */
	    this.frictionCoefficient = 0.3;
	
	    /**
	     * Will be the .relativeVelocity in each produced FrictionEquation.
	     * @property {Number} surfaceVelocity
	     */
	    this.surfaceVelocity = 0;
	
	    /**
	     * Keeps track of the allocated ContactEquations.
	     * @property {ContactEquationPool} contactEquationPool
	     *
	     * @example
	     *
	     *     // Allocate a few equations before starting the simulation.
	     *     // This way, no contact objects need to be created on the fly in the game loop.
	     *     world.narrowphase.contactEquationPool.resize(1024);
	     *     world.narrowphase.frictionEquationPool.resize(1024);
	     */
	    this.contactEquationPool = new ContactEquationPool({ size: 32 });
	
	    /**
	     * Keeps track of the allocated ContactEquations.
	     * @property {FrictionEquationPool} frictionEquationPool
	     */
	    this.frictionEquationPool = new FrictionEquationPool({ size: 64 });
	
	    /**
	     * The restitution value to use in the next contact equations.
	     * @property restitution
	     * @type {Number}
	     */
	    this.restitution = 0;
	
	    /**
	     * The stiffness value to use in the next contact equations.
	     * @property {Number} stiffness
	     */
	    this.stiffness = Equation.DEFAULT_STIFFNESS;
	
	    /**
	     * The stiffness value to use in the next contact equations.
	     * @property {Number} stiffness
	     */
	    this.relaxation = Equation.DEFAULT_RELAXATION;
	
	    /**
	     * The stiffness value to use in the next friction equations.
	     * @property frictionStiffness
	     * @type {Number}
	     */
	    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;
	
	    /**
	     * The relaxation value to use in the next friction equations.
	     * @property frictionRelaxation
	     * @type {Number}
	     */
	    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;
	
	    /**
	     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
	     * @property enableFrictionReduction
	     * @type {Boolean}
	     * @deprecated This flag will be removed when the feature is stable enough.
	     * @default true
	     */
	    this.enableFrictionReduction = true;
	
	    /**
	     * Keeps track of the colliding bodies last step.
	     * @private
	     * @property collidingBodiesLastStep
	     * @type {TupleDictionary}
	     */
	    this.collidingBodiesLastStep = new TupleDictionary();
	
	    /**
	     * Contact skin size value to use in the next contact equations.
	     * @property {Number} contactSkinSize
	     * @default 0.01
	     */
	    this.contactSkinSize = 0.01;
	}
	
	var bodiesOverlap_shapePositionA = vec2.create();
	var bodiesOverlap_shapePositionB = vec2.create();
	
	/**
	 * @method bodiesOverlap
	 * @param  {Body} bodyA
	 * @param  {Body} bodyB
	 * @return {Boolean}
	 * @todo shape world transforms are wrong
	 */
	Narrowphase.prototype.bodiesOverlap = function(bodyA, bodyB){
	    var shapePositionA = bodiesOverlap_shapePositionA;
	    var shapePositionB = bodiesOverlap_shapePositionB;
	
	    // Loop over all shapes of bodyA
	    for(var k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){
	        var shapeA = bodyA.shapes[k];
	
	        bodyA.toWorldFrame(shapePositionA, shapeA.position);
	
	        // All shapes of body j
	        for(var l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){
	            var shapeB = bodyB.shapes[l];
	
	            bodyB.toWorldFrame(shapePositionB, shapeB.position);
	
	            if(this[shapeA.type | shapeB.type](
	                bodyA,
	                shapeA,
	                shapePositionA,
	                shapeA.angle + bodyA.angle,
	                bodyB,
	                shapeB,
	                shapePositionB,
	                shapeB.angle + bodyB.angle,
	                true
	            )){
	                return true;
	            }
	        }
	    }
	
	    return false;
	};
	
	/**
	 * Check if the bodies were in contact since the last reset().
	 * @method collidedLastStep
	 * @param  {Body} bodyA
	 * @param  {Body} bodyB
	 * @return {Boolean}
	 */
	Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB){
	    var id1 = bodyA.id|0,
	        id2 = bodyB.id|0;
	    return !!this.collidingBodiesLastStep.get(id1, id2);
	};
	
	/**
	 * Throws away the old equations and gets ready to create new
	 * @method reset
	 */
	Narrowphase.prototype.reset = function(){
	    this.collidingBodiesLastStep.reset();
	
	    var eqs = this.contactEquations;
	    var l = eqs.length;
	    while(l--){
	        var eq = eqs[l],
	            id1 = eq.bodyA.id,
	            id2 = eq.bodyB.id;
	        this.collidingBodiesLastStep.set(id1, id2, true);
	    }
	
	    var ce = this.contactEquations,
	        fe = this.frictionEquations;
	    for(var i=0; i<ce.length; i++){
	        this.contactEquationPool.release(ce[i]);
	    }
	    for(var i=0; i<fe.length; i++){
	        this.frictionEquationPool.release(fe[i]);
	    }
	
	    // Reset
	    this.contactEquations.length = this.frictionEquations.length = 0;
	};
	
	/**
	 * Creates a ContactEquation, either by reusing an existing object or creating a new one.
	 * @method createContactEquation
	 * @param  {Body} bodyA
	 * @param  {Body} bodyB
	 * @return {ContactEquation}
	 */
	Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB){
	    var c = this.contactEquationPool.get();
	    c.bodyA = bodyA;
	    c.bodyB = bodyB;
	    c.shapeA = shapeA;
	    c.shapeB = shapeB;
	    c.restitution = this.restitution;
	    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);
	    c.stiffness = this.stiffness;
	    c.relaxation = this.relaxation;
	    c.needsUpdate = true;
	    c.enabled = this.enabledEquations;
	    c.offset = this.contactSkinSize;
	
	    return c;
	};
	
	/**
	 * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
	 * @method createFrictionEquation
	 * @param  {Body} bodyA
	 * @param  {Body} bodyB
	 * @return {FrictionEquation}
	 */
	Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB){
	    var c = this.frictionEquationPool.get();
	    c.bodyA = bodyA;
	    c.bodyB = bodyB;
	    c.shapeA = shapeA;
	    c.shapeB = shapeB;
	    c.setSlipForce(this.slipForce);
	    c.frictionCoefficient = this.frictionCoefficient;
	    c.relativeVelocity = this.surfaceVelocity;
	    c.enabled = this.enabledEquations;
	    c.needsUpdate = true;
	    c.stiffness = this.frictionStiffness;
	    c.relaxation = this.frictionRelaxation;
	    c.contactEquations.length = 0;
	    return c;
	};
	
	/**
	 * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
	 * @method createFrictionFromContact
	 * @param  {ContactEquation} contactEquation
	 * @return {FrictionEquation}
	 */
	Narrowphase.prototype.createFrictionFromContact = function(c){
	    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
	    vec2.copy(eq.contactPointA, c.contactPointA);
	    vec2.copy(eq.contactPointB, c.contactPointB);
	    vec2.rotate90cw(eq.t, c.normalA);
	    eq.contactEquations.push(c);
	    return eq;
	};
	
	// Take the average N latest contact point on the plane.
	Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
	    var c = this.contactEquations[this.contactEquations.length - 1];
	    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
	    var bodyA = c.bodyA;
	    var bodyB = c.bodyB;
	    vec2.set(eq.contactPointA, 0, 0);
	    vec2.set(eq.contactPointB, 0, 0);
	    vec2.set(eq.t, 0, 0);
	    for(var i=0; i!==numContacts; i++){
	        c = this.contactEquations[this.contactEquations.length - 1 - i];
	        if(c.bodyA === bodyA){
	            vec2.add(eq.t, eq.t, c.normalA);
	            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
	            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
	        } else {
	            vec2.sub(eq.t, eq.t, c.normalA);
	            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
	            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
	        }
	        eq.contactEquations.push(c);
	    }
	
	    var invNumContacts = 1/numContacts;
	    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
	    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
	    vec2.normalize(eq.t, eq.t);
	    vec2.rotate90cw(eq.t, eq.t);
	    return eq;
	};
	
	/**
	 * Convex/line narrowphase
	 * @method convexLine
	 * @param  {Body}       convexBody
	 * @param  {Convex}     convexShape
	 * @param  {Array}      convexOffset
	 * @param  {Number}     convexAngle
	 * @param  {Body}       lineBody
	 * @param  {Line}       lineShape
	 * @param  {Array}      lineOffset
	 * @param  {Number}     lineAngle
	 * @param {boolean}     justTest
	 * @todo Implement me!
	 */
	Narrowphase.prototype[Shape.LINE | Shape.CONVEX] =
	Narrowphase.prototype.convexLine = function(
	    convexBody,
	    convexShape,
	    convexOffset,
	    convexAngle,
	    lineBody,
	    lineShape,
	    lineOffset,
	    lineAngle,
	    justTest
	){
	    // TODO
	    if(justTest){
	        return false;
	    } else {
	        return 0;
	    }
	};
	
	/**
	 * Line/box narrowphase
	 * @method lineBox
	 * @param  {Body}       lineBody
	 * @param  {Line}       lineShape
	 * @param  {Array}      lineOffset
	 * @param  {Number}     lineAngle
	 * @param  {Body}       boxBody
	 * @param  {Box}  boxShape
	 * @param  {Array}      boxOffset
	 * @param  {Number}     boxAngle
	 * @param  {Boolean}    justTest
	 * @todo Implement me!
	 */
	Narrowphase.prototype[Shape.LINE | Shape.BOX] =
	Narrowphase.prototype.lineBox = function(
	    lineBody,
	    lineShape,
	    lineOffset,
	    lineAngle,
	    boxBody,
	    boxShape,
	    boxOffset,
	    boxAngle,
	    justTest
	){
	    // TODO
	    if(justTest){
	        return false;
	    } else {
	        return 0;
	    }
	};
	
	function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){
	    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);
	    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);
	    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);
	    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);
	}
	
	var convexCapsule_tempRect = new Box({ width: 1, height: 1 }),
	    convexCapsule_tempVec = vec2.create();
	
	/**
	 * Convex/capsule narrowphase
	 * @method convexCapsule
	 * @param  {Body}       convexBody
	 * @param  {Convex}     convexShape
	 * @param  {Array}      convexPosition
	 * @param  {Number}     convexAngle
	 * @param  {Body}       capsuleBody
	 * @param  {Capsule}    capsuleShape
	 * @param  {Array}      capsulePosition
	 * @param  {Number}     capsuleAngle
	 */
	Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =
	Narrowphase.prototype[Shape.CAPSULE | Shape.BOX] =
	Narrowphase.prototype.convexCapsule = function(
	    convexBody,
	    convexShape,
	    convexPosition,
	    convexAngle,
	    capsuleBody,
	    capsuleShape,
	    capsulePosition,
	    capsuleAngle,
	    justTest
	){
	
	    // Check the circles
	    // Add offsets!
	    var circlePos = convexCapsule_tempVec;
	    vec2.set(circlePos, capsuleShape.length/2,0);
	    vec2.rotate(circlePos,circlePos,capsuleAngle);
	    vec2.add(circlePos,circlePos,capsulePosition);
	    var result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);
	
	    vec2.set(circlePos,-capsuleShape.length/2, 0);
	    vec2.rotate(circlePos,circlePos,capsuleAngle);
	    vec2.add(circlePos,circlePos,capsulePosition);
	    var result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);
	
	    if(justTest && (result1 || result2)){
	        return true;
	    }
	
	    // Check center rect
	    var r = convexCapsule_tempRect;
	    setConvexToCapsuleShapeMiddle(r,capsuleShape);
	    var result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);
	
	    return result + result1 + result2;
	};
	
	/**
	 * Capsule/line narrowphase
	 * @method lineCapsule
	 * @param  {Body}       lineBody
	 * @param  {Line}       lineShape
	 * @param  {Array}      linePosition
	 * @param  {Number}     lineAngle
	 * @param  {Body}       capsuleBody
	 * @param  {Capsule}    capsuleShape
	 * @param  {Array}      capsulePosition
	 * @param  {Number}     capsuleAngle
	 * @todo Implement me!
	 */
	Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] =
	Narrowphase.prototype.lineCapsule = function(
	    lineBody,
	    lineShape,
	    linePosition,
	    lineAngle,
	    capsuleBody,
	    capsuleShape,
	    capsulePosition,
	    capsuleAngle,
	    justTest
	){
	    // TODO
	    if(justTest){
	        return false;
	    } else {
	        return 0;
	    }
	};
	
	var capsuleCapsule_tempVec1 = vec2.create();
	var capsuleCapsule_tempVec2 = vec2.create();
	var capsuleCapsule_tempRect1 = new Box({ width: 1, height: 1 });
	
	/**
	 * Capsule/capsule narrowphase
	 * @method capsuleCapsule
	 * @param  {Body}       bi
	 * @param  {Capsule}    si
	 * @param  {Array}      xi
	 * @param  {Number}     ai
	 * @param  {Body}       bj
	 * @param  {Capsule}    sj
	 * @param  {Array}      xj
	 * @param  {Number}     aj
	 */
	Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =
	Narrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){
	
	    var enableFrictionBefore;
	
	    // Check the circles
	    // Add offsets!
	    var circlePosi = capsuleCapsule_tempVec1,
	        circlePosj = capsuleCapsule_tempVec2;
	
	    var numContacts = 0;
	
	
	    // Need 4 circle checks, between all
	    for(var i=0; i<2; i++){
	
	        vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
	        vec2.rotate(circlePosi,circlePosi,ai);
	        vec2.add(circlePosi,circlePosi,xi);
	
	        for(var j=0; j<2; j++){
	
	            vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
	            vec2.rotate(circlePosj,circlePosj,aj);
	            vec2.add(circlePosj,circlePosj,xj);
	
	            // Temporarily turn off friction
	            if(this.enableFrictionReduction){
	                enableFrictionBefore = this.enableFriction;
	                this.enableFriction = false;
	            }
	
	            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);
	
	            if(this.enableFrictionReduction){
	                this.enableFriction = enableFrictionBefore;
	            }
	
	            if(justTest && result){
	                return true;
	            }
	
	            numContacts += result;
	        }
	    }
	
	    if(this.enableFrictionReduction){
	        // Temporarily turn off friction
	        enableFrictionBefore = this.enableFriction;
	        this.enableFriction = false;
	    }
	
	    // Check circles against the center boxs
	    var rect = capsuleCapsule_tempRect1;
	    setConvexToCapsuleShapeMiddle(rect,si);
	    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);
	
	    if(this.enableFrictionReduction){
	        this.enableFriction = enableFrictionBefore;
	    }
	
	    if(justTest && result1){
	        return true;
	    }
	    numContacts += result1;
	
	    if(this.enableFrictionReduction){
	        // Temporarily turn off friction
	        var enableFrictionBefore = this.enableFriction;
	        this.enableFriction = false;
	    }
	
	    setConvexToCapsuleShapeMiddle(rect,sj);
	    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);
	
	    if(this.enableFrictionReduction){
	        this.enableFriction = enableFrictionBefore;
	    }
	
	    if(justTest && result2){
	        return true;
	    }
	    numContacts += result2;
	
	    if(this.enableFrictionReduction){
	        if(numContacts && this.enableFriction){
	            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
	        }
	    }
	
	    return numContacts;
	};
	
	/**
	 * Line/line narrowphase
	 * @method lineLine
	 * @param  {Body}       bodyA
	 * @param  {Line}       shapeA
	 * @param  {Array}      positionA
	 * @param  {Number}     angleA
	 * @param  {Body}       bodyB
	 * @param  {Line}       shapeB
	 * @param  {Array}      positionB
	 * @param  {Number}     angleB
	 * @todo Implement me!
	 */
	Narrowphase.prototype[Shape.LINE | Shape.LINE] =
	Narrowphase.prototype.lineLine = function(
	    bodyA,
	    shapeA,
	    positionA,
	    angleA,
	    bodyB,
	    shapeB,
	    positionB,
	    angleB,
	    justTest
	){
	    // TODO
	    if(justTest){
	        return false;
	    } else {
	        return 0;
	    }
	};
	
	/**
	 * Plane/line Narrowphase
	 * @method planeLine
	 * @param  {Body}   planeBody
	 * @param  {Plane}  planeShape
	 * @param  {Array}  planeOffset
	 * @param  {Number} planeAngle
	 * @param  {Body}   lineBody
	 * @param  {Line}   lineShape
	 * @param  {Array}  lineOffset
	 * @param  {Number} lineAngle
	 */
	Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
	Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,
	                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){
	    var worldVertex0 = tmp1,
	        worldVertex1 = tmp2,
	        worldVertex01 = tmp3,
	        worldVertex11 = tmp4,
	        worldEdge = tmp5,
	        worldEdgeUnit = tmp6,
	        dist = tmp7,
	        worldNormal = tmp8,
	        worldTangent = tmp9,
	        verts = tmpArray,
	        numContacts = 0;
	
	    // Get start and end points
	    vec2.set(worldVertex0, -lineShape.length/2, 0);
	    vec2.set(worldVertex1,  lineShape.length/2, 0);
	
	    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
	    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
	    vec2.rotate(worldVertex11, worldVertex1, lineAngle);
	
	    add(worldVertex01, worldVertex01, lineOffset);
	    add(worldVertex11, worldVertex11, lineOffset);
	
	    vec2.copy(worldVertex0,worldVertex01);
	    vec2.copy(worldVertex1,worldVertex11);
	
	    // Get vector along the line
	    sub(worldEdge, worldVertex1, worldVertex0);
	    vec2.normalize(worldEdgeUnit, worldEdge);
	
	    // Get tangent to the edge.
	    vec2.rotate90cw(worldTangent, worldEdgeUnit);
	
	    vec2.rotate(worldNormal, yAxis, planeAngle);
	
	    // Check line ends
	    verts[0] = worldVertex0;
	    verts[1] = worldVertex1;
	    for(var i=0; i<verts.length; i++){
	        var v = verts[i];
	
	        sub(dist, v, planeOffset);
	
	        var d = dot(dist,worldNormal);
	
	        if(d < 0){
	
	            if(justTest){
	                return true;
	            }
	
	            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);
	            numContacts++;
	
	            vec2.copy(c.normalA, worldNormal);
	            vec2.normalize(c.normalA,c.normalA);
	
	            // distance vector along plane normal
	            vec2.scale(dist, worldNormal, d);
	
	            // Vector from plane center to contact
	            sub(c.contactPointA, v, dist);
	            sub(c.contactPointA, c.contactPointA, planeBody.position);
	
	            // From line center to contact
	            sub(c.contactPointB, v,    lineOffset);
	            add(c.contactPointB, c.contactPointB, lineOffset);
	            sub(c.contactPointB, c.contactPointB, lineBody.position);
	
	            this.contactEquations.push(c);
	
	            if(!this.enableFrictionReduction){
	                if(this.enableFriction){
	                    this.frictionEquations.push(this.createFrictionFromContact(c));
	                }
	            }
	        }
	    }
	
	    if(justTest){
	        return false;
	    }
	
	    if(!this.enableFrictionReduction){
	        if(numContacts && this.enableFriction){
	            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
	        }
	    }
	
	    return numContacts;
	};
	
	Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
	Narrowphase.prototype.particleCapsule = function(
	    particleBody,
	    particleShape,
	    particlePosition,
	    particleAngle,
	    capsuleBody,
	    capsuleShape,
	    capsulePosition,
	    capsuleAngle,
	    justTest
	){
	    return this.circleLine(particleBody,particleShape,particlePosition,particleAngle, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);
	};
	
	/**
	 * Circle/line Narrowphase
	 * @method circleLine
	 * @param  {Body} circleBody
	 * @param  {Circle} circleShape
	 * @param  {Array} circleOffset
	 * @param  {Number} circleAngle
	 * @param  {Body} lineBody
	 * @param  {Line} lineShape
	 * @param  {Array} lineOffset
	 * @param  {Number} lineAngle
	 * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
	 * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
	 * @param {Number} circleRadius If set, this value overrides the circle shape radius.
	 */
	Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
	Narrowphase.prototype.circleLine = function(
	    circleBody,
	    circleShape,
	    circleOffset,
	    circleAngle,
	    lineBody,
	    lineShape,
	    lineOffset,
	    lineAngle,
	    justTest,
	    lineRadius,
	    circleRadius
	){
	    var lineRadius = lineRadius || 0,
	        circleRadius = typeof(circleRadius)!=="undefined" ? circleRadius : circleShape.radius,
	
	        orthoDist = tmp1,
	        lineToCircleOrthoUnit = tmp2,
	        projectedPoint = tmp3,
	        centerDist = tmp4,
	        worldTangent = tmp5,
	        worldEdge = tmp6,
	        worldEdgeUnit = tmp7,
	        worldVertex0 = tmp8,
	        worldVertex1 = tmp9,
	        worldVertex01 = tmp10,
	        worldVertex11 = tmp11,
	        dist = tmp12,
	        lineToCircle = tmp13,
	        lineEndToLineRadius = tmp14,
	
	        verts = tmpArray;
	
	    // Get start and end points
	    vec2.set(worldVertex0, -lineShape.length/2, 0);
	    vec2.set(worldVertex1,  lineShape.length/2, 0);
	
	    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
	    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
	    vec2.rotate(worldVertex11, worldVertex1, lineAngle);
	
	    add(worldVertex01, worldVertex01, lineOffset);
	    add(worldVertex11, worldVertex11, lineOffset);
	
	    vec2.copy(worldVertex0,worldVertex01);
	    vec2.copy(worldVertex1,worldVertex11);
	
	    // Get vector along the line
	    sub(worldEdge, worldVertex1, worldVertex0);
	    vec2.normalize(worldEdgeUnit, worldEdge);
	
	    // Get tangent to the edge.
	    vec2.rotate90cw(worldTangent, worldEdgeUnit);
	
	    // Check distance from the plane spanned by the edge vs the circle
	    sub(dist, circleOffset, worldVertex0);
	    var d = dot(dist, worldTangent); // Distance from center of line to circle center
	    sub(centerDist, worldVertex0, lineOffset);
	
	    sub(lineToCircle, circleOffset, lineOffset);
	
	    var radiusSum = circleRadius + lineRadius;
	
	    if(Math.abs(d) < radiusSum){
	
	        // Now project the circle onto the edge
	        vec2.scale(orthoDist, worldTangent, d);
	        sub(projectedPoint, circleOffset, orthoDist);
	
	        // Add the missing line radius
	        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
	        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);
	        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
	        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);
	
	        // Check if the point is within the edge span
	        var pos =  dot(worldEdgeUnit, projectedPoint);
	        var pos0 = dot(worldEdgeUnit, worldVertex0);
	        var pos1 = dot(worldEdgeUnit, worldVertex1);
	
	        if(pos > pos0 && pos < pos1){
	            // We got contact!
	
	            if(justTest){
	                return true;
	            }
	
	            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);
	
	            vec2.scale(c.normalA, orthoDist, -1);
	            vec2.normalize(c.normalA, c.normalA);
	
	            vec2.scale( c.contactPointA, c.normalA,  circleRadius);
	            add(c.contactPointA, c.contactPointA, circleOffset);
	            sub(c.contactPointA, c.contactPointA, circleBody.position);
	
	            sub(c.contactPointB, projectedPoint, lineOffset);
	            add(c.contactPointB, c.contactPointB, lineOffset);
	            sub(c.contactPointB, c.contactPointB, lineBody.position);
	
	            this.contactEquations.push(c);
	
	            if(this.enableFriction){
	                this.frictionEquations.push(this.createFrictionFromContact(c));
	            }
	
	            return 1;
	        }
	    }
	
	    // Add corner
	    verts[0] = worldVertex0;
	    verts[1] = worldVertex1;
	
	    for(var i=0; i<verts.length; i++){
	        var v = verts[i];
	
	        sub(dist, v, circleOffset);
	
	        if(vec2.squaredLength(dist) < Math.pow(radiusSum, 2)){
	
	            if(justTest){
	                return true;
	            }
	
	            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);
	
	            vec2.copy(c.normalA, dist);
	            vec2.normalize(c.normalA,c.normalA);
	
	            // Vector from circle to contact point is the normal times the circle radius
	            vec2.scale(c.contactPointA, c.normalA, circleRadius);
	            add(c.contactPointA, c.contactPointA, circleOffset);
	            sub(c.contactPointA, c.contactPointA, circleBody.position);
	
	            sub(c.contactPointB, v, lineOffset);
	            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
	            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
	            add(c.contactPointB, c.contactPointB, lineOffset);
	            sub(c.contactPointB, c.contactPointB, lineBody.position);
	
	            this.contactEquations.push(c);
	
	            if(this.enableFriction){
	                this.frictionEquations.push(this.createFrictionFromContact(c));
	            }
	
	            return 1;
	        }
	    }
	
	    return 0;
	};
	
	/**
	 * Circle/capsule Narrowphase
	 * @method circleCapsule
	 * @param  {Body}   bi
	 * @param  {Circle} si
	 * @param  {Array}  xi
	 * @param  {Number} ai
	 * @param  {Body}   bj
	 * @param  {Line}   sj
	 * @param  {Array}  xj
	 * @param  {Number} aj
	 */
	Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
	Narrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){
	    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);
	};
	
	/**
	 * Circle/convex Narrowphase.
	 * @method circleConvex
	 * @param  {Body} circleBody
	 * @param  {Circle} circleShape
	 * @param  {Array} circleOffset
	 * @param  {Number} circleAngle
	 * @param  {Body} convexBody
	 * @param  {Convex} convexShape
	 * @param  {Array} convexOffset
	 * @param  {Number} convexAngle
	 * @param  {Boolean} justTest
	 * @param  {Number} circleRadius
	 */
	Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
	Narrowphase.prototype[Shape.CIRCLE | Shape.BOX] =
	Narrowphase.prototype.circleConvex = function(
	    circleBody,
	    circleShape,
	    circleOffset,
	    circleAngle,
	    convexBody,
	    convexShape,
	    convexOffset,
	    convexAngle,
	    justTest,
	    circleRadius
	){
	    var circleRadius = typeof(circleRadius)==="number" ? circleRadius : circleShape.radius;
	
	    var worldVertex0 = tmp1,
	        worldVertex1 = tmp2,
	        worldEdge = tmp3,
	        worldEdgeUnit = tmp4,
	        worldNormal = tmp5,
	        centerDist = tmp6,
	        convexToCircle = tmp7,
	        orthoDist = tmp8,
	        projectedPoint = tmp9,
	        dist = tmp10,
	        worldVertex = tmp11,
	
	        closestEdge = -1,
	        closestEdgeDistance = null,
	        closestEdgeOrthoDist = tmp12,
	        closestEdgeProjectedPoint = tmp13,
	        candidate = tmp14,
	        candidateDist = tmp15,
	        minCandidate = tmp16,
	
	        found = false,
	        minCandidateDistance = Number.MAX_VALUE;
	
	    var numReported = 0;
	
	    // New algorithm:
	    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
	    // 2. For each edge
	    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
	    // 2. 2. Check if point is inside.
	
	    var verts = convexShape.vertices;
	
	    // Check all edges first
	    for(var i=0; i!==verts.length+1; i++){
	        var v0 = verts[i%verts.length],
	            v1 = verts[(i+1)%verts.length];
	
	        vec2.rotate(worldVertex0, v0, convexAngle);
	        vec2.rotate(worldVertex1, v1, convexAngle);
	        add(worldVertex0, worldVertex0, convexOffset);
	        add(worldVertex1, worldVertex1, convexOffset);
	        sub(worldEdge, worldVertex1, worldVertex0);
	
	        vec2.normalize(worldEdgeUnit, worldEdge);
	
	        // Get tangent to the edge. Points out of the Convex
	        vec2.rotate90cw(worldNormal, worldEdgeUnit);
	
	        // Get point on circle, closest to the polygon
	        vec2.scale(candidate,worldNormal,-circleShape.radius);
	        add(candidate,candidate,circleOffset);
	
	        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){
	
	            vec2.sub(candidateDist,worldVertex0,candidate);
	            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldNormal));
	
	            if(candidateDistance < minCandidateDistance){
	                vec2.copy(minCandidate,candidate);
	                minCandidateDistance = candidateDistance;
	                vec2.scale(closestEdgeProjectedPoint,worldNormal,candidateDistance);
	                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);
	                found = true;
	            }
	        }
	    }
	
	    if(found){
	
	        if(justTest){
	            return true;
	        }
	
	        var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);
	        vec2.sub(c.normalA, minCandidate, circleOffset);
	        vec2.normalize(c.normalA, c.normalA);
	
	        vec2.scale(c.contactPointA,  c.normalA, circleRadius);
	        add(c.contactPointA, c.contactPointA, circleOffset);
	        sub(c.contactPointA, c.contactPointA, circleBody.position);
	
	        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
	        add(c.contactPointB, c.contactPointB, convexOffset);
	        sub(c.contactPointB, c.contactPointB, convexBody.position);
	
	        this.contactEquations.push(c);
	
	        if(this.enableFriction){
	            this.frictionEquations.push( this.createFrictionFromContact(c) );
	        }
	
	        return 1;
	    }
	
	    // Check all vertices
	    if(circleRadius > 0){
	        for(var i=0; i<verts.length; i++){
	            var localVertex = verts[i];
	            vec2.rotate(worldVertex, localVertex, convexAngle);
	            add(worldVertex, worldVertex, convexOffset);
	
	            sub(dist, worldVertex, circleOffset);
	            if(vec2.squaredLength(dist) < Math.pow(circleRadius, 2)){
	
	                if(justTest){
	                    return true;
	                }
	
	                var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);
	
	                vec2.copy(c.normalA, dist);
	                vec2.normalize(c.normalA,c.normalA);
	
	                // Vector from circle to contact point is the normal times the circle radius
	                vec2.scale(c.contactPointA, c.normalA, circleRadius);
	                add(c.contactPointA, c.contactPointA, circleOffset);
	                sub(c.contactPointA, c.contactPointA, circleBody.position);
	
	                sub(c.contactPointB, worldVertex, convexOffset);
	                add(c.contactPointB, c.contactPointB, convexOffset);
	                sub(c.contactPointB, c.contactPointB, convexBody.position);
	
	                this.contactEquations.push(c);
	
	                if(this.enableFriction){
	                    this.frictionEquations.push(this.createFrictionFromContact(c));
	                }
	
	                return 1;
	            }
	        }
	    }
	
	    return 0;
	};
	
	var pic_worldVertex0 = vec2.create(),
	    pic_worldVertex1 = vec2.create(),
	    pic_r0 = vec2.create(),
	    pic_r1 = vec2.create();
	
	/*
	 * Check if a point is in a polygon
	 */
	function pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){
	    var worldVertex0 = pic_worldVertex0,
	        worldVertex1 = pic_worldVertex1,
	        r0 = pic_r0,
	        r1 = pic_r1,
	        point = worldPoint,
	        verts = convexShape.vertices,
	        lastCross = null;
	    for(var i=0; i!==verts.length+1; i++){
	        var v0 = verts[i%verts.length],
	            v1 = verts[(i+1)%verts.length];
	
	        // Transform vertices to world
	        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex
	        vec2.rotate(worldVertex0, v0, convexAngle);
	        vec2.rotate(worldVertex1, v1, convexAngle);
	        add(worldVertex0, worldVertex0, convexOffset);
	        add(worldVertex1, worldVertex1, convexOffset);
	
	        sub(r0, worldVertex0, point);
	        sub(r1, worldVertex1, point);
	        var cross = vec2.crossLength(r0,r1);
	
	        if(lastCross===null){
	            lastCross = cross;
	        }
	
	        // If we got a different sign of the distance vector, the point is out of the polygon
	        if(cross*lastCross <= 0){
	            return false;
	        }
	        lastCross = cross;
	    }
	    return true;
	}
	
	/**
	 * Particle/convex Narrowphase
	 * @method particleConvex
	 * @param  {Body} particleBody
	 * @param  {Particle} particleShape
	 * @param  {Array} particleOffset
	 * @param  {Number} particleAngle
	 * @param  {Body} convexBody
	 * @param  {Convex} convexShape
	 * @param  {Array} convexOffset
	 * @param  {Number} convexAngle
	 * @param {Boolean} justTest
	 * @todo use pointInConvex and code more similar to circleConvex
	 * @todo don't transform each vertex, but transform the particle position to convex-local instead
	 */
	Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
	Narrowphase.prototype[Shape.PARTICLE | Shape.BOX] =
	Narrowphase.prototype.particleConvex = function(
	    particleBody,
	    particleShape,
	    particleOffset,
	    particleAngle,
	    convexBody,
	    convexShape,
	    convexOffset,
	    convexAngle,
	    justTest
	){
	    var worldVertex0 = tmp1,
	        worldVertex1 = tmp2,
	        worldEdge = tmp3,
	        worldEdgeUnit = tmp4,
	        worldTangent = tmp5,
	        centerDist = tmp6,
	        convexToparticle = tmp7,
	        orthoDist = tmp8,
	        projectedPoint = tmp9,
	        dist = tmp10,
	        worldVertex = tmp11,
	        closestEdge = -1,
	        closestEdgeDistance = null,
	        closestEdgeOrthoDist = tmp12,
	        closestEdgeProjectedPoint = tmp13,
	        r0 = tmp14, // vector from particle to vertex0
	        r1 = tmp15,
	        localPoint = tmp16,
	        candidateDist = tmp17,
	        minEdgeNormal = tmp18,
	        minCandidateDistance = Number.MAX_VALUE;
	
	    var numReported = 0,
	        found = false,
	        verts = convexShape.vertices;
	
	    // Check if the particle is in the polygon at all
	    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){
	        return 0;
	    }
	
	    if(justTest){
	        return true;
	    }
	
	    // Check edges first
	    var lastCross = null;
	    for(var i=0; i!==verts.length+1; i++){
	        var v0 = verts[i%verts.length],
	            v1 = verts[(i+1)%verts.length];
	
	        // Transform vertices to world
	        vec2.rotate(worldVertex0, v0, convexAngle);
	        vec2.rotate(worldVertex1, v1, convexAngle);
	        add(worldVertex0, worldVertex0, convexOffset);
	        add(worldVertex1, worldVertex1, convexOffset);
	
	        // Get world edge
	        sub(worldEdge, worldVertex1, worldVertex0);
	        vec2.normalize(worldEdgeUnit, worldEdge);
	
	        // Get tangent to the edge. Points out of the Convex
	        vec2.rotate90cw(worldTangent, worldEdgeUnit);
	
	        // Check distance from the infinite line (spanned by the edge) to the particle
	        sub(dist, particleOffset, worldVertex0);
	        var d = dot(dist, worldTangent);
	        sub(centerDist, worldVertex0, convexOffset);
	
	        sub(convexToparticle, particleOffset, convexOffset);
	
	        vec2.sub(candidateDist,worldVertex0,particleOffset);
	        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));
	
	        if(candidateDistance < minCandidateDistance){
	            minCandidateDistance = candidateDistance;
	            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);
	            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);
	            vec2.copy(minEdgeNormal,worldTangent);
	            found = true;
	        }
	    }
	
	    if(found){
	        var c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);
	
	        vec2.scale(c.normalA, minEdgeNormal, -1);
	        vec2.normalize(c.normalA, c.normalA);
	
	        // Particle has no extent to the contact point
	        vec2.set(c.contactPointA,  0, 0);
	        add(c.contactPointA, c.contactPointA, particleOffset);
	        sub(c.contactPointA, c.contactPointA, particleBody.position);
	
	        // From convex center to point
	        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
	        add(c.contactPointB, c.contactPointB, convexOffset);
	        sub(c.contactPointB, c.contactPointB, convexBody.position);
	
	        this.contactEquations.push(c);
	
	        if(this.enableFriction){
	            this.frictionEquations.push( this.createFrictionFromContact(c) );
	        }
	
	        return 1;
	    }
	
	
	    return 0;
	};
	
	/**
	 * Circle/circle Narrowphase
	 * @method circleCircle
	 * @param  {Body} bodyA
	 * @param  {Circle} shapeA
	 * @param  {Array} offsetA
	 * @param  {Number} angleA
	 * @param  {Body} bodyB
	 * @param  {Circle} shapeB
	 * @param  {Array} offsetB
	 * @param  {Number} angleB
	 * @param {Boolean} justTest
	 * @param {Number} [radiusA] Optional radius to use for shapeA
	 * @param {Number} [radiusB] Optional radius to use for shapeB
	 */
	Narrowphase.prototype[Shape.CIRCLE] =
	Narrowphase.prototype.circleCircle = function(
	    bodyA,
	    shapeA,
	    offsetA,
	    angleA,
	    bodyB,
	    shapeB,
	    offsetB,
	    angleB,
	    justTest,
	    radiusA,
	    radiusB
	){
	
	    var dist = tmp1,
	        radiusA = radiusA || shapeA.radius,
	        radiusB = radiusB || shapeB.radius;
	
	    sub(dist,offsetA,offsetB);
	    var r = radiusA + radiusB;
	    if(vec2.squaredLength(dist) > Math.pow(r,2)){
	        return 0;
	    }
	
	    if(justTest){
	        return true;
	    }
	
	    var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
	    sub(c.normalA, offsetB, offsetA);
	    vec2.normalize(c.normalA,c.normalA);
	
	    vec2.scale( c.contactPointA, c.normalA,  radiusA);
	    vec2.scale( c.contactPointB, c.normalA, -radiusB);
	
	    add(c.contactPointA, c.contactPointA, offsetA);
	    sub(c.contactPointA, c.contactPointA, bodyA.position);
	
	    add(c.contactPointB, c.contactPointB, offsetB);
	    sub(c.contactPointB, c.contactPointB, bodyB.position);
	
	    this.contactEquations.push(c);
	
	    if(this.enableFriction){
	        this.frictionEquations.push(this.createFrictionFromContact(c));
	    }
	    return 1;
	};
	
	/**
	 * Plane/Convex Narrowphase
	 * @method planeConvex
	 * @param  {Body} planeBody
	 * @param  {Plane} planeShape
	 * @param  {Array} planeOffset
	 * @param  {Number} planeAngle
	 * @param  {Body} convexBody
	 * @param  {Convex} convexShape
	 * @param  {Array} convexOffset
	 * @param  {Number} convexAngle
	 * @param {Boolean} justTest
	 */
	Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
	Narrowphase.prototype[Shape.PLANE | Shape.BOX] =
	Narrowphase.prototype.planeConvex = function(
	    planeBody,
	    planeShape,
	    planeOffset,
	    planeAngle,
	    convexBody,
	    convexShape,
	    convexOffset,
	    convexAngle,
	    justTest
	){
	    var worldVertex = tmp1,
	        worldNormal = tmp2,
	        dist = tmp3;
	
	    var numReported = 0;
	    vec2.rotate(worldNormal, yAxis, planeAngle);
	
	    for(var i=0; i!==convexShape.vertices.length; i++){
	        var v = convexShape.vertices[i];
	        vec2.rotate(worldVertex, v, convexAngle);
	        add(worldVertex, worldVertex, convexOffset);
	
	        sub(dist, worldVertex, planeOffset);
	
	        if(dot(dist,worldNormal) <= 0){
	
	            if(justTest){
	                return true;
	            }
	
	            // Found vertex
	            numReported++;
	
	            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);
	
	            sub(dist, worldVertex, planeOffset);
	
	            vec2.copy(c.normalA, worldNormal);
	
	            var d = dot(dist, c.normalA);
	            vec2.scale(dist, c.normalA, d);
	
	            // rj is from convex center to contact
	            sub(c.contactPointB, worldVertex, convexBody.position);
	
	
	            // ri is from plane center to contact
	            sub( c.contactPointA, worldVertex, dist);
	            sub( c.contactPointA, c.contactPointA, planeBody.position);
	
	            this.contactEquations.push(c);
	
	            if(!this.enableFrictionReduction){
	                if(this.enableFriction){
	                    this.frictionEquations.push(this.createFrictionFromContact(c));
	                }
	            }
	        }
	    }
	
	    if(this.enableFrictionReduction){
	        if(this.enableFriction && numReported){
	            this.frictionEquations.push(this.createFrictionFromAverage(numReported));
	        }
	    }
	
	    return numReported;
	};
	
	/**
	 * Narrowphase for particle vs plane
	 * @method particlePlane
	 * @param  {Body}       particleBody
	 * @param  {Particle}   particleShape
	 * @param  {Array}      particleOffset
	 * @param  {Number}     particleAngle
	 * @param  {Body}       planeBody
	 * @param  {Plane}      planeShape
	 * @param  {Array}      planeOffset
	 * @param  {Number}     planeAngle
	 * @param {Boolean}     justTest
	 */
	Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
	Narrowphase.prototype.particlePlane = function(
	    particleBody,
	    particleShape,
	    particleOffset,
	    particleAngle,
	    planeBody,
	    planeShape,
	    planeOffset,
	    planeAngle,
	    justTest
	){
	    var dist = tmp1,
	        worldNormal = tmp2;
	
	    planeAngle = planeAngle || 0;
	
	    sub(dist, particleOffset, planeOffset);
	    vec2.rotate(worldNormal, yAxis, planeAngle);
	
	    var d = dot(dist, worldNormal);
	
	    if(d > 0){
	        return 0;
	    }
	    if(justTest){
	        return true;
	    }
	
	    var c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);
	
	    vec2.copy(c.normalA, worldNormal);
	    vec2.scale( dist, c.normalA, d );
	    // dist is now the distance vector in the normal direction
	
	    // ri is the particle position projected down onto the plane, from the plane center
	    sub( c.contactPointA, particleOffset, dist);
	    sub( c.contactPointA, c.contactPointA, planeBody.position);
	
	    // rj is from the body center to the particle center
	    sub( c.contactPointB, particleOffset, particleBody.position );
	
	    this.contactEquations.push(c);
	
	    if(this.enableFriction){
	        this.frictionEquations.push(this.createFrictionFromContact(c));
	    }
	    return 1;
	};
	
	/**
	 * Circle/Particle Narrowphase
	 * @method circleParticle
	 * @param  {Body} circleBody
	 * @param  {Circle} circleShape
	 * @param  {Array} circleOffset
	 * @param  {Number} circleAngle
	 * @param  {Body} particleBody
	 * @param  {Particle} particleShape
	 * @param  {Array} particleOffset
	 * @param  {Number} particleAngle
	 * @param  {Boolean} justTest
	 */
	Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
	Narrowphase.prototype.circleParticle = function(
	    circleBody,
	    circleShape,
	    circleOffset,
	    circleAngle,
	    particleBody,
	    particleShape,
	    particleOffset,
	    particleAngle,
	    justTest
	){
	    var dist = tmp1;
	
	    sub(dist, particleOffset, circleOffset);
	    if(vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)){
	        return 0;
	    }
	    if(justTest){
	        return true;
	    }
	
	    var c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);
	    vec2.copy(c.normalA, dist);
	    vec2.normalize(c.normalA,c.normalA);
	
	    // Vector from circle to contact point is the normal times the circle radius
	    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
	    add(c.contactPointA, c.contactPointA, circleOffset);
	    sub(c.contactPointA, c.contactPointA, circleBody.position);
	
	    // Vector from particle center to contact point is zero
	    sub(c.contactPointB, particleOffset, particleBody.position);
	
	    this.contactEquations.push(c);
	
	    if(this.enableFriction){
	        this.frictionEquations.push(this.createFrictionFromContact(c));
	    }
	
	    return 1;
	};
	
	var planeCapsule_tmpCircle = new Circle({ radius: 1 }),
	    planeCapsule_tmp1 = vec2.create(),
	    planeCapsule_tmp2 = vec2.create(),
	    planeCapsule_tmp3 = vec2.create();
	
	/**
	 * @method planeCapsule
	 * @param  {Body} planeBody
	 * @param  {Circle} planeShape
	 * @param  {Array} planeOffset
	 * @param  {Number} planeAngle
	 * @param  {Body} capsuleBody
	 * @param  {Particle} capsuleShape
	 * @param  {Array} capsuleOffset
	 * @param  {Number} capsuleAngle
	 * @param {Boolean} justTest
	 */
	Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
	Narrowphase.prototype.planeCapsule = function(
	    planeBody,
	    planeShape,
	    planeOffset,
	    planeAngle,
	    capsuleBody,
	    capsuleShape,
	    capsuleOffset,
	    capsuleAngle,
	    justTest
	){
	    var end1 = planeCapsule_tmp1,
	        end2 = planeCapsule_tmp2,
	        circle = planeCapsule_tmpCircle,
	        dst = planeCapsule_tmp3;
	
	    // Compute world end positions
	    vec2.set(end1, -capsuleShape.length/2, 0);
	    vec2.rotate(end1,end1,capsuleAngle);
	    add(end1,end1,capsuleOffset);
	
	    vec2.set(end2,  capsuleShape.length/2, 0);
	    vec2.rotate(end2,end2,capsuleAngle);
	    add(end2,end2,capsuleOffset);
	
	    circle.radius = capsuleShape.radius;
	
	    var enableFrictionBefore;
	
	    // Temporarily turn off friction
	    if(this.enableFrictionReduction){
	        enableFrictionBefore = this.enableFriction;
	        this.enableFriction = false;
	    }
	
	    // Do Narrowphase as two circles
	    var numContacts1 = this.circlePlane(capsuleBody,circle,end1,0, planeBody,planeShape,planeOffset,planeAngle, justTest),
	        numContacts2 = this.circlePlane(capsuleBody,circle,end2,0, planeBody,planeShape,planeOffset,planeAngle, justTest);
	
	    // Restore friction
	    if(this.enableFrictionReduction){
	        this.enableFriction = enableFrictionBefore;
	    }
	
	    if(justTest){
	        return numContacts1 || numContacts2;
	    } else {
	        var numTotal = numContacts1 + numContacts2;
	        if(this.enableFrictionReduction){
	            if(numTotal){
	                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
	            }
	        }
	        return numTotal;
	    }
	};
	
	/**
	 * Creates ContactEquations and FrictionEquations for a collision.
	 * @method circlePlane
	 * @param  {Body}    bi     The first body that should be connected to the equations.
	 * @param  {Circle}  si     The circle shape participating in the collision.
	 * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.
	 * @param  {Body}    bj     The second body that should be connected to the equations.
	 * @param  {Plane}   sj     The Plane shape that is participating
	 * @param  {Array}   xj     Extra offset for the plane shape.
	 * @param  {Number}  aj     Extra angle to apply to the plane
	 */
	Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
	Narrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){
	    var circleBody = bi,
	        circleShape = si,
	        circleOffset = xi, // Offset from body center, rotated!
	        planeBody = bj,
	        shapeB = sj,
	        planeOffset = xj,
	        planeAngle = aj;
	
	    planeAngle = planeAngle || 0;
	
	    // Vector from plane to circle
	    var planeToCircle = tmp1,
	        worldNormal = tmp2,
	        temp = tmp3;
	
	    sub(planeToCircle, circleOffset, planeOffset);
	
	    // World plane normal
	    vec2.rotate(worldNormal, yAxis, planeAngle);
	
	    // Normal direction distance
	    var d = dot(worldNormal, planeToCircle);
	
	    if(d > circleShape.radius){
	        return 0; // No overlap. Abort.
	    }
	
	    if(justTest){
	        return true;
	    }
	
	    // Create contact
	    var contact = this.createContactEquation(planeBody,circleBody,sj,si);
	
	    // ni is the plane world normal
	    vec2.copy(contact.normalA, worldNormal);
	
	    // rj is the vector from circle center to the contact point
	    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
	    add(contact.contactPointB, contact.contactPointB, circleOffset);
	    sub(contact.contactPointB, contact.contactPointB, circleBody.position);
	
	    // ri is the distance from plane center to contact.
	    vec2.scale(temp, contact.normalA, d);
	    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector
	    add(contact.contactPointA, contact.contactPointA, planeOffset);
	    sub(contact.contactPointA, contact.contactPointA, planeBody.position);
	
	    this.contactEquations.push(contact);
	
	    if(this.enableFriction){
	        this.frictionEquations.push( this.createFrictionFromContact(contact) );
	    }
	
	    return 1;
	};
	
	/**
	 * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
	 * @method convexConvex
	 * @param  {Body} bi
	 * @param  {Convex} si
	 * @param  {Array} xi
	 * @param  {Number} ai
	 * @param  {Body} bj
	 * @param  {Convex} sj
	 * @param  {Array} xj
	 * @param  {Number} aj
	 */
	Narrowphase.prototype[Shape.CONVEX] =
	Narrowphase.prototype[Shape.CONVEX | Shape.BOX] =
	Narrowphase.prototype[Shape.BOX] =
	Narrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){
	    var sepAxis = tmp1,
	        worldPoint = tmp2,
	        worldPoint0 = tmp3,
	        worldPoint1 = tmp4,
	        worldEdge = tmp5,
	        projected = tmp6,
	        penetrationVec = tmp7,
	        dist = tmp8,
	        worldNormal = tmp9,
	        numContacts = 0,
	        precision = typeof(precision) === 'number' ? precision : 0;
	
	    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);
	    if(!found){
	        return 0;
	    }
	
	    // Make sure the separating axis is directed from shape i to shape j
	    sub(dist,xj,xi);
	    if(dot(sepAxis,dist) > 0){
	        vec2.scale(sepAxis,sepAxis,-1);
	    }
	
	    // Find edges with normals closest to the separating axis
	    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis
	        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);
	
	    if(closestEdge1 === -1 || closestEdge2 === -1){
	        return 0;
	    }
	
	    // Loop over the shapes
	    for(var k=0; k<2; k++){
	
	        var closestEdgeA = closestEdge1,
	            closestEdgeB = closestEdge2,
	            shapeA =  si, shapeB =  sj,
	            offsetA = xi, offsetB = xj,
	            angleA = ai, angleB = aj,
	            bodyA = bi, bodyB = bj;
	
	        if(k === 0){
	            // Swap!
	            var tmp;
	            tmp = closestEdgeA;
	            closestEdgeA = closestEdgeB;
	            closestEdgeB = tmp;
	
	            tmp = shapeA;
	            shapeA = shapeB;
	            shapeB = tmp;
	
	            tmp = offsetA;
	            offsetA = offsetB;
	            offsetB = tmp;
	
	            tmp = angleA;
	            angleA = angleB;
	            angleB = tmp;
	
	            tmp = bodyA;
	            bodyA = bodyB;
	            bodyB = tmp;
	        }
	
	        // Loop over 2 points in convex B
	        for(var j=closestEdgeB; j<closestEdgeB+2; j++){
	
	            // Get world point
	            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];
	            vec2.rotate(worldPoint, v, angleB);
	            add(worldPoint, worldPoint, offsetB);
	
	            var insideNumEdges = 0;
	
	            // Loop over the 3 closest edges in convex A
	            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){
	
	                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],
	                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];
	
	                // Construct the edge
	                vec2.rotate(worldPoint0, v0, angleA);
	                vec2.rotate(worldPoint1, v1, angleA);
	                add(worldPoint0, worldPoint0, offsetA);
	                add(worldPoint1, worldPoint1, offsetA);
	
	                sub(worldEdge, worldPoint1, worldPoint0);
	
	                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1
	                vec2.normalize(worldNormal,worldNormal);
	
	                sub(dist, worldPoint, worldPoint0);
	
	                var d = dot(worldNormal,dist);
	
	                if((i === closestEdgeA && d <= precision) || (i !== closestEdgeA && d <= 0)){
	                    insideNumEdges++;
	                }
	            }
	
	            if(insideNumEdges >= 3){
	
	                if(justTest){
	                    return true;
	                }
	
	                // worldPoint was on the "inside" side of each of the 3 checked edges.
	                // Project it to the center edge and use the projection direction as normal
	
	                // Create contact
	                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
	                numContacts++;
	
	                // Get center edge from body A
	                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],
	                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];
	
	                // Construct the edge
	                vec2.rotate(worldPoint0, v0, angleA);
	                vec2.rotate(worldPoint1, v1, angleA);
	                add(worldPoint0, worldPoint0, offsetA);
	                add(worldPoint1, worldPoint1, offsetA);
	
	                sub(worldEdge, worldPoint1, worldPoint0);
	
	                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A
	                vec2.normalize(c.normalA,c.normalA);
	
	                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point
	                var d = dot(c.normalA,dist);             // Penetration
	                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration
	
	                sub(c.contactPointA, worldPoint, offsetA);
	                sub(c.contactPointA, c.contactPointA, penetrationVec);
	                add(c.contactPointA, c.contactPointA, offsetA);
	                sub(c.contactPointA, c.contactPointA, bodyA.position);
	
	                sub(c.contactPointB, worldPoint, offsetB);
	                add(c.contactPointB, c.contactPointB, offsetB);
	                sub(c.contactPointB, c.contactPointB, bodyB.position);
	
	                this.contactEquations.push(c);
	
	                // Todo reduce to 1 friction equation if we have 2 contact points
	                if(!this.enableFrictionReduction){
	                    if(this.enableFriction){
	                        this.frictionEquations.push(this.createFrictionFromContact(c));
	                    }
	                }
	            }
	        }
	    }
	
	    if(this.enableFrictionReduction){
	        if(this.enableFriction && numContacts){
	            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
	        }
	    }
	
	    return numContacts;
	};
	
	// .projectConvex is called by other functions, need local tmp vectors
	var pcoa_tmp1 = vec2.fromValues(0,0);
	
	/**
	 * Project a Convex onto a world-oriented axis
	 * @method projectConvexOntoAxis
	 * @static
	 * @param  {Convex} convexShape
	 * @param  {Array} convexOffset
	 * @param  {Number} convexAngle
	 * @param  {Array} worldAxis
	 * @param  {Array} result
	 */
	Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){
	    var max=null,
	        min=null,
	        v,
	        value,
	        localAxis = pcoa_tmp1;
	
	    // Convert the axis to local coords of the body
	    vec2.rotate(localAxis, worldAxis, -convexAngle);
	
	    // Get projected position of all vertices
	    for(var i=0; i<convexShape.vertices.length; i++){
	        v = convexShape.vertices[i];
	        value = dot(v,localAxis);
	        if(max === null || value > max){
	            max = value;
	        }
	        if(min === null || value < min){
	            min = value;
	        }
	    }
	
	    if(min > max){
	        var t = min;
	        min = max;
	        max = t;
	    }
	
	    // Project the position of the body onto the axis - need to add this to the result
	    var offset = dot(convexOffset, worldAxis);
	
	    vec2.set( result, min + offset, max + offset);
	};
	
	// .findSeparatingAxis is called by other functions, need local tmp vectors
	var fsa_tmp1 = vec2.fromValues(0,0)
	,   fsa_tmp2 = vec2.fromValues(0,0)
	,   fsa_tmp3 = vec2.fromValues(0,0)
	,   fsa_tmp4 = vec2.fromValues(0,0)
	,   fsa_tmp5 = vec2.fromValues(0,0)
	,   fsa_tmp6 = vec2.fromValues(0,0);
	
	/**
	 * Find a separating axis between the shapes, that maximizes the separating distance between them.
	 * @method findSeparatingAxis
	 * @static
	 * @param  {Convex}     c1
	 * @param  {Array}      offset1
	 * @param  {Number}     angle1
	 * @param  {Convex}     c2
	 * @param  {Array}      offset2
	 * @param  {Number}     angle2
	 * @param  {Array}      sepAxis     The resulting axis
	 * @return {Boolean}                Whether the axis could be found.
	 */
	Narrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){
	    var maxDist = null,
	        overlap = false,
	        found = false,
	        edge = fsa_tmp1,
	        worldPoint0 = fsa_tmp2,
	        worldPoint1 = fsa_tmp3,
	        normal = fsa_tmp4,
	        span1 = fsa_tmp5,
	        span2 = fsa_tmp6;
	
	    if(c1 instanceof Box && c2 instanceof Box){
	
	        for(var j=0; j!==2; j++){
	            var c = c1,
	                angle = angle1;
	            if(j===1){
	                c = c2;
	                angle = angle2;
	            }
	
	            for(var i=0; i!==2; i++){
	
	                // Get the world edge
	                if(i === 0){
	                    vec2.set(normal, 0, 1);
	                } else if(i === 1) {
	                    vec2.set(normal, 1, 0);
	                }
	                if(angle !== 0){
	                    vec2.rotate(normal, normal, angle);
	                }
	
	                // Project hulls onto that normal
	                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
	                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);
	
	                // Order by span position
	                var a=span1,
	                    b=span2,
	                    swapped = false;
	                if(span1[0] > span2[0]){
	                    b=span1;
	                    a=span2;
	                    swapped = true;
	                }
	
	                // Get separating distance
	                var dist = b[0] - a[1];
	                overlap = (dist <= 0);
	
	                if(maxDist===null || dist > maxDist){
	                    vec2.copy(sepAxis, normal);
	                    maxDist = dist;
	                    found = overlap;
	                }
	            }
	        }
	
	    } else {
	
	        for(var j=0; j!==2; j++){
	            var c = c1,
	                angle = angle1;
	            if(j===1){
	                c = c2;
	                angle = angle2;
	            }
	
	            for(var i=0; i!==c.vertices.length; i++){
	                // Get the world edge
	                vec2.rotate(worldPoint0, c.vertices[i], angle);
	                vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);
	
	                sub(edge, worldPoint1, worldPoint0);
	
	                // Get normal - just rotate 90 degrees since vertices are given in CCW
	                vec2.rotate90cw(normal, edge);
	                vec2.normalize(normal,normal);
	
	                // Project hulls onto that normal
	                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
	                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);
	
	                // Order by span position
	                var a=span1,
	                    b=span2,
	                    swapped = false;
	                if(span1[0] > span2[0]){
	                    b=span1;
	                    a=span2;
	                    swapped = true;
	                }
	
	                // Get separating distance
	                var dist = b[0] - a[1];
	                overlap = (dist <= 0);
	
	                if(maxDist===null || dist > maxDist){
	                    vec2.copy(sepAxis, normal);
	                    maxDist = dist;
	                    found = overlap;
	                }
	            }
	        }
	    }
	
	
	    /*
	    // Needs to be tested some more
	    for(var j=0; j!==2; j++){
	        var c = c1,
	            angle = angle1;
	        if(j===1){
	            c = c2;
	            angle = angle2;
	        }
	
	        for(var i=0; i!==c.axes.length; i++){
	
	            var normal = c.axes[i];
	
	            // Project hulls onto that normal
	            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
	            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
	
	            // Order by span position
	            var a=span1,
	                b=span2,
	                swapped = false;
	            if(span1[0] > span2[0]){
	                b=span1;
	                a=span2;
	                swapped = true;
	            }
	
	            // Get separating distance
	            var dist = b[0] - a[1];
	            overlap = (dist <= Narrowphase.convexPrecision);
	
	            if(maxDist===null || dist > maxDist){
	                vec2.copy(sepAxis, normal);
	                maxDist = dist;
	                found = overlap;
	            }
	        }
	    }
	    */
	
	    return found;
	};
	
	// .getClosestEdge is called by other functions, need local tmp vectors
	var gce_tmp1 = vec2.fromValues(0,0)
	,   gce_tmp2 = vec2.fromValues(0,0)
	,   gce_tmp3 = vec2.fromValues(0,0);
	
	/**
	 * Get the edge that has a normal closest to an axis.
	 * @method getClosestEdge
	 * @static
	 * @param  {Convex}     c
	 * @param  {Number}     angle
	 * @param  {Array}      axis
	 * @param  {Boolean}    flip
	 * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.
	 */
	Narrowphase.getClosestEdge = function(c,angle,axis,flip){
	    var localAxis = gce_tmp1,
	        edge = gce_tmp2,
	        normal = gce_tmp3;
	
	    // Convert the axis to local coords of the body
	    vec2.rotate(localAxis, axis, -angle);
	    if(flip){
	        vec2.scale(localAxis,localAxis,-1);
	    }
	
	    var closestEdge = -1,
	        N = c.vertices.length,
	        maxDot = -1;
	    for(var i=0; i!==N; i++){
	        // Get the edge
	        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);
	
	        // Get normal - just rotate 90 degrees since vertices are given in CCW
	        vec2.rotate90cw(normal, edge);
	        vec2.normalize(normal,normal);
	
	        var d = dot(normal,localAxis);
	        if(closestEdge === -1 || d > maxDot){
	            closestEdge = i % N;
	            maxDot = d;
	        }
	    }
	
	    return closestEdge;
	};
	
	var circleHeightfield_candidate = vec2.create(),
	    circleHeightfield_dist = vec2.create(),
	    circleHeightfield_v0 = vec2.create(),
	    circleHeightfield_v1 = vec2.create(),
	    circleHeightfield_minCandidate = vec2.create(),
	    circleHeightfield_worldNormal = vec2.create(),
	    circleHeightfield_minCandidateNormal = vec2.create();
	
	/**
	 * @method circleHeightfield
	 * @param  {Body}           bi
	 * @param  {Circle}         si
	 * @param  {Array}          xi
	 * @param  {Body}           bj
	 * @param  {Heightfield}    sj
	 * @param  {Array}          xj
	 * @param  {Number}         aj
	 */
	Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
	Narrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,
	                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){
	    var data = hfShape.heights,
	        radius = radius || circleShape.radius,
	        w = hfShape.elementWidth,
	        dist = circleHeightfield_dist,
	        candidate = circleHeightfield_candidate,
	        minCandidate = circleHeightfield_minCandidate,
	        minCandidateNormal = circleHeightfield_minCandidateNormal,
	        worldNormal = circleHeightfield_worldNormal,
	        v0 = circleHeightfield_v0,
	        v1 = circleHeightfield_v1;
	
	    // Get the index of the points to test against
	    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),
	        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );
	
	    /*if(idxB < 0 || idxA >= data.length)
	        return justTest ? false : 0;*/
	
	    if(idxA < 0){
	        idxA = 0;
	    }
	    if(idxB >= data.length){
	        idxB = data.length-1;
	    }
	
	    // Get max and min
	    var max = data[idxA],
	        min = data[idxB];
	    for(var i=idxA; i<idxB; i++){
	        if(data[i] < min){
	            min = data[i];
	        }
	        if(data[i] > max){
	            max = data[i];
	        }
	    }
	
	    if(circlePos[1]-radius > max){
	        return justTest ? false : 0;
	    }
	
	    /*
	    if(circlePos[1]+radius < min){
	        // Below the minimum point... We can just guess.
	        // TODO
	    }
	    */
	
	    // 1. Check so center of circle is not inside the field. If it is, this wont work...
	    // 2. For each edge
	    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
	    // 2. 2. Check if point is inside.
	
	    var found = false;
	
	    // Check all edges first
	    for(var i=idxA; i<idxB; i++){
	
	        // Get points
	        vec2.set(v0,     i*w, data[i]  );
	        vec2.set(v1, (i+1)*w, data[i+1]);
	        vec2.add(v0,v0,hfPos);
	        vec2.add(v1,v1,hfPos);
	
	        // Get normal
	        vec2.sub(worldNormal, v1, v0);
	        vec2.rotate(worldNormal, worldNormal, Math.PI/2);
	        vec2.normalize(worldNormal,worldNormal);
	
	        // Get point on circle, closest to the edge
	        vec2.scale(candidate,worldNormal,-radius);
	        vec2.add(candidate,candidate,circlePos);
	
	        // Distance from v0 to the candidate point
	        vec2.sub(dist,candidate,v0);
	
	        // Check if it is in the element "stick"
	        var d = vec2.dot(dist,worldNormal);
	        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){
	
	            if(justTest){
	                return true;
	            }
	
	            found = true;
	
	            // Store the candidate point, projected to the edge
	            vec2.scale(dist,worldNormal,-d);
	            vec2.add(minCandidate,candidate,dist);
	            vec2.copy(minCandidateNormal,worldNormal);
	
	            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);
	
	            // Normal is out of the heightfield
	            vec2.copy(c.normalA, minCandidateNormal);
	
	            // Vector from circle to heightfield
	            vec2.scale(c.contactPointB,  c.normalA, -radius);
	            add(c.contactPointB, c.contactPointB, circlePos);
	            sub(c.contactPointB, c.contactPointB, circleBody.position);
	
	            vec2.copy(c.contactPointA, minCandidate);
	            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);
	
	            this.contactEquations.push(c);
	
	            if(this.enableFriction){
	                this.frictionEquations.push( this.createFrictionFromContact(c) );
	            }
	        }
	    }
	
	    // Check all vertices
	    found = false;
	    if(radius > 0){
	        for(var i=idxA; i<=idxB; i++){
	
	            // Get point
	            vec2.set(v0, i*w, data[i]);
	            vec2.add(v0,v0,hfPos);
	
	            vec2.sub(dist, circlePos, v0);
	
	            if(vec2.squaredLength(dist) < Math.pow(radius, 2)){
	
	                if(justTest){
	                    return true;
	                }
	
	                found = true;
	
	                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);
	
	                // Construct normal - out of heightfield
	                vec2.copy(c.normalA, dist);
	                vec2.normalize(c.normalA,c.normalA);
	
	                vec2.scale(c.contactPointB, c.normalA, -radius);
	                add(c.contactPointB, c.contactPointB, circlePos);
	                sub(c.contactPointB, c.contactPointB, circleBody.position);
	
	                sub(c.contactPointA, v0, hfPos);
	                add(c.contactPointA, c.contactPointA, hfPos);
	                sub(c.contactPointA, c.contactPointA, hfBody.position);
	
	                this.contactEquations.push(c);
	
	                if(this.enableFriction){
	                    this.frictionEquations.push(this.createFrictionFromContact(c));
	                }
	            }
	        }
	    }
	
	    if(found){
	        return 1;
	    }
	
	    return 0;
	
	};
	
	var convexHeightfield_v0 = vec2.create(),
	    convexHeightfield_v1 = vec2.create(),
	    convexHeightfield_tilePos = vec2.create(),
	    convexHeightfield_tempConvexShape = new Convex({ vertices: [vec2.create(),vec2.create(),vec2.create(),vec2.create()] });
	/**
	 * @method circleHeightfield
	 * @param  {Body}           bi
	 * @param  {Circle}         si
	 * @param  {Array}          xi
	 * @param  {Body}           bj
	 * @param  {Heightfield}    sj
	 * @param  {Array}          xj
	 * @param  {Number}         aj
	 */
	Narrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] =
	Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
	Narrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,
	                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){
	    var data = hfShape.heights,
	        w = hfShape.elementWidth,
	        v0 = convexHeightfield_v0,
	        v1 = convexHeightfield_v1,
	        tilePos = convexHeightfield_tilePos,
	        tileConvex = convexHeightfield_tempConvexShape;
	
	    // Get the index of the points to test against
	    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),
	        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );
	
	    if(idxA < 0){
	        idxA = 0;
	    }
	    if(idxB >= data.length){
	        idxB = data.length-1;
	    }
	
	    // Get max and min
	    var max = data[idxA],
	        min = data[idxB];
	    for(var i=idxA; i<idxB; i++){
	        if(data[i] < min){
	            min = data[i];
	        }
	        if(data[i] > max){
	            max = data[i];
	        }
	    }
	
	    if(convexBody.aabb.lowerBound[1] > max){
	        return justTest ? false : 0;
	    }
	
	    var found = false;
	    var numContacts = 0;
	
	    // Loop over all edges
	    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)
	    for(var i=idxA; i<idxB; i++){
	
	        // Get points
	        vec2.set(v0,     i*w, data[i]  );
	        vec2.set(v1, (i+1)*w, data[i+1]);
	        vec2.add(v0,v0,hfPos);
	        vec2.add(v1,v1,hfPos);
	
	        // Construct a convex
	        var tileHeight = 100; // todo
	        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);
	
	        vec2.sub(tileConvex.vertices[0], v1, tilePos);
	        vec2.sub(tileConvex.vertices[1], v0, tilePos);
	        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
	        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
	        tileConvex.vertices[2][1] -= tileHeight;
	        tileConvex.vertices[3][1] -= tileHeight;
	
	        // Do convex collision
	        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,
	                                            hfBody, tileConvex, tilePos, 0, justTest);
	    }
	
	    return numContacts;
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:
	
	  * Redistributions of source code must retain the above copyright notice, this
	    list of conditions and the following disclaimer.
	  * Redistributions in binary form must reproduce the above copyright notice,
	    this list of conditions and the following disclaimer in the documentation
	    and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
	
	/**
	 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
	 * @class vec2
	 */
	
	var vec2 = module.exports = {};
	
	var Utils = __webpack_require__(5);
	
	/**
	 * Make a cross product and only return the z component
	 * @method crossLength
	 * @static
	 * @param  {Array} a
	 * @param  {Array} b
	 * @return {Number}
	 */
	vec2.crossLength = function(a,b){
	    return a[0] * b[1] - a[1] * b[0];
	};
	
	/**
	 * Cross product between a vector and the Z component of a vector
	 * @method crossVZ
	 * @static
	 * @param  {Array} out
	 * @param  {Array} vec
	 * @param  {Number} zcomp
	 * @return {Number}
	 */
	vec2.crossVZ = function(out, vec, zcomp){
	    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule
	    vec2.scale(out,out,zcomp);      // Scale with z
	    return out;
	};
	
	/**
	 * Cross product between a vector and the Z component of a vector
	 * @method crossZV
	 * @static
	 * @param  {Array} out
	 * @param  {Number} zcomp
	 * @param  {Array} vec
	 * @return {Number}
	 */
	vec2.crossZV = function(out, zcomp, vec){
	    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule
	    vec2.scale(out,out,zcomp);      // Scale with z
	    return out;
	};
	
	/**
	 * Rotate a vector by an angle
	 * @method rotate
	 * @static
	 * @param  {Array} out
	 * @param  {Array} a
	 * @param  {Number} angle
	 */
	vec2.rotate = function(out,a,angle){
	    if(angle !== 0){
	        var c = Math.cos(angle),
	            s = Math.sin(angle),
	            x = a[0],
	            y = a[1];
	        out[0] = c*x -s*y;
	        out[1] = s*x +c*y;
	    } else {
	        out[0] = a[0];
	        out[1] = a[1];
	    }
	};
	
	/**
	 * Rotate a vector 90 degrees clockwise
	 * @method rotate90cw
	 * @static
	 * @param  {Array} out
	 * @param  {Array} a
	 * @param  {Number} angle
	 */
	vec2.rotate90cw = function(out, a) {
	    var x = a[0];
	    var y = a[1];
	    out[0] = y;
	    out[1] = -x;
	};
	
	/**
	 * Transform a point position to local frame.
	 * @method toLocalFrame
	 * @param  {Array} out
	 * @param  {Array} worldPoint
	 * @param  {Array} framePosition
	 * @param  {Number} frameAngle
	 */
	vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){
	    vec2.copy(out, worldPoint);
	    vec2.sub(out, out, framePosition);
	    vec2.rotate(out, out, -frameAngle);
	};
	
	/**
	 * Transform a point position to global frame.
	 * @method toGlobalFrame
	 * @param  {Array} out
	 * @param  {Array} localPoint
	 * @param  {Array} framePosition
	 * @param  {Number} frameAngle
	 */
	vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){
	    vec2.copy(out, localPoint);
	    vec2.rotate(out, out, frameAngle);
	    vec2.add(out, out, framePosition);
	};
	
	/**
	 * Transform a vector to local frame.
	 * @method vectorToLocalFrame
	 * @param  {Array} out
	 * @param  {Array} worldVector
	 * @param  {Number} frameAngle
	 */
	vec2.vectorToLocalFrame = function(out, worldVector, frameAngle){
	    vec2.rotate(out, worldVector, -frameAngle);
	};
	
	/**
	 * Transform a point position to global frame.
	 * @method toGlobalFrame
	 * @param  {Array} out
	 * @param  {Array} localVector
	 * @param  {Number} frameAngle
	 */
	vec2.vectorToGlobalFrame = function(out, localVector, frameAngle){
	    vec2.rotate(out, localVector, frameAngle);
	};
	
	/**
	 * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
	 * @method centroid
	 * @static
	 * @param  {Array} out
	 * @param  {Array} a
	 * @param  {Array} b
	 * @param  {Array} c
	 * @return  {Array} The out object
	 */
	vec2.centroid = function(out, a, b, c){
	    vec2.add(out, a, b);
	    vec2.add(out, out, c);
	    vec2.scale(out, out, 1/3);
	    return out;
	};
	
	/**
	 * Creates a new, empty vec2
	 * @static
	 * @method create
	 * @return {Array} a new 2D vector
	 */
	vec2.create = function() {
	    var out = new Utils.ARRAY_TYPE(2);
	    out[0] = 0;
	    out[1] = 0;
	    return out;
	};
	
	/**
	 * Creates a new vec2 initialized with values from an existing vector
	 * @static
	 * @method clone
	 * @param {Array} a vector to clone
	 * @return {Array} a new 2D vector
	 */
	vec2.clone = function(a) {
	    var out = new Utils.ARRAY_TYPE(2);
	    out[0] = a[0];
	    out[1] = a[1];
	    return out;
	};
	
	/**
	 * Creates a new vec2 initialized with the given values
	 * @static
	 * @method fromValues
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @return {Array} a new 2D vector
	 */
	vec2.fromValues = function(x, y) {
	    var out = new Utils.ARRAY_TYPE(2);
	    out[0] = x;
	    out[1] = y;
	    return out;
	};
	
	/**
	 * Copy the values from one vec2 to another
	 * @static
	 * @method copy
	 * @param {Array} out the receiving vector
	 * @param {Array} a the source vector
	 * @return {Array} out
	 */
	vec2.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    return out;
	};
	
	/**
	 * Set the components of a vec2 to the given values
	 * @static
	 * @method set
	 * @param {Array} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @return {Array} out
	 */
	vec2.set = function(out, x, y) {
	    out[0] = x;
	    out[1] = y;
	    return out;
	};
	
	/**
	 * Adds two vec2's
	 * @static
	 * @method add
	 * @param {Array} out the receiving vector
	 * @param {Array} a the first operand
	 * @param {Array} b the second operand
	 * @return {Array} out
	 */
	vec2.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    return out;
	};
	
	/**
	 * Subtracts two vec2's
	 * @static
	 * @method subtract
	 * @param {Array} out the receiving vector
	 * @param {Array} a the first operand
	 * @param {Array} b the second operand
	 * @return {Array} out
	 */
	vec2.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    return out;
	};
	
	/**
	 * Alias for vec2.subtract
	 * @static
	 * @method sub
	 */
	vec2.sub = vec2.subtract;
	
	/**
	 * Multiplies two vec2's
	 * @static
	 * @method multiply
	 * @param {Array} out the receiving vector
	 * @param {Array} a the first operand
	 * @param {Array} b the second operand
	 * @return {Array} out
	 */
	vec2.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    return out;
	};
	
	/**
	 * Alias for vec2.multiply
	 * @static
	 * @method mul
	 */
	vec2.mul = vec2.multiply;
	
	/**
	 * Divides two vec2's
	 * @static
	 * @method divide
	 * @param {Array} out the receiving vector
	 * @param {Array} a the first operand
	 * @param {Array} b the second operand
	 * @return {Array} out
	 */
	vec2.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    return out;
	};
	
	/**
	 * Alias for vec2.divide
	 * @static
	 * @method div
	 */
	vec2.div = vec2.divide;
	
	/**
	 * Scales a vec2 by a scalar number
	 * @static
	 * @method scale
	 * @param {Array} out the receiving vector
	 * @param {Array} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @return {Array} out
	 */
	vec2.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    return out;
	};
	
	/**
	 * Calculates the euclidian distance between two vec2's
	 * @static
	 * @method distance
	 * @param {Array} a the first operand
	 * @param {Array} b the second operand
	 * @return {Number} distance between a and b
	 */
	vec2.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1];
	    return Math.sqrt(x*x + y*y);
	};
	
	/**
	 * Alias for vec2.distance
	 * @static
	 * @method dist
	 */
	vec2.dist = vec2.distance;
	
	/**
	 * Calculates the squared euclidian distance between two vec2's
	 * @static
	 * @method squaredDistance
	 * @param {Array} a the first operand
	 * @param {Array} b the second operand
	 * @return {Number} squared distance between a and b
	 */
	vec2.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1];
	    return x*x + y*y;
	};
	
	/**
	 * Alias for vec2.squaredDistance
	 * @static
	 * @method sqrDist
	 */
	vec2.sqrDist = vec2.squaredDistance;
	
	/**
	 * Calculates the length of a vec2
	 * @static
	 * @method length
	 * @param {Array} a vector to calculate length of
	 * @return {Number} length of a
	 */
	vec2.length = function (a) {
	    var x = a[0],
	        y = a[1];
	    return Math.sqrt(x*x + y*y);
	};
	
	/**
	 * Alias for vec2.length
	 * @method len
	 * @static
	 */
	vec2.len = vec2.length;
	
	/**
	 * Calculates the squared length of a vec2
	 * @static
	 * @method squaredLength
	 * @param {Array} a vector to calculate squared length of
	 * @return {Number} squared length of a
	 */
	vec2.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1];
	    return x*x + y*y;
	};
	
	/**
	 * Alias for vec2.squaredLength
	 * @static
	 * @method sqrLen
	 */
	vec2.sqrLen = vec2.squaredLength;
	
	/**
	 * Negates the components of a vec2
	 * @static
	 * @method negate
	 * @param {Array} out the receiving vector
	 * @param {Array} a vector to negate
	 * @return {Array} out
	 */
	vec2.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    return out;
	};
	
	/**
	 * Normalize a vec2
	 * @static
	 * @method normalize
	 * @param {Array} out the receiving vector
	 * @param {Array} a vector to normalize
	 * @return {Array} out
	 */
	vec2.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1];
	    var len = x*x + y*y;
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	    }
	    return out;
	};
	
	/**
	 * Calculates the dot product of two vec2's
	 * @static
	 * @method dot
	 * @param {Array} a the first operand
	 * @param {Array} b the second operand
	 * @return {Number} dot product of a and b
	 */
	vec2.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	};
	
	/**
	 * Returns a string representation of a vector
	 * @static
	 * @method str
	 * @param {Array} vec vector to represent as a string
	 * @return {String} string representation of the vector
	 */
	vec2.str = function (a) {
	    return 'vec2(' + a[0] + ', ' + a[1] + ')';
	};
	
	/**
	 * Linearly interpolate/mix two vectors.
	 * @static
	 * @method lerp
	 * @param {Array} out
	 * @param {Array} a First vector
	 * @param {Array} b Second vector
	 * @param {number} t Lerp factor
	 */
	vec2.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    return out;
	};
	
	/**
	 * Reflect a vector along a normal.
	 * @static
	 * @method reflect
	 * @param {Array} out
	 * @param {Array} vector
	 * @param {Array} normal
	 */
	vec2.reflect = function(out, vector, normal){
	    var dot = vector[0] * normal[0] + vector[1] * normal[1];
	    out[0] = vector[0] - 2 * normal[0] * dot;
	    out[1] = vector[1] - 2 * normal[1] * dot;
	};
	
	/**
	 * Get the intersection point between two line segments.
	 * @static
	 * @method getLineSegmentsIntersection
	 * @param  {Array} out
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {Array} p2
	 * @param  {Array} p3
	 * @return {boolean} True if there was an intersection, otherwise false.
	 */
	vec2.getLineSegmentsIntersection = function(out, p0, p1, p2, p3) {
	    var t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);
	    if(t < 0){
	        return false;
	    } else {
	        out[0] = p0[0] + (t * (p1[0] - p0[0]));
	        out[1] = p0[1] + (t * (p1[1] - p0[1]));
	        return true;
	    }
	};
	
	/**
	 * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)
	 * @static
	 * @method getLineSegmentsIntersectionFraction
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {Array} p2
	 * @param  {Array} p3
	 * @return {number} A number between 0 and 1 if there was an intersection, otherwise -1.
	 */
	vec2.getLineSegmentsIntersectionFraction = function(p0, p1, p2, p3) {
	    var s1_x = p1[0] - p0[0];
	    var s1_y = p1[1] - p0[1];
	    var s2_x = p3[0] - p2[0];
	    var s2_y = p3[1] - p2[1];
	
	    var s, t;
	    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
	    t = ( s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
	    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected
	        return t;
	    }
	    return -1; // No collision
	};


/***/ },
/* 5 */
/***/ function(module, exports) {

	/* global P2_ARRAY_TYPE */
	
	module.exports = Utils;
	
	/**
	 * Misc utility functions
	 * @class Utils
	 * @constructor
	 */
	function Utils(){}
	
	/**
	 * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
	 * @method appendArray
	 * @static
	 * @param  {Array} a
	 * @param  {Array} b
	 */
	Utils.appendArray = function(a,b){
	    if (b.length < 150000) {
	        a.push.apply(a, b);
	    } else {
	        for (var i = 0, len = b.length; i !== len; ++i) {
	            a.push(b[i]);
	        }
	    }
	};
	
	/**
	 * Garbage free Array.splice(). Does not allocate a new array.
	 * @method splice
	 * @static
	 * @param  {Array} array
	 * @param  {Number} index
	 * @param  {Number} howmany
	 */
	Utils.splice = function(array,index,howmany){
	    howmany = howmany || 1;
	    for (var i=index, len=array.length-howmany; i < len; i++){
	        array[i] = array[i + howmany];
	    }
	    array.length = len;
	};
	
	/**
	 * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.
	 * @static
	 * @property {function} ARRAY_TYPE
	 * @example
	 *     <script>
	 *         <!-- Inject your preferred array type before loading p2.js -->
	 *         P2_ARRAY_TYPE = Array;
	 *     </script>
	 *     <script src="p2.js"></script>
	 */
	if(typeof P2_ARRAY_TYPE !== 'undefined') {
	    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;
	} else if (typeof Float32Array !== 'undefined'){
	    Utils.ARRAY_TYPE = Float32Array;
	} else {
	    Utils.ARRAY_TYPE = Array;
	}
	
	/**
	 * Extend an object with the properties of another
	 * @static
	 * @method extend
	 * @param  {object} a
	 * @param  {object} b
	 */
	Utils.extend = function(a,b){
	    for(var key in b){
	        a[key] = b[key];
	    }
	};
	
	/**
	 * Extend an options object with default values.
	 * @static
	 * @method defaults
	 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
	 * @param  {object} defaults An object containing default values.
	 * @return {object} The modified options object.
	 */
	Utils.defaults = function(options, defaults){
	    options = options || {};
	    for(var key in defaults){
	        if(!(key in options)){
	            options[key] = defaults[key];
	        }
	    }
	    return options;
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var ContactEquation = __webpack_require__(7);
	var Pool = __webpack_require__(22);
	
	module.exports = ContactEquationPool;
	
	/**
	 * @class
	 */
	function ContactEquationPool() {
		Pool.apply(this, arguments);
	}
	ContactEquationPool.prototype = new Pool();
	ContactEquationPool.prototype.constructor = ContactEquationPool;
	
	/**
	 * @method create
	 * @return {ContactEquation}
	 */
	ContactEquationPool.prototype.create = function () {
		return new ContactEquation();
	};
	
	/**
	 * @method destroy
	 * @param {ContactEquation} equation
	 * @return {ContactEquationPool}
	 */
	ContactEquationPool.prototype.destroy = function (equation) {
		equation.bodyA = equation.bodyB = null;
		return this;
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var Equation = __webpack_require__(8),
	    vec2 = __webpack_require__(4);
	
	module.exports = ContactEquation;
	
	/**
	 * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
	 *
	 * @class ContactEquation
	 * @constructor
	 * @extends Equation
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function ContactEquation(bodyA, bodyB){
	    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);
	
	    /**
	     * Vector from body i center of mass to the contact point.
	     * @property contactPointA
	     * @type {Array}
	     */
	    this.contactPointA = vec2.create();
	    this.penetrationVec = vec2.create();
	
	    /**
	     * World-oriented vector from body A center of mass to the contact point.
	     * @property contactPointB
	     * @type {Array}
	     */
	    this.contactPointB = vec2.create();
	
	    /**
	     * The normal vector, pointing out of body i
	     * @property normalA
	     * @type {Array}
	     */
	    this.normalA = vec2.create();
	
	    /**
	     * The restitution to use (0=no bounciness, 1=max bounciness).
	     * @property restitution
	     * @type {Number}
	     */
	    this.restitution = 0;
	
	    /**
	     * This property is set to true if this is the first impact between the bodies (not persistant contact).
	     * @property firstImpact
	     * @type {Boolean}
	     * @readOnly
	     */
	    this.firstImpact = false;
	
	    /**
	     * The shape in body i that triggered this contact.
	     * @property shapeA
	     * @type {Shape}
	     */
	    this.shapeA = null;
	
	    /**
	     * The shape in body j that triggered this contact.
	     * @property shapeB
	     * @type {Shape}
	     */
	    this.shapeB = null;
	}
	ContactEquation.prototype = new Equation();
	ContactEquation.prototype.constructor = ContactEquation;
	ContactEquation.prototype.computeB = function(a,b,h){
	    var bi = this.bodyA,
	        bj = this.bodyB,
	        ri = this.contactPointA,
	        rj = this.contactPointB,
	        xi = bi.position,
	        xj = bj.position;
	
	    var penetrationVec = this.penetrationVec,
	        n = this.normalA,
	        G = this.G;
	
	    // Caluclate cross products
	    var rixn = vec2.crossLength(ri,n),
	        rjxn = vec2.crossLength(rj,n);
	
	    // G = [-n -rixn n rjxn]
	    G[0] = -n[0];
	    G[1] = -n[1];
	    G[2] = -rixn;
	    G[3] = n[0];
	    G[4] = n[1];
	    G[5] = rjxn;
	
	    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
	    vec2.add(penetrationVec,xj,rj);
	    vec2.sub(penetrationVec,penetrationVec,xi);
	    vec2.sub(penetrationVec,penetrationVec,ri);
	
	    // Compute iteration
	    var GW, Gq;
	    if(this.firstImpact && this.restitution !== 0){
	        Gq = 0;
	        GW = (1/b)*(1+this.restitution) * this.computeGW();
	    } else {
	        Gq = vec2.dot(n,penetrationVec) + this.offset;
	        GW = this.computeGW();
	    }
	
	    var GiMf = this.computeGiMf();
	    var B = - Gq * a - GW * b - h*GiMf;
	
	    return B;
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Equation;
	
	var vec2 = __webpack_require__(4),
	    Utils = __webpack_require__(5),
	    Body = __webpack_require__(9);
	
	/**
	 * Base class for constraint equations.
	 * @class Equation
	 * @constructor
	 * @param {Body} bodyA First body participating in the equation
	 * @param {Body} bodyB Second body participating in the equation
	 * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE
	 * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE
	 */
	function Equation(bodyA, bodyB, minForce, maxForce){
	
	    /**
	     * Minimum force to apply when solving.
	     * @property minForce
	     * @type {Number}
	     */
	    this.minForce = typeof(minForce)==="undefined" ? -Number.MAX_VALUE : minForce;
	
	    /**
	     * Max force to apply when solving.
	     * @property maxForce
	     * @type {Number}
	     */
	    this.maxForce = typeof(maxForce)==="undefined" ? Number.MAX_VALUE : maxForce;
	
	    /**
	     * First body participating in the constraint
	     * @property bodyA
	     * @type {Body}
	     */
	    this.bodyA = bodyA;
	
	    /**
	     * Second body participating in the constraint
	     * @property bodyB
	     * @type {Body}
	     */
	    this.bodyB = bodyB;
	
	    /**
	     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
	     * @property stiffness
	     * @type {Number}
	     */
	    this.stiffness = Equation.DEFAULT_STIFFNESS;
	
	    /**
	     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
	     * @property relaxation
	     * @type {Number}
	     */
	    this.relaxation = Equation.DEFAULT_RELAXATION;
	
	    /**
	     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).
	     * @property G
	     * @type {Array}
	     */
	    this.G = new Utils.ARRAY_TYPE(6);
	    for(var i=0; i<6; i++){
	        this.G[i]=0;
	    }
	
	    this.offset = 0;
	
	    this.a = 0;
	    this.b = 0;
	    this.epsilon = 0;
	    this.timeStep = 1/60;
	
	    /**
	     * Indicates if stiffness or relaxation was changed.
	     * @property {Boolean} needsUpdate
	     */
	    this.needsUpdate = true;
	
	    /**
	     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
	     * @property multiplier
	     * @type {Number}
	     */
	    this.multiplier = 0;
	
	    /**
	     * Relative velocity.
	     * @property {Number} relativeVelocity
	     */
	    this.relativeVelocity = 0;
	
	    /**
	     * Whether this equation is enabled or not. If true, it will be added to the solver.
	     * @property {Boolean} enabled
	     */
	    this.enabled = true;
	}
	Equation.prototype.constructor = Equation;
	
	/**
	 * The default stiffness when creating a new Equation.
	 * @static
	 * @property {Number} DEFAULT_STIFFNESS
	 * @default 1e6
	 */
	Equation.DEFAULT_STIFFNESS = 1e6;
	
	/**
	 * The default relaxation when creating a new Equation.
	 * @static
	 * @property {Number} DEFAULT_RELAXATION
	 * @default 4
	 */
	Equation.DEFAULT_RELAXATION = 4;
	
	/**
	 * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
	 * @method update
	 */
	Equation.prototype.update = function(){
	    var k = this.stiffness,
	        d = this.relaxation,
	        h = this.timeStep;
	
	    this.a = 4.0 / (h * (1 + 4 * d));
	    this.b = (4.0 * d) / (1 + 4 * d);
	    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));
	
	    this.needsUpdate = false;
	};
	
	/**
	 * Multiply a jacobian entry with corresponding positions or velocities
	 * @method gmult
	 * @return {Number}
	 */
	Equation.prototype.gmult = function(G,vi,wi,vj,wj){
	    return  G[0] * vi[0] +
	            G[1] * vi[1] +
	            G[2] * wi +
	            G[3] * vj[0] +
	            G[4] * vj[1] +
	            G[5] * wj;
	};
	
	/**
	 * Computes the RHS of the SPOOK equation
	 * @method computeB
	 * @return {Number}
	 */
	Equation.prototype.computeB = function(a,b,h){
	    var GW = this.computeGW();
	    var Gq = this.computeGq();
	    var GiMf = this.computeGiMf();
	    return - Gq * a - GW * b - GiMf*h;
	};
	
	/**
	 * Computes G\*q, where q are the generalized body coordinates
	 * @method computeGq
	 * @return {Number}
	 */
	var qi = vec2.create(),
	    qj = vec2.create();
	Equation.prototype.computeGq = function(){
	    var G = this.G,
	        bi = this.bodyA,
	        bj = this.bodyB,
	        xi = bi.position,
	        xj = bj.position,
	        ai = bi.angle,
	        aj = bj.angle;
	
	    return this.gmult(G, qi, ai, qj, aj) + this.offset;
	};
	
	/**
	 * Computes G\*W, where W are the body velocities
	 * @method computeGW
	 * @return {Number}
	 */
	Equation.prototype.computeGW = function(){
	    var G = this.G,
	        bi = this.bodyA,
	        bj = this.bodyB,
	        vi = bi.velocity,
	        vj = bj.velocity,
	        wi = bi.angularVelocity,
	        wj = bj.angularVelocity;
	    return this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;
	};
	
	/**
	 * Computes G\*Wlambda, where W are the body velocities
	 * @method computeGWlambda
	 * @return {Number}
	 */
	Equation.prototype.computeGWlambda = function(){
	    var G = this.G,
	        bi = this.bodyA,
	        bj = this.bodyB,
	        vi = bi.vlambda,
	        vj = bj.vlambda,
	        wi = bi.wlambda,
	        wj = bj.wlambda;
	    return this.gmult(G,vi,wi,vj,wj);
	};
	
	/**
	 * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
	 * @method computeGiMf
	 * @return {Number}
	 */
	var iMfi = vec2.create(),
	    iMfj = vec2.create();
	Equation.prototype.computeGiMf = function(){
	    var bi = this.bodyA,
	        bj = this.bodyB,
	        fi = bi.force,
	        ti = bi.angularForce,
	        fj = bj.force,
	        tj = bj.angularForce,
	        invMassi = bi.invMassSolve,
	        invMassj = bj.invMassSolve,
	        invIi = bi.invInertiaSolve,
	        invIj = bj.invInertiaSolve,
	        G = this.G;
	
	    vec2.scale(iMfi, fi, invMassi);
	    vec2.multiply(iMfi, bi.massMultiplier, iMfi);
	    vec2.scale(iMfj, fj,invMassj);
	    vec2.multiply(iMfj, bj.massMultiplier, iMfj);
	
	    return this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);
	};
	
	/**
	 * Computes G\*inv(M)\*G'
	 * @method computeGiMGt
	 * @return {Number}
	 */
	Equation.prototype.computeGiMGt = function(){
	    var bi = this.bodyA,
	        bj = this.bodyB,
	        invMassi = bi.invMassSolve,
	        invMassj = bj.invMassSolve,
	        invIi = bi.invInertiaSolve,
	        invIj = bj.invInertiaSolve,
	        G = this.G;
	
	    return  G[0] * G[0] * invMassi * bi.massMultiplier[0] +
	            G[1] * G[1] * invMassi * bi.massMultiplier[1] +
	            G[2] * G[2] *    invIi +
	            G[3] * G[3] * invMassj * bj.massMultiplier[0] +
	            G[4] * G[4] * invMassj * bj.massMultiplier[1] +
	            G[5] * G[5] *    invIj;
	};
	
	var addToWlambda_temp = vec2.create(),
	    addToWlambda_Gi = vec2.create(),
	    addToWlambda_Gj = vec2.create(),
	    addToWlambda_ri = vec2.create(),
	    addToWlambda_rj = vec2.create(),
	    addToWlambda_Mdiag = vec2.create();
	
	/**
	 * Add constraint velocity to the bodies.
	 * @method addToWlambda
	 * @param {Number} deltalambda
	 */
	Equation.prototype.addToWlambda = function(deltalambda){
	    var bi = this.bodyA,
	        bj = this.bodyB,
	        temp = addToWlambda_temp,
	        Gi = addToWlambda_Gi,
	        Gj = addToWlambda_Gj,
	        ri = addToWlambda_ri,
	        rj = addToWlambda_rj,
	        invMassi = bi.invMassSolve,
	        invMassj = bj.invMassSolve,
	        invIi = bi.invInertiaSolve,
	        invIj = bj.invInertiaSolve,
	        Mdiag = addToWlambda_Mdiag,
	        G = this.G;
	
	    Gi[0] = G[0];
	    Gi[1] = G[1];
	    Gj[0] = G[3];
	    Gj[1] = G[4];
	
	    // Add to linear velocity
	    // v_lambda += inv(M) * delta_lamba * G
	    vec2.scale(temp, Gi, invMassi*deltalambda);
	    vec2.multiply(temp, temp, bi.massMultiplier);
	    vec2.add( bi.vlambda, bi.vlambda, temp);
	    // This impulse is in the offset frame
	    // Also add contribution to angular
	    //bi.wlambda -= vec2.crossLength(temp,ri);
	    bi.wlambda += invIi * G[2] * deltalambda;
	
	
	    vec2.scale(temp, Gj, invMassj*deltalambda);
	    vec2.multiply(temp, temp, bj.massMultiplier);
	    vec2.add( bj.vlambda, bj.vlambda, temp);
	    //bj.wlambda -= vec2.crossLength(temp,rj);
	    bj.wlambda += invIj * G[5] * deltalambda;
	};
	
	/**
	 * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
	 * @method computeInvC
	 * @param  {Number} eps
	 * @return {Number}
	 */
	Equation.prototype.computeInvC = function(eps){
	    return 1.0 / (this.computeGiMGt() + eps);
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4)
	,   decomp = __webpack_require__(10)
	,   Convex = __webpack_require__(15)
	,   RaycastResult = __webpack_require__(18)
	,   Ray = __webpack_require__(19)
	,   AABB = __webpack_require__(20)
	,   EventEmitter = __webpack_require__(21);
	
	module.exports = Body;
	
	/**
	 * A rigid body. Has got a center of mass, position, velocity and a number of
	 * shapes that are used for collisions.
	 *
	 * @class Body
	 * @constructor
	 * @extends EventEmitter
	 * @param {Array} [options.force]
	 * @param {Array} [options.position]
	 * @param {Array} [options.velocity]
	 * @param {Boolean} [options.allowSleep]
	 * @param {Boolean} [options.collisionResponse]
	 * @param {Number} [options.angle=0]
	 * @param {Number} [options.angularForce=0]
	 * @param {Number} [options.angularVelocity=0]
	 * @param {Number} [options.ccdIterations=10]
	 * @param {Number} [options.ccdSpeedThreshold=-1]
	 * @param {Number} [options.fixedRotation=false]
	 * @param {Number} [options.gravityScale]
	 * @param {Number} [options.id]
	 * @param {Number} [options.mass=0] A number >= 0. If zero, the .type will be set to Body.STATIC.
	 * @param {Number} [options.sleepSpeedLimit]
	 * @param {Number} [options.sleepTimeLimit]
	 * @param {Object} [options]
	 *
	 * @example
	 *
	 *     // Create a typical dynamic body
	 *     var body = new Body({
	 *         mass: 1,
	 *         position: [0, 0],
	 *         angle: 0,
	 *         velocity: [0, 0],
	 *         angularVelocity: 0
	 *     });
	 *
	 *     // Add a circular shape to the body
	 *     body.addShape(new Circle({ radius: 1 }));
	 *
	 *     // Add the body to the world
	 *     world.addBody(body);
	 */
	function Body(options){
	    options = options || {};
	
	    EventEmitter.call(this);
	
	    /**
	     * The body identifyer
	     * @property id
	     * @type {Number}
	     */
	    this.id = options.id || ++Body._idCounter;
	
	    /**
	     * The world that this body is added to. This property is set to NULL if the body is not added to any world.
	     * @property world
	     * @type {World}
	     */
	    this.world = null;
	
	    /**
	     * The shapes of the body.
	     *
	     * @property shapes
	     * @type {Array}
	     */
	    this.shapes = [];
	
	    /**
	     * The mass of the body.
	     * @property mass
	     * @type {number}
	     */
	    this.mass = options.mass || 0;
	
	    /**
	     * The inverse mass of the body.
	     * @property invMass
	     * @type {number}
	     */
	    this.invMass = 0;
	
	    /**
	     * The inertia of the body around the Z axis.
	     * @property inertia
	     * @type {number}
	     */
	    this.inertia = 0;
	
	    /**
	     * The inverse inertia of the body.
	     * @property invInertia
	     * @type {number}
	     */
	    this.invInertia = 0;
	
	    this.invMassSolve = 0;
	    this.invInertiaSolve = 0;
	
	    /**
	     * Set to true if you want to fix the rotation of the body.
	     * @property fixedRotation
	     * @type {Boolean}
	     */
	    this.fixedRotation = !!options.fixedRotation;
	
	    /**
	     * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.
	     * @property {Boolean} fixedX
	     */
	    this.fixedX = !!options.fixedX;
	
	    /**
	     * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X.
	     * @property {Boolean} fixedY
	     */
	    this.fixedY = !!options.fixedY;
	
	    /**
	     * @private
	     * @property {array} massMultiplier
	     */
	    this.massMultiplier = vec2.create();
	
	    /**
	     * The position of the body
	     * @property position
	     * @type {Array}
	     */
	    this.position = vec2.fromValues(0,0);
	    if(options.position){
	        vec2.copy(this.position, options.position);
	    }
	
	    /**
	     * The interpolated position of the body. Use this for rendering.
	     * @property interpolatedPosition
	     * @type {Array}
	     */
	    this.interpolatedPosition = vec2.fromValues(0,0);
	
	    /**
	     * The interpolated angle of the body. Use this for rendering.
	     * @property interpolatedAngle
	     * @type {Number}
	     */
	    this.interpolatedAngle = 0;
	
	    /**
	     * The previous position of the body.
	     * @property previousPosition
	     * @type {Array}
	     */
	    this.previousPosition = vec2.fromValues(0,0);
	
	    /**
	     * The previous angle of the body.
	     * @property previousAngle
	     * @type {Number}
	     */
	    this.previousAngle = 0;
	
	    /**
	     * The current velocity of the body.
	     * @property velocity
	     * @type {Array}
	     */
	    this.velocity = vec2.fromValues(0,0);
	    if(options.velocity){
	        vec2.copy(this.velocity, options.velocity);
	    }
	
	    /**
	     * Constraint velocity that was added to the body during the last step.
	     * @property vlambda
	     * @type {Array}
	     */
	    this.vlambda = vec2.fromValues(0,0);
	
	    /**
	     * Angular constraint velocity that was added to the body during last step.
	     * @property wlambda
	     * @type {Array}
	     */
	    this.wlambda = 0;
	
	    /**
	     * The angle of the body, in radians.
	     * @property angle
	     * @type {number}
	     * @example
	     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
	     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
	     *     function normalizeAngle(angle){
	     *         angle = angle % (2*Math.PI);
	     *         if(angle < 0){
	     *             angle += (2*Math.PI);
	     *         }
	     *         return angle;
	     *     }
	     */
	    this.angle = options.angle || 0;
	
	    /**
	     * The angular velocity of the body, in radians per second.
	     * @property angularVelocity
	     * @type {number}
	     */
	    this.angularVelocity = options.angularVelocity || 0;
	
	    /**
	     * The force acting on the body. Since the body force (and {{#crossLink "Body/angularForce:property"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.
	     * @property force
	     * @type {Array}
	     *
	     * @example
	     *     // This produces a forcefield of 1 Newton in the positive x direction.
	     *     for(var i=0; i<numSteps; i++){
	     *         body.force[0] = 1;
	     *         world.step(1/60);
	     *     }
	     *
	     * @example
	     *     // This will apply a rotational force on the body
	     *     for(var i=0; i<numSteps; i++){
	     *         body.angularForce = -3;
	     *         world.step(1/60);
	     *     }
	     */
	    this.force = vec2.create();
	    if(options.force){
	        vec2.copy(this.force, options.force);
	    }
	
	    /**
	     * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
	     * @property angularForce
	     * @type {number}
	     */
	    this.angularForce = options.angularForce || 0;
	
	    /**
	     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.
	     * @property damping
	     * @type {Number}
	     * @default 0.1
	     */
	    this.damping = typeof(options.damping) === "number" ? options.damping : 0.1;
	
	    /**
	     * The angular force acting on the body. Should be a value between 0 and 1.
	     * @property angularDamping
	     * @type {Number}
	     * @default 0.1
	     */
	    this.angularDamping = typeof(options.angularDamping) === "number" ? options.angularDamping : 0.1;
	
	    /**
	     * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
	     *
	     * * Static bodies do not move, and they do not respond to forces or collision.
	     * * Dynamic bodies body can move and respond to collisions and forces.
	     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
	     *
	     * @property type
	     * @type {number}
	     *
	     * @example
	     *     // Bodies are static by default. Static bodies will never move.
	     *     var body = new Body();
	     *     console.log(body.type == Body.STATIC); // true
	     *
	     * @example
	     *     // By setting the mass of a body to a nonzero number, the body
	     *     // will become dynamic and will move and interact with other bodies.
	     *     var dynamicBody = new Body({
	     *         mass : 1
	     *     });
	     *     console.log(dynamicBody.type == Body.DYNAMIC); // true
	     *
	     * @example
	     *     // Kinematic bodies will only move if you change their velocity.
	     *     var kinematicBody = new Body({
	     *         type: Body.KINEMATIC // Type can be set via the options object.
	     *     });
	     */
	    this.type = Body.STATIC;
	
	    if(typeof(options.type) !== 'undefined'){
	        this.type = options.type;
	    } else if(!options.mass){
	        this.type = Body.STATIC;
	    } else {
	        this.type = Body.DYNAMIC;
	    }
	
	    /**
	     * Bounding circle radius.
	     * @property boundingRadius
	     * @type {Number}
	     */
	    this.boundingRadius = 0;
	
	    /**
	     * Bounding box of this body.
	     * @property aabb
	     * @type {AABB}
	     */
	    this.aabb = new AABB();
	
	    /**
	     * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}.updateAABB(){{/crossLink}}.
	     * @property aabbNeedsUpdate
	     * @type {Boolean}
	     * @see updateAABB
	     *
	     * @example
	     *     // Force update the AABB
	     *     body.aabbNeedsUpdate = true;
	     *     body.updateAABB();
	     *     console.log(body.aabbNeedsUpdate); // false
	     */
	    this.aabbNeedsUpdate = true;
	
	    /**
	     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
	     * @property allowSleep
	     * @type {Boolean}
	     * @default true
	     */
	    this.allowSleep = options.allowSleep !== undefined ? options.allowSleep : true;
	
	    this.wantsToSleep = false;
	
	    /**
	     * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
	     *
	     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
	     *
	     * @property sleepState
	     * @type {Number}
	     * @default Body.AWAKE
	     */
	    this.sleepState = Body.AWAKE;
	
	    /**
	     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
	     * @property sleepSpeedLimit
	     * @type {Number}
	     * @default 0.2
	     */
	    this.sleepSpeedLimit = options.sleepSpeedLimit !== undefined ? options.sleepSpeedLimit : 0.2;
	
	    /**
	     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
	     * @property sleepTimeLimit
	     * @type {Number}
	     * @default 1
	     */
	    this.sleepTimeLimit = options.sleepTimeLimit !== undefined ? options.sleepTimeLimit : 1;
	
	    /**
	     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
	     * @property {Number} gravityScale
	     * @default 1
	     */
	    this.gravityScale = options.gravityScale !== undefined ? options.gravityScale : 1;
	
	    /**
	     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
	     * @property {Boolean} collisionResponse
	     */
	    this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;
	
	    /**
	     * How long the body has been sleeping.
	     * @property {Number} idleTime
	     */
	    this.idleTime = 0;
	
	    /**
	     * The last time when the body went to SLEEPY state.
	     * @property {Number} timeLastSleepy
	     * @private
	     */
	    this.timeLastSleepy = 0;
	
	    /**
	     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
	     * @property {number} ccdSpeedThreshold
	     * @default -1
	     */
	    this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;
	
	    /**
	     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
	     * @property {number} ccdIterations
	     * @default 10
	     */
	    this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;
	
	    this.concavePath = null;
	
	    this._wakeUpAfterNarrowphase = false;
	
	    this.updateMassProperties();
	}
	Body.prototype = new EventEmitter();
	Body.prototype.constructor = Body;
	
	Body._idCounter = 0;
	
	/**
	 * @private
	 * @method updateSolveMassProperties
	 */
	Body.prototype.updateSolveMassProperties = function(){
	    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
	        this.invMassSolve = 0;
	        this.invInertiaSolve = 0;
	    } else {
	        this.invMassSolve = this.invMass;
	        this.invInertiaSolve = this.invInertia;
	    }
	};
	
	/**
	 * Set the total density of the body
	 * @method setDensity
	 * @param {number} density
	 */
	Body.prototype.setDensity = function(density) {
	    var totalArea = this.getArea();
	    this.mass = totalArea * density;
	    this.updateMassProperties();
	};
	
	/**
	 * Get the total area of all shapes in the body
	 * @method getArea
	 * @return {Number}
	 */
	Body.prototype.getArea = function() {
	    var totalArea = 0;
	    for(var i=0; i<this.shapes.length; i++){
	        totalArea += this.shapes[i].area;
	    }
	    return totalArea;
	};
	
	/**
	 * Get the AABB from the body. The AABB is updated if necessary.
	 * @method getAABB
	 * @return {AABB} The AABB instance (this.aabb)
	 */
	Body.prototype.getAABB = function(){
	    if(this.aabbNeedsUpdate){
	        this.updateAABB();
	    }
	    return this.aabb;
	};
	
	var shapeAABB = new AABB(),
	    tmp = vec2.create();
	
	/**
	 * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.
	 * @method updateAABB
	 */
	Body.prototype.updateAABB = function() {
	    var shapes = this.shapes,
	        N = shapes.length,
	        offset = tmp,
	        bodyAngle = this.angle;
	
	    for(var i=0; i!==N; i++){
	        var shape = shapes[i],
	            angle = shape.angle + bodyAngle;
	
	        // Get shape world offset
	        vec2.rotate(offset, shape.position, bodyAngle);
	        vec2.add(offset, offset, this.position);
	
	        // Get shape AABB
	        shape.computeAABB(shapeAABB, offset, angle);
	
	        if(i===0){
	            this.aabb.copy(shapeAABB);
	        } else {
	            this.aabb.extend(shapeAABB);
	        }
	    }
	
	    this.aabbNeedsUpdate = false;
	};
	
	/**
	 * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.
	 * @method updateBoundingRadius
	 */
	Body.prototype.updateBoundingRadius = function(){
	    var shapes = this.shapes,
	        N = shapes.length,
	        radius = 0;
	
	    for(var i=0; i!==N; i++){
	        var shape = shapes[i],
	            offset = vec2.length(shape.position),
	            r = shape.boundingRadius;
	        if(offset + r > radius){
	            radius = offset + r;
	        }
	    }
	
	    this.boundingRadius = radius;
	};
	
	/**
	 * Add a shape to the body. You can pass a local transform when adding a shape,
	 * so that the shape gets an offset and angle relative to the body center of mass.
	 * Will automatically update the mass properties and bounding radius.
	 *
	 * @method addShape
	 * @param  {Shape}              shape
	 * @param  {Array} [offset] Local body offset of the shape.
	 * @param  {Number}             [angle]  Local body angle.
	 *
	 * @example
	 *     var body = new Body(),
	 *         shape = new Circle({ radius: 1 });
	 *
	 *     // Add the shape to the body, positioned in the center
	 *     body.addShape(shape);
	 *
	 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
	 *     body.addShape(shape,[1,0]);
	 *
	 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
	 *     body.addShape(shape,[0,1],Math.PI/2);
	 */
	Body.prototype.addShape = function(shape, offset, angle){
	    if(shape.body){
	        throw new Error('A shape can only be added to one body.');
	    }
	    shape.body = this;
	
	    // Copy the offset vector
	    if(offset){
	        vec2.copy(shape.position, offset);
	    } else {
	        vec2.set(shape.position, 0, 0);
	    }
	
	    shape.angle = angle || 0;
	
	    this.shapes.push(shape);
	    this.updateMassProperties();
	    this.updateBoundingRadius();
	
	    this.aabbNeedsUpdate = true;
	};
	
	/**
	 * Remove a shape
	 * @method removeShape
	 * @param  {Shape} shape
	 * @return {Boolean} True if the shape was found and removed, else false.
	 */
	Body.prototype.removeShape = function(shape){
	    var idx = this.shapes.indexOf(shape);
	
	    if(idx !== -1){
	        this.shapes.splice(idx,1);
	        this.aabbNeedsUpdate = true;
	        shape.body = null;
	        return true;
	    } else {
	        return false;
	    }
	};
	
	/**
	 * Updates .inertia, .invMass, .invInertia for this Body. Should be called when
	 * changing the structure or mass of the Body.
	 *
	 * @method updateMassProperties
	 *
	 * @example
	 *     body.mass += 1;
	 *     body.updateMassProperties();
	 */
	Body.prototype.updateMassProperties = function(){
	    if(this.type === Body.STATIC || this.type === Body.KINEMATIC){
	
	        this.mass = Number.MAX_VALUE;
	        this.invMass = 0;
	        this.inertia = Number.MAX_VALUE;
	        this.invInertia = 0;
	
	    } else {
	
	        var shapes = this.shapes,
	            N = shapes.length,
	            m = this.mass / N,
	            I = 0;
	
	        if(!this.fixedRotation){
	            for(var i=0; i<N; i++){
	                var shape = shapes[i],
	                    r2 = vec2.squaredLength(shape.position),
	                    Icm = shape.computeMomentOfInertia(m);
	                I += Icm + m*r2;
	            }
	            this.inertia = I;
	            this.invInertia = I>0 ? 1/I : 0;
	
	        } else {
	            this.inertia = Number.MAX_VALUE;
	            this.invInertia = 0;
	        }
	
	        // Inverse mass properties are easy
	        this.invMass = 1 / this.mass;
	
	        vec2.set(
	            this.massMultiplier,
	            this.fixedX ? 0 : 1,
	            this.fixedY ? 0 : 1
	        );
	    }
	};
	
	var Body_applyForce_r = vec2.create();
	
	/**
	 * Apply force to a point relative to the center of mass of the body. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce. If relativePoint is zero, the force will be applied directly on the center of mass, and the torque produced will be zero.
	 * @method applyForce
	 * @param {Array} force The force to add.
	 * @param {Array} [relativePoint] A world point to apply the force on.
	 */
	Body.prototype.applyForce = function(force, relativePoint){
	
	    // Add linear force
	    vec2.add(this.force, this.force, force);
	
	    if(relativePoint){
	
	        // Compute produced rotational force
	        var rotForce = vec2.crossLength(relativePoint,force);
	
	        // Add rotational force
	        this.angularForce += rotForce;
	    }
	};
	
	/**
	 * Apply force to a body-local point.
	 * @method applyForceLocal
	 * @param  {Array} localForce The force vector to add, oriented in local body space.
	 * @param  {Array} localPoint A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.
	 */
	var Body_applyForce_forceWorld = vec2.create();
	var Body_applyForce_pointWorld = vec2.create();
	var Body_applyForce_pointLocal = vec2.create();
	Body.prototype.applyForceLocal = function(localForce, localPoint){
	    localPoint = localPoint || Body_applyForce_pointLocal;
	    var worldForce = Body_applyForce_forceWorld;
	    var worldPoint = Body_applyForce_pointWorld;
	    this.vectorToWorldFrame(worldForce, localForce);
	    this.vectorToWorldFrame(worldPoint, localPoint);
	    this.applyForce(worldForce, worldPoint);
	};
	
	/**
	 * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
	 * @method applyImpulse
	 * @param  {Array} impulse The impulse vector to add, oriented in world space.
	 * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.
	 */
	var Body_applyImpulse_velo = vec2.create();
	Body.prototype.applyImpulse = function(impulseVector, relativePoint){
	    if(this.type !== Body.DYNAMIC){
	        return;
	    }
	
	    // Compute produced central impulse velocity
	    var velo = Body_applyImpulse_velo;
	    vec2.scale(velo, impulseVector, this.invMass);
	    vec2.multiply(velo, this.massMultiplier, velo);
	
	    // Add linear impulse
	    vec2.add(this.velocity, velo, this.velocity);
	
	    if(relativePoint){
	        // Compute produced rotational impulse velocity
	        var rotVelo = vec2.crossLength(relativePoint, impulseVector);
	        rotVelo *= this.invInertia;
	
	        // Add rotational Impulse
	        this.angularVelocity += rotVelo;
	    }
	};
	
	/**
	 * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
	 * @method applyImpulseLocal
	 * @param  {Array} impulse The impulse vector to add, oriented in world space.
	 * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.
	 */
	var Body_applyImpulse_impulseWorld = vec2.create();
	var Body_applyImpulse_pointWorld = vec2.create();
	var Body_applyImpulse_pointLocal = vec2.create();
	Body.prototype.applyImpulseLocal = function(localImpulse, localPoint){
	    localPoint = localPoint || Body_applyImpulse_pointLocal;
	    var worldImpulse = Body_applyImpulse_impulseWorld;
	    var worldPoint = Body_applyImpulse_pointWorld;
	    this.vectorToWorldFrame(worldImpulse, localImpulse);
	    this.vectorToWorldFrame(worldPoint, localPoint);
	    this.applyImpulse(worldImpulse, worldPoint);
	};
	
	/**
	 * Transform a world point to local body frame.
	 * @method toLocalFrame
	 * @param  {Array} out          The vector to store the result in
	 * @param  {Array} worldPoint   The input world point
	 */
	Body.prototype.toLocalFrame = function(out, worldPoint){
	    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
	};
	
	/**
	 * Transform a local point to world frame.
	 * @method toWorldFrame
	 * @param  {Array} out          The vector to store the result in
	 * @param  {Array} localPoint   The input local point
	 */
	Body.prototype.toWorldFrame = function(out, localPoint){
	    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
	};
	
	/**
	 * Transform a world point to local body frame.
	 * @method vectorToLocalFrame
	 * @param  {Array} out          The vector to store the result in
	 * @param  {Array} worldVector  The input world vector
	 */
	Body.prototype.vectorToLocalFrame = function(out, worldVector){
	    vec2.vectorToLocalFrame(out, worldVector, this.angle);
	};
	
	/**
	 * Transform a local point to world frame.
	 * @method vectorToWorldFrame
	 * @param  {Array} out          The vector to store the result in
	 * @param  {Array} localVector  The input local vector
	 */
	Body.prototype.vectorToWorldFrame = function(out, localVector){
	    vec2.vectorToGlobalFrame(out, localVector, this.angle);
	};
	
	/**
	 * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
	 * @method fromPolygon
	 * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
	 * @param {Object} [options]
	 * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
	 * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
	 * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
	 * @return {Boolean} True on success, else false.
	 */
	Body.prototype.fromPolygon = function(path,options){
	    options = options || {};
	
	    // Remove all shapes
	    for(var i=this.shapes.length; i>=0; --i){
	        this.removeShape(this.shapes[i]);
	    }
	
	    var p = new decomp.Polygon();
	    p.vertices = path;
	
	    // Make it counter-clockwise
	    p.makeCCW();
	
	    if(typeof(options.removeCollinearPoints) === "number"){
	        p.removeCollinearPoints(options.removeCollinearPoints);
	    }
	
	    // Check if any line segment intersects the path itself
	    if(typeof(options.skipSimpleCheck) === "undefined"){
	        if(!p.isSimple()){
	            return false;
	        }
	    }
	
	    // Save this path for later
	    this.concavePath = p.vertices.slice(0);
	    for(var i=0; i<this.concavePath.length; i++){
	        var v = [0,0];
	        vec2.copy(v,this.concavePath[i]);
	        this.concavePath[i] = v;
	    }
	
	    // Slow or fast decomp?
	    var convexes;
	    if(options.optimalDecomp){
	        convexes = p.decomp();
	    } else {
	        convexes = p.quickDecomp();
	    }
	
	    var cm = vec2.create();
	
	    // Add convexes
	    for(var i=0; i!==convexes.length; i++){
	        // Create convex
	        var c = new Convex({ vertices: convexes[i].vertices });
	
	        // Move all vertices so its center of mass is in the local center of the convex
	        for(var j=0; j!==c.vertices.length; j++){
	            var v = c.vertices[j];
	            vec2.sub(v,v,c.centerOfMass);
	        }
	
	        vec2.scale(cm,c.centerOfMass,1);
	        c.updateTriangles();
	        c.updateCenterOfMass();
	        c.updateBoundingRadius();
	
	        // Add the shape
	        this.addShape(c,cm);
	    }
	
	    this.adjustCenterOfMass();
	
	    this.aabbNeedsUpdate = true;
	
	    return true;
	};
	
	var adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),
	    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),
	    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),
	    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);
	
	/**
	 * Moves the shape offsets so their center of mass becomes the body center of mass.
	 * @method adjustCenterOfMass
	 */
	Body.prototype.adjustCenterOfMass = function(){
	    var offset_times_area = adjustCenterOfMass_tmp2,
	        sum =               adjustCenterOfMass_tmp3,
	        cm =                adjustCenterOfMass_tmp4,
	        totalArea =         0;
	    vec2.set(sum,0,0);
	
	    for(var i=0; i!==this.shapes.length; i++){
	        var s = this.shapes[i];
	        vec2.scale(offset_times_area, s.position, s.area);
	        vec2.add(sum, sum, offset_times_area);
	        totalArea += s.area;
	    }
	
	    vec2.scale(cm,sum,1/totalArea);
	
	    // Now move all shapes
	    for(var i=0; i!==this.shapes.length; i++){
	        var s = this.shapes[i];
	        vec2.sub(s.position, s.position, cm);
	    }
	
	    // Move the body position too
	    vec2.add(this.position,this.position,cm);
	
	    // And concave path
	    for(var i=0; this.concavePath && i<this.concavePath.length; i++){
	        vec2.sub(this.concavePath[i], this.concavePath[i], cm);
	    }
	
	    this.updateMassProperties();
	    this.updateBoundingRadius();
	};
	
	/**
	 * Sets the force on the body to zero.
	 * @method setZeroForce
	 */
	Body.prototype.setZeroForce = function(){
	    vec2.set(this.force,0.0,0.0);
	    this.angularForce = 0.0;
	};
	
	Body.prototype.resetConstraintVelocity = function(){
	    var b = this,
	        vlambda = b.vlambda;
	    vec2.set(vlambda,0,0);
	    b.wlambda = 0;
	};
	
	Body.prototype.addConstraintVelocity = function(){
	    var b = this,
	        v = b.velocity;
	    vec2.add( v, v, b.vlambda);
	    b.angularVelocity += b.wlambda;
	};
	
	/**
	 * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
	 * @method applyDamping
	 * @param  {number} dt Current time step
	 */
	Body.prototype.applyDamping = function(dt){
	    if(this.type === Body.DYNAMIC){ // Only for dynamic bodies
	        var v = this.velocity;
	        vec2.scale(v, v, Math.pow(1.0 - this.damping,dt));
	        this.angularVelocity *= Math.pow(1.0 - this.angularDamping,dt);
	    }
	};
	
	/**
	 * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
	 * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
	 * @method wakeUp
	 */
	Body.prototype.wakeUp = function(){
	    var s = this.sleepState;
	    this.sleepState = Body.AWAKE;
	    this.idleTime = 0;
	    if(s !== Body.AWAKE){
	        this.emit(Body.wakeUpEvent);
	    }
	};
	
	/**
	 * Force body sleep
	 * @method sleep
	 */
	Body.prototype.sleep = function(){
	    this.sleepState = Body.SLEEPING;
	    this.angularVelocity = 0;
	    this.angularForce = 0;
	    vec2.set(this.velocity,0,0);
	    vec2.set(this.force,0,0);
	    this.emit(Body.sleepEvent);
	};
	
	/**
	 * Called every timestep to update internal sleep timer and change sleep state if needed.
	 * @method sleepTick
	 * @param {number} time The world time in seconds
	 * @param {boolean} dontSleep
	 * @param {number} dt
	 */
	Body.prototype.sleepTick = function(time, dontSleep, dt){
	    if(!this.allowSleep || this.type === Body.SLEEPING){
	        return;
	    }
	
	    this.wantsToSleep = false;
	
	    var sleepState = this.sleepState,
	        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),
	        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);
	
	    // Add to idle time
	    if(speedSquared >= speedLimitSquared){
	        this.idleTime = 0;
	        this.sleepState = Body.AWAKE;
	    } else {
	        this.idleTime += dt;
	        this.sleepState = Body.SLEEPY;
	    }
	    if(this.idleTime > this.sleepTimeLimit){
	        if(!dontSleep){
	            this.sleep();
	        } else {
	            this.wantsToSleep = true;
	        }
	    }
	};
	
	/**
	 * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
	 * @method overlaps
	 * @param  {Body} body
	 * @return {boolean}
	 */
	Body.prototype.overlaps = function(body){
	    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
	};
	
	var integrate_fhMinv = vec2.create();
	var integrate_velodt = vec2.create();
	
	/**
	 * Move the body forward in time given its current velocity.
	 * @method integrate
	 * @param  {Number} dt
	 */
	Body.prototype.integrate = function(dt){
	    var minv = this.invMass,
	        f = this.force,
	        pos = this.position,
	        velo = this.velocity;
	
	    // Save old position
	    vec2.copy(this.previousPosition, this.position);
	    this.previousAngle = this.angle;
	
	    // Velocity update
	    if(!this.fixedRotation){
	        this.angularVelocity += this.angularForce * this.invInertia * dt;
	    }
	    vec2.scale(integrate_fhMinv, f, dt * minv);
	    vec2.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);
	    vec2.add(velo, integrate_fhMinv, velo);
	
	    // CCD
	    if(!this.integrateToTimeOfImpact(dt)){
	
	        // Regular position update
	        vec2.scale(integrate_velodt, velo, dt);
	        vec2.add(pos, pos, integrate_velodt);
	        if(!this.fixedRotation){
	            this.angle += this.angularVelocity * dt;
	        }
	    }
	
	    this.aabbNeedsUpdate = true;
	};
	
	var result = new RaycastResult();
	var ray = new Ray({
	    mode: Ray.ALL
	});
	var direction = vec2.create();
	var end = vec2.create();
	var startToEnd = vec2.create();
	var rememberPosition = vec2.create();
	Body.prototype.integrateToTimeOfImpact = function(dt){
	
	    if(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)){
	        return false;
	    }
	
	    vec2.normalize(direction, this.velocity);
	
	    vec2.scale(end, this.velocity, dt);
	    vec2.add(end, end, this.position);
	
	    vec2.sub(startToEnd, end, this.position);
	    var startToEndAngle = this.angularVelocity * dt;
	    var len = vec2.length(startToEnd);
	
	    var timeOfImpact = 1;
	
	    var hit;
	    var that = this;
	    result.reset();
	    ray.callback = function (result) {
	        if(result.body === that){
	            return;
	        }
	        hit = result.body;
	        result.getHitPoint(end, ray);
	        vec2.sub(startToEnd, end, that.position);
	        timeOfImpact = vec2.length(startToEnd) / len;
	        result.stop();
	    };
	    vec2.copy(ray.from, this.position);
	    vec2.copy(ray.to, end);
	    ray.update();
	    this.world.raycast(result, ray);
	
	    if(!hit){
	        return false;
	    }
	
	    var rememberAngle = this.angle;
	    vec2.copy(rememberPosition, this.position);
	
	    // Got a start and end point. Approximate time of impact using binary search
	    var iter = 0;
	    var tmin = 0;
	    var tmid = 0;
	    var tmax = timeOfImpact;
	    while (tmax >= tmin && iter < this.ccdIterations) {
	        iter++;
	
	        // calculate the midpoint
	        tmid = (tmax - tmin) / 2;
	
	        // Move the body to that point
	        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
	        vec2.add(this.position, rememberPosition, integrate_velodt);
	        this.angle = rememberAngle + startToEndAngle * timeOfImpact;
	        this.updateAABB();
	
	        // check overlap
	        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);
	
	        if (overlaps) {
	            // change min to search upper interval
	            tmin = tmid;
	        } else {
	            // change max to search lower interval
	            tmax = tmid;
	        }
	    }
	
	    timeOfImpact = tmid;
	
	    vec2.copy(this.position, rememberPosition);
	    this.angle = rememberAngle;
	
	    // move to TOI
	    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
	    vec2.add(this.position, this.position, integrate_velodt);
	    if(!this.fixedRotation){
	        this.angle += startToEndAngle * timeOfImpact;
	    }
	
	    return true;
	};
	
	/**
	 * Get velocity of a point in the body.
	 * @method getVelocityAtPoint
	 * @param  {Array} result A vector to store the result in
	 * @param  {Array} relativePoint A world oriented vector, indicating the position of the point to get the velocity from
	 * @return {Array} The result vector
	 */
	Body.prototype.getVelocityAtPoint = function(result, relativePoint){
	    vec2.crossVZ(result, relativePoint, this.angularVelocity);
	    vec2.subtract(result, this.velocity, result);
	    return result;
	};
	
	/**
	 * @event sleepy
	 */
	Body.sleepyEvent = {
	    type: "sleepy"
	};
	
	/**
	 * @event sleep
	 */
	Body.sleepEvent = {
	    type: "sleep"
	};
	
	/**
	 * @event wakeup
	 */
	Body.wakeUpEvent = {
	    type: "wakeup"
	};
	
	/**
	 * Dynamic body.
	 * @property DYNAMIC
	 * @type {Number}
	 * @static
	 */
	Body.DYNAMIC = 1;
	
	/**
	 * Static body.
	 * @property STATIC
	 * @type {Number}
	 * @static
	 */
	Body.STATIC = 2;
	
	/**
	 * Kinematic body.
	 * @property KINEMATIC
	 * @type {Number}
	 * @static
	 */
	Body.KINEMATIC = 4;
	
	/**
	 * @property AWAKE
	 * @type {Number}
	 * @static
	 */
	Body.AWAKE = 0;
	
	/**
	 * @property SLEEPY
	 * @type {Number}
	 * @static
	 */
	Body.SLEEPY = 1;
	
	/**
	 * @property SLEEPING
	 * @type {Number}
	 * @static
	 */
	Body.SLEEPING = 2;
	


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    Polygon : __webpack_require__(11),
	    Point : __webpack_require__(14),
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var Line = __webpack_require__(12)
	,   Point = __webpack_require__(14)
	,   Scalar = __webpack_require__(13)
	
	module.exports = Polygon;
	
	/**
	 * Polygon class.
	 * @class Polygon
	 * @constructor
	 */
	function Polygon(){
	
	    /**
	     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]
	     * @property vertices
	     * @type {Array}
	     */
	    this.vertices = [];
	}
	
	/**
	 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
	 * @method at
	 * @param  {Number} i
	 * @return {Array}
	 */
	Polygon.prototype.at = function(i){
	    var v = this.vertices,
	        s = v.length;
	    return v[i < 0 ? i % s + s : i % s];
	};
	
	/**
	 * Get first vertex
	 * @method first
	 * @return {Array}
	 */
	Polygon.prototype.first = function(){
	    return this.vertices[0];
	};
	
	/**
	 * Get last vertex
	 * @method last
	 * @return {Array}
	 */
	Polygon.prototype.last = function(){
	    return this.vertices[this.vertices.length-1];
	};
	
	/**
	 * Clear the polygon data
	 * @method clear
	 * @return {Array}
	 */
	Polygon.prototype.clear = function(){
	    this.vertices.length = 0;
	};
	
	/**
	 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
	 * @method append
	 * @param {Polygon} poly The polygon to get points from.
	 * @param {Number}  from The vertex index in "poly".
	 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
	 * @return {Array}
	 */
	Polygon.prototype.append = function(poly,from,to){
	    if(typeof(from) == "undefined") throw new Error("From is not given!");
	    if(typeof(to) == "undefined")   throw new Error("To is not given!");
	
	    if(to-1 < from)                 throw new Error("lol1");
	    if(to > poly.vertices.length)   throw new Error("lol2");
	    if(from < 0)                    throw new Error("lol3");
	
	    for(var i=from; i<to; i++){
	        this.vertices.push(poly.vertices[i]);
	    }
	};
	
	/**
	 * Make sure that the polygon vertices are ordered counter-clockwise.
	 * @method makeCCW
	 */
	Polygon.prototype.makeCCW = function(){
	    var br = 0,
	        v = this.vertices;
	
	    // find bottom right point
	    for (var i = 1; i < this.vertices.length; ++i) {
	        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {
	            br = i;
	        }
	    }
	
	    // reverse poly if clockwise
	    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
	        this.reverse();
	    }
	};
	
	/**
	 * Reverse the vertices in the polygon
	 * @method reverse
	 */
	Polygon.prototype.reverse = function(){
	    var tmp = [];
	    for(var i=0, N=this.vertices.length; i!==N; i++){
	        tmp.push(this.vertices.pop());
	    }
	    this.vertices = tmp;
	};
	
	/**
	 * Check if a point in the polygon is a reflex point
	 * @method isReflex
	 * @param  {Number}  i
	 * @return {Boolean}
	 */
	Polygon.prototype.isReflex = function(i){
	    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
	};
	
	var tmpLine1=[],
	    tmpLine2=[];
	
	/**
	 * Check if two vertices in the polygon can see each other
	 * @method canSee
	 * @param  {Number} a Vertex index 1
	 * @param  {Number} b Vertex index 2
	 * @return {Boolean}
	 */
	Polygon.prototype.canSee = function(a,b) {
	    var p, dist, l1=tmpLine1, l2=tmpLine2;
	
	    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
	        return false;
	    }
	    dist = Point.sqdist(this.at(a), this.at(b));
	    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge
	        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges
	            continue;
	        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge
	            l1[0] = this.at(a);
	            l1[1] = this.at(b);
	            l2[0] = this.at(i);
	            l2[1] = this.at(i + 1);
	            p = Line.lineInt(l1,l2);
	            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b
	                return false;
	            }
	        }
	    }
	
	    return true;
	};
	
	/**
	 * Copy the polygon from vertex i to vertex j.
	 * @method copy
	 * @param  {Number} i
	 * @param  {Number} j
	 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
	 * @return {Polygon}                The resulting copy.
	 */
	Polygon.prototype.copy = function(i,j,targetPoly){
	    var p = targetPoly || new Polygon();
	    p.clear();
	    if (i < j) {
	        // Insert all vertices from i to j
	        for(var k=i; k<=j; k++)
	            p.vertices.push(this.vertices[k]);
	
	    } else {
	
	        // Insert vertices 0 to j
	        for(var k=0; k<=j; k++)
	            p.vertices.push(this.vertices[k]);
	
	        // Insert vertices i to end
	        for(var k=i; k<this.vertices.length; k++)
	            p.vertices.push(this.vertices[k]);
	    }
	
	    return p;
	};
	
	/**
	 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
	 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
	 * @method getCutEdges
	 * @return {Array}
	 */
	Polygon.prototype.getCutEdges = function() {
	    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();
	    var nDiags = Number.MAX_VALUE;
	
	    for (var i = 0; i < this.vertices.length; ++i) {
	        if (this.isReflex(i)) {
	            for (var j = 0; j < this.vertices.length; ++j) {
	                if (this.canSee(i, j)) {
	                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
	                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();
	
	                    for(var k=0; k<tmp2.length; k++)
	                        tmp1.push(tmp2[k]);
	
	                    if (tmp1.length < nDiags) {
	                        min = tmp1;
	                        nDiags = tmp1.length;
	                        min.push([this.at(i), this.at(j)]);
	                    }
	                }
	            }
	        }
	    }
	
	    return min;
	};
	
	/**
	 * Decomposes the polygon into one or more convex sub-Polygons.
	 * @method decomp
	 * @return {Array} An array or Polygon objects.
	 */
	Polygon.prototype.decomp = function(){
	    var edges = this.getCutEdges();
	    if(edges.length > 0)
	        return this.slice(edges);
	    else
	        return [this];
	};
	
	/**
	 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
	 * @method slice
	 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
	 * @return {Array}
	 */
	Polygon.prototype.slice = function(cutEdges){
	    if(cutEdges.length == 0) return [this];
	    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){
	
	        var polys = [this];
	
	        for(var i=0; i<cutEdges.length; i++){
	            var cutEdge = cutEdges[i];
	            // Cut all polys
	            for(var j=0; j<polys.length; j++){
	                var poly = polys[j];
	                var result = poly.slice(cutEdge);
	                if(result){
	                    // Found poly! Cut and quit
	                    polys.splice(j,1);
	                    polys.push(result[0],result[1]);
	                    break;
	                }
	            }
	        }
	
	        return polys;
	    } else {
	
	        // Was given one edge
	        var cutEdge = cutEdges;
	        var i = this.vertices.indexOf(cutEdge[0]);
	        var j = this.vertices.indexOf(cutEdge[1]);
	
	        if(i != -1 && j != -1){
	            return [this.copy(i,j),
	                    this.copy(j,i)];
	        } else {
	            return false;
	        }
	    }
	};
	
	/**
	 * Checks that the line segments of this polygon do not intersect each other.
	 * @method isSimple
	 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
	 * @return {Boolean}
	 * @todo Should it check all segments with all others?
	 */
	Polygon.prototype.isSimple = function(){
	    var path = this.vertices;
	    // Check
	    for(var i=0; i<path.length-1; i++){
	        for(var j=0; j<i-1; j++){
	            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
	                return false;
	            }
	        }
	    }
	
	    // Check the segment between the last and the first point to all others
	    for(var i=1; i<path.length-2; i++){
	        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
	            return false;
	        }
	    }
	
	    return true;
	};
	
	function getIntersectionPoint(p1, p2, q1, q2, delta){
	    delta = delta || 0;
	   var a1 = p2[1] - p1[1];
	   var b1 = p1[0] - p2[0];
	   var c1 = (a1 * p1[0]) + (b1 * p1[1]);
	   var a2 = q2[1] - q1[1];
	   var b2 = q1[0] - q2[0];
	   var c2 = (a2 * q1[0]) + (b2 * q1[1]);
	   var det = (a1 * b2) - (a2 * b1);
	
	   if(!Scalar.eq(det,0,delta))
	      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]
	   else
	      return [0,0]
	}
	
	/**
	 * Quickly decompose the Polygon into convex sub-polygons.
	 * @method quickDecomp
	 * @param  {Array} result
	 * @param  {Array} [reflexVertices]
	 * @param  {Array} [steinerPoints]
	 * @param  {Number} [delta]
	 * @param  {Number} [maxlevel]
	 * @param  {Number} [level]
	 * @return {Array}
	 */
	Polygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){
	    maxlevel = maxlevel || 100;
	    level = level || 0;
	    delta = delta || 25;
	    result = typeof(result)!="undefined" ? result : [];
	    reflexVertices = reflexVertices || [];
	    steinerPoints = steinerPoints || [];
	
	    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
	    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
	    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
	    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons
	    var poly = this,
	        v = this.vertices;
	
	    if(v.length < 3) return result;
	
	    level++;
	    if(level > maxlevel){
	        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
	        return result;
	    }
	
	    for (var i = 0; i < this.vertices.length; ++i) {
	        if (poly.isReflex(i)) {
	            reflexVertices.push(poly.vertices[i]);
	            upperDist = lowerDist = Number.MAX_VALUE;
	
	
	            for (var j = 0; j < this.vertices.length; ++j) {
	                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))
	                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge
	                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection
	                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly
	                        d = Point.sqdist(poly.vertices[i], p);
	                        if (d < lowerDist) { // keep only the closest intersection
	                            lowerDist = d;
	                            lowerInt = p;
	                            lowerIndex = j;
	                        }
	                    }
	                }
	                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))
	                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
	                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
	                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {
	                        d = Point.sqdist(poly.vertices[i], p);
	                        if (d < upperDist) {
	                            upperDist = d;
	                            upperInt = p;
	                            upperIndex = j;
	                        }
	                    }
	                }
	            }
	
	            // if there are no vertices to connect to, choose a point in the middle
	            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
	                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+this.vertices.length+")");
	                p[0] = (lowerInt[0] + upperInt[0]) / 2;
	                p[1] = (lowerInt[1] + upperInt[1]) / 2;
	                steinerPoints.push(p);
	
	                if (i < upperIndex) {
	                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
	                    lowerPoly.append(poly, i, upperIndex+1);
	                    lowerPoly.vertices.push(p);
	                    upperPoly.vertices.push(p);
	                    if (lowerIndex != 0){
	                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
	                        upperPoly.append(poly,lowerIndex,poly.vertices.length);
	                    }
	                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
	                    upperPoly.append(poly,0,i+1);
	                } else {
	                    if (i != 0){
	                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
	                        lowerPoly.append(poly,i,poly.vertices.length);
	                    }
	                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
	                    lowerPoly.append(poly,0,upperIndex+1);
	                    lowerPoly.vertices.push(p);
	                    upperPoly.vertices.push(p);
	                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
	                    upperPoly.append(poly,lowerIndex,i+1);
	                }
	            } else {
	                // connect to the closest point within the triangle
	                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+this.vertices.length+")\n");
	
	                if (lowerIndex > upperIndex) {
	                    upperIndex += this.vertices.length;
	                }
	                closestDist = Number.MAX_VALUE;
	
	                if(upperIndex < lowerIndex){
	                    return result;
	                }
	
	                for (var j = lowerIndex; j <= upperIndex; ++j) {
	                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))
	                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
	                        d = Point.sqdist(poly.at(i), poly.at(j));
	                        if (d < closestDist) {
	                            closestDist = d;
	                            closestIndex = j % this.vertices.length;
	                        }
	                    }
	                }
	
	                if (i < closestIndex) {
	                    lowerPoly.append(poly,i,closestIndex+1);
	                    if (closestIndex != 0){
	                        upperPoly.append(poly,closestIndex,v.length);
	                    }
	                    upperPoly.append(poly,0,i+1);
	                } else {
	                    if (i != 0){
	                        lowerPoly.append(poly,i,v.length);
	                    }
	                    lowerPoly.append(poly,0,closestIndex+1);
	                    upperPoly.append(poly,closestIndex,i+1);
	                }
	            }
	
	            // solve smallest poly first
	            if (lowerPoly.vertices.length < upperPoly.vertices.length) {
	                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
	                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
	            } else {
	                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
	                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
	            }
	
	            return result;
	        }
	    }
	    result.push(this);
	
	    return result;
	};
	
	/**
	 * Remove collinear points in the polygon.
	 * @method removeCollinearPoints
	 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
	 * @return {Number}           The number of points removed
	 */
	Polygon.prototype.removeCollinearPoints = function(precision){
	    var num = 0;
	    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){
	        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){
	            // Remove the middle point
	            this.vertices.splice(i%this.vertices.length,1);
	            i--; // Jump one point forward. Otherwise we may get a chain removal
	            num++;
	        }
	    }
	    return num;
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var Scalar = __webpack_require__(13);
	
	module.exports = Line;
	
	/**
	 * Container for line-related functions
	 * @class Line
	 */
	function Line(){};
	
	/**
	 * Compute the intersection between two lines.
	 * @static
	 * @method lineInt
	 * @param  {Array}  l1          Line vector 1
	 * @param  {Array}  l2          Line vector 2
	 * @param  {Number} precision   Precision to use when checking if the lines are parallel
	 * @return {Array}              The intersection point.
	 */
	Line.lineInt = function(l1,l2,precision){
	    precision = precision || 0;
	    var i = [0,0]; // point
	    var a1, b1, c1, a2, b2, c2, det; // scalars
	    a1 = l1[1][1] - l1[0][1];
	    b1 = l1[0][0] - l1[1][0];
	    c1 = a1 * l1[0][0] + b1 * l1[0][1];
	    a2 = l2[1][1] - l2[0][1];
	    b2 = l2[0][0] - l2[1][0];
	    c2 = a2 * l2[0][0] + b2 * l2[0][1];
	    det = a1 * b2 - a2*b1;
	    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel
	        i[0] = (b2 * c1 - b1 * c2) / det;
	        i[1] = (a1 * c2 - a2 * c1) / det;
	    }
	    return i;
	};
	
	/**
	 * Checks if two line segments intersects.
	 * @method segmentsIntersect
	 * @param {Array} p1 The start vertex of the first line segment.
	 * @param {Array} p2 The end vertex of the first line segment.
	 * @param {Array} q1 The start vertex of the second line segment.
	 * @param {Array} q2 The end vertex of the second line segment.
	 * @return {Boolean} True if the two line segments intersect
	 */
	Line.segmentsIntersect = function(p1, p2, q1, q2){
	   var dx = p2[0] - p1[0];
	   var dy = p2[1] - p1[1];
	   var da = q2[0] - q1[0];
	   var db = q2[1] - q1[1];
	
	   // segments are parallel
	   if(da*dy - db*dx == 0)
	      return false;
	
	   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)
	   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)
	
	   return (s>=0 && s<=1 && t>=0 && t<=1);
	};
	


/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = Scalar;
	
	/**
	 * Scalar functions
	 * @class Scalar
	 */
	function Scalar(){}
	
	/**
	 * Check if two scalars are equal
	 * @static
	 * @method eq
	 * @param  {Number} a
	 * @param  {Number} b
	 * @param  {Number} [precision]
	 * @return {Boolean}
	 */
	Scalar.eq = function(a,b,precision){
	    precision = precision || 0;
	    return Math.abs(a-b) < precision;
	};


/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = Point;
	
	/**
	 * Point related functions
	 * @class Point
	 */
	function Point(){};
	
	/**
	 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
	 * @static
	 * @method area
	 * @param  {Array} a
	 * @param  {Array} b
	 * @param  {Array} c
	 * @return {Number}
	 */
	Point.area = function(a,b,c){
	    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
	};
	
	Point.left = function(a,b,c){
	    return Point.area(a,b,c) > 0;
	};
	
	Point.leftOn = function(a,b,c) {
	    return Point.area(a, b, c) >= 0;
	};
	
	Point.right = function(a,b,c) {
	    return Point.area(a, b, c) < 0;
	};
	
	Point.rightOn = function(a,b,c) {
	    return Point.area(a, b, c) <= 0;
	};
	
	var tmpPoint1 = [],
	    tmpPoint2 = [];
	
	/**
	 * Check if three points are collinear
	 * @method collinear
	 * @param  {Array} a
	 * @param  {Array} b
	 * @param  {Array} c
	 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
	 * @return {Boolean}
	 */
	Point.collinear = function(a,b,c,thresholdAngle) {
	    if(!thresholdAngle)
	        return Point.area(a, b, c) == 0;
	    else {
	        var ab = tmpPoint1,
	            bc = tmpPoint2;
	
	        ab[0] = b[0]-a[0];
	        ab[1] = b[1]-a[1];
	        bc[0] = c[0]-b[0];
	        bc[1] = c[1]-b[1];
	
	        var dot = ab[0]*bc[0] + ab[1]*bc[1],
	            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
	            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
	            angle = Math.acos(dot/(magA*magB));
	        return angle < thresholdAngle;
	    }
	};
	
	Point.sqdist = function(a,b){
	    var dx = b[0] - a[0];
	    var dy = b[1] - a[1];
	    return dx * dx + dy * dy;
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var Shape = __webpack_require__(16)
	,   vec2 = __webpack_require__(4)
	,   polyk = __webpack_require__(17)
	,   decomp = __webpack_require__(10);
	
	module.exports = Convex;
	
	/**
	 * Convex shape class.
	 * @class Convex
	 * @constructor
	 * @extends Shape
	 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
	 * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
	 * @param {Array} [options.axes] An array of unit length vectors, representing the symmetry axes in the convex.
	 * @example
	 *     // Create a box
	 *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
	 *     var convexShape = new Convex({ vertices: vertices });
	 *     body.addShape(convexShape);
	 */
	function Convex(options){
	    if(Array.isArray(arguments[0])){
	        options = {
	            vertices: arguments[0],
	            axes: arguments[1]
	        };
	        console.warn('The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })');
	    }
	    options = options || {};
	
	    /**
	     * Vertices defined in the local frame.
	     * @property vertices
	     * @type {Array}
	     */
	    this.vertices = [];
	
	    // Copy the verts
	    var vertices = options.vertices !== undefined ? options.vertices : [];
	    for(var i=0; i < vertices.length; i++){
	        var v = vec2.create();
	        vec2.copy(v, vertices[i]);
	        this.vertices.push(v);
	    }
	
	    /**
	     * Axes defined in the local frame.
	     * @property axes
	     * @type {Array}
	     */
	    this.axes = [];
	
	    if(options.axes){
	
	        // Copy the axes
	        for(var i=0; i < options.axes.length; i++){
	            var axis = vec2.create();
	            vec2.copy(axis, options.axes[i]);
	            this.axes.push(axis);
	        }
	
	    } else {
	
	        // Construct axes from the vertex data
	        for(var i = 0; i < this.vertices.length; i++){
	            // Get the world edge
	            var worldPoint0 = this.vertices[i];
	            var worldPoint1 = this.vertices[(i+1) % this.vertices.length];
	
	            var normal = vec2.create();
	            vec2.sub(normal, worldPoint1, worldPoint0);
	
	            // Get normal - just rotate 90 degrees since vertices are given in CCW
	            vec2.rotate90cw(normal, normal);
	            vec2.normalize(normal, normal);
	
	            this.axes.push(normal);
	        }
	
	    }
	
	    /**
	     * The center of mass of the Convex
	     * @property centerOfMass
	     * @type {Array}
	     */
	    this.centerOfMass = vec2.fromValues(0,0);
	
	    /**
	     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
	     * @property triangles
	     * @type {Array}
	     */
	    this.triangles = [];
	
	    if(this.vertices.length){
	        this.updateTriangles();
	        this.updateCenterOfMass();
	    }
	
	    /**
	     * The bounding radius of the convex
	     * @property boundingRadius
	     * @type {Number}
	     */
	    this.boundingRadius = 0;
	
	    options.type = Shape.CONVEX;
	    Shape.call(this, options);
	
	    this.updateBoundingRadius();
	    this.updateArea();
	    if(this.area < 0){
	        throw new Error("Convex vertices must be given in conter-clockwise winding.");
	    }
	}
	Convex.prototype = new Shape();
	Convex.prototype.constructor = Convex;
	
	var tmpVec1 = vec2.create();
	var tmpVec2 = vec2.create();
	
	/**
	 * Project a Convex onto a world-oriented axis
	 * @method projectOntoAxis
	 * @static
	 * @param  {Array} offset
	 * @param  {Array} localAxis
	 * @param  {Array} result
	 */
	Convex.prototype.projectOntoLocalAxis = function(localAxis, result){
	    var max=null,
	        min=null,
	        v,
	        value,
	        localAxis = tmpVec1;
	
	    // Get projected position of all vertices
	    for(var i=0; i<this.vertices.length; i++){
	        v = this.vertices[i];
	        value = vec2.dot(v, localAxis);
	        if(max === null || value > max){
	            max = value;
	        }
	        if(min === null || value < min){
	            min = value;
	        }
	    }
	
	    if(min > max){
	        var t = min;
	        min = max;
	        max = t;
	    }
	
	    vec2.set(result, min, max);
	};
	
	Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result){
	    var worldAxis = tmpVec2;
	
	    this.projectOntoLocalAxis(localAxis, result);
	
	    // Project the position of the body onto the axis - need to add this to the result
	    if(shapeAngle !== 0){
	        vec2.rotate(worldAxis, localAxis, shapeAngle);
	    } else {
	        worldAxis = localAxis;
	    }
	    var offset = vec2.dot(shapeOffset, worldAxis);
	
	    vec2.set(result, result[0] + offset, result[1] + offset);
	};
	
	
	/**
	 * Update the .triangles property
	 * @method updateTriangles
	 */
	Convex.prototype.updateTriangles = function(){
	
	    this.triangles.length = 0;
	
	    // Rewrite on polyk notation, array of numbers
	    var polykVerts = [];
	    for(var i=0; i<this.vertices.length; i++){
	        var v = this.vertices[i];
	        polykVerts.push(v[0],v[1]);
	    }
	
	    // Triangulate
	    var triangles = polyk.Triangulate(polykVerts);
	
	    // Loop over all triangles, add their inertia contributions to I
	    for(var i=0; i<triangles.length; i+=3){
	        var id1 = triangles[i],
	            id2 = triangles[i+1],
	            id3 = triangles[i+2];
	
	        // Add to triangles
	        this.triangles.push([id1,id2,id3]);
	    }
	};
	
	var updateCenterOfMass_centroid = vec2.create(),
	    updateCenterOfMass_centroid_times_mass = vec2.create(),
	    updateCenterOfMass_a = vec2.create(),
	    updateCenterOfMass_b = vec2.create(),
	    updateCenterOfMass_c = vec2.create(),
	    updateCenterOfMass_ac = vec2.create(),
	    updateCenterOfMass_ca = vec2.create(),
	    updateCenterOfMass_cb = vec2.create(),
	    updateCenterOfMass_n = vec2.create();
	
	/**
	 * Update the .centerOfMass property.
	 * @method updateCenterOfMass
	 */
	Convex.prototype.updateCenterOfMass = function(){
	    var triangles = this.triangles,
	        verts = this.vertices,
	        cm = this.centerOfMass,
	        centroid = updateCenterOfMass_centroid,
	        n = updateCenterOfMass_n,
	        a = updateCenterOfMass_a,
	        b = updateCenterOfMass_b,
	        c = updateCenterOfMass_c,
	        ac = updateCenterOfMass_ac,
	        ca = updateCenterOfMass_ca,
	        cb = updateCenterOfMass_cb,
	        centroid_times_mass = updateCenterOfMass_centroid_times_mass;
	
	    vec2.set(cm,0,0);
	    var totalArea = 0;
	
	    for(var i=0; i!==triangles.length; i++){
	        var t = triangles[i],
	            a = verts[t[0]],
	            b = verts[t[1]],
	            c = verts[t[2]];
	
	        vec2.centroid(centroid,a,b,c);
	
	        // Get mass for the triangle (density=1 in this case)
	        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
	        var m = Convex.triangleArea(a,b,c);
	        totalArea += m;
	
	        // Add to center of mass
	        vec2.scale(centroid_times_mass, centroid, m);
	        vec2.add(cm, cm, centroid_times_mass);
	    }
	
	    vec2.scale(cm,cm,1/totalArea);
	};
	
	/**
	 * Compute the mass moment of inertia of the Convex.
	 * @method computeMomentOfInertia
	 * @param  {Number} mass
	 * @return {Number}
	 * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
	 */
	Convex.prototype.computeMomentOfInertia = function(mass){
	    var denom = 0.0,
	        numer = 0.0,
	        N = this.vertices.length;
	    for(var j = N-1, i = 0; i < N; j = i, i ++){
	        var p0 = this.vertices[j];
	        var p1 = this.vertices[i];
	        var a = Math.abs(vec2.crossLength(p0,p1));
	        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);
	        denom += a * b;
	        numer += a;
	    }
	    return (mass / 6.0) * (denom / numer);
	};
	
	/**
	 * Updates the .boundingRadius property
	 * @method updateBoundingRadius
	 */
	Convex.prototype.updateBoundingRadius = function(){
	    var verts = this.vertices,
	        r2 = 0;
	
	    for(var i=0; i!==verts.length; i++){
	        var l2 = vec2.squaredLength(verts[i]);
	        if(l2 > r2){
	            r2 = l2;
	        }
	    }
	
	    this.boundingRadius = Math.sqrt(r2);
	};
	
	/**
	 * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
	 * @static
	 * @method triangleArea
	 * @param {Array} a
	 * @param {Array} b
	 * @param {Array} c
	 * @return {Number}
	 */
	Convex.triangleArea = function(a,b,c){
	    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;
	};
	
	/**
	 * Update the .area
	 * @method updateArea
	 */
	Convex.prototype.updateArea = function(){
	    this.updateTriangles();
	    this.area = 0;
	
	    var triangles = this.triangles,
	        verts = this.vertices;
	    for(var i=0; i!==triangles.length; i++){
	        var t = triangles[i],
	            a = verts[t[0]],
	            b = verts[t[1]],
	            c = verts[t[2]];
	
	        // Get mass for the triangle (density=1 in this case)
	        var m = Convex.triangleArea(a,b,c);
	        this.area += m;
	    }
	};
	
	/**
	 * @method computeAABB
	 * @param  {AABB}   out
	 * @param  {Array}  position
	 * @param  {Number} angle
	 */
	Convex.prototype.computeAABB = function(out, position, angle){
	    out.setFromPoints(this.vertices, position, angle, 0);
	};
	
	var intersectConvex_rayStart = vec2.create();
	var intersectConvex_rayEnd = vec2.create();
	var intersectConvex_normal = vec2.create();
	
	/**
	 * @method raycast
	 * @param  {RaycastResult} result
	 * @param  {Ray} ray
	 * @param  {array} position
	 * @param  {number} angle
	 */
	Convex.prototype.raycast = function(result, ray, position, angle){
	    var rayStart = intersectConvex_rayStart;
	    var rayEnd = intersectConvex_rayEnd;
	    var normal = intersectConvex_normal;
	    var vertices = this.vertices;
	
	    // Transform to local shape space
	    vec2.toLocalFrame(rayStart, ray.from, position, angle);
	    vec2.toLocalFrame(rayEnd, ray.to, position, angle);
	
	    var n = vertices.length;
	
	    for (var i = 0; i < n && !result.shouldStop(ray); i++) {
	        var q1 = vertices[i];
	        var q2 = vertices[(i+1) % n];
	        var delta = vec2.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);
	
	        if(delta >= 0){
	            vec2.sub(normal, q2, q1);
	            vec2.rotate(normal, normal, -Math.PI / 2 + angle);
	            vec2.normalize(normal, normal);
	            ray.reportIntersection(result, delta, normal, i);
	        }
	    }
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Shape;
	
	var vec2 = __webpack_require__(4);
	
	/**
	 * Base class for shapes.
	 * @class Shape
	 * @constructor
	 * @param {object} [options]
	 * @param {array} [options.position]
	 * @param {number} [options.angle=0]
	 * @param {number} [options.collisionGroup=1]
	 * @param {number} [options.collisionMask=1]
	 * @param {boolean} [options.sensor=false]
	 * @param {boolean} [options.collisionResponse=true]
	 * @param {object} [options.type=0]
	 */
	function Shape(options){
	    options = options || {};
	
	    /**
	     * The body this shape is attached to. A shape can only be attached to a single body.
	     * @property {Body} body
	     */
	    this.body = null;
	
	    /**
	     * Body-local position of the shape.
	     * @property {Array} position
	     */
	    this.position = vec2.fromValues(0,0);
	    if(options.position){
	        vec2.copy(this.position, options.position);
	    }
	
	    /**
	     * Body-local angle of the shape.
	     * @property {number} angle
	     */
	    this.angle = options.angle || 0;
	
	    /**
	     * The type of the shape. One of:
	     *
	     * * {{#crossLink "Shape/CIRCLE:property"}}Shape.CIRCLE{{/crossLink}}
	     * * {{#crossLink "Shape/PARTICLE:property"}}Shape.PARTICLE{{/crossLink}}
	     * * {{#crossLink "Shape/PLANE:property"}}Shape.PLANE{{/crossLink}}
	     * * {{#crossLink "Shape/CONVEX:property"}}Shape.CONVEX{{/crossLink}}
	     * * {{#crossLink "Shape/LINE:property"}}Shape.LINE{{/crossLink}}
	     * * {{#crossLink "Shape/BOX:property"}}Shape.BOX{{/crossLink}}
	     * * {{#crossLink "Shape/CAPSULE:property"}}Shape.CAPSULE{{/crossLink}}
	     * * {{#crossLink "Shape/HEIGHTFIELD:property"}}Shape.HEIGHTFIELD{{/crossLink}}
	     *
	     * @property {number} type
	     */
	    this.type = options.type || 0;
	
	    /**
	     * Shape object identifier.
	     * @type {Number}
	     * @property id
	     */
	    this.id = Shape.idCounter++;
	
	    /**
	     * Bounding circle radius of this shape
	     * @property boundingRadius
	     * @type {Number}
	     */
	    this.boundingRadius = 0;
	
	    /**
	     * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
	     * @property collisionGroup
	     * @type {Number}
	     * @example
	     *     // Setup bits for each available group
	     *     var PLAYER = Math.pow(2,0),
	     *         ENEMY =  Math.pow(2,1),
	     *         GROUND = Math.pow(2,2)
	     *
	     *     // Put shapes into their groups
	     *     player1Shape.collisionGroup = PLAYER;
	     *     player2Shape.collisionGroup = PLAYER;
	     *     enemyShape  .collisionGroup = ENEMY;
	     *     groundShape .collisionGroup = GROUND;
	     *
	     *     // Assign groups that each shape collide with.
	     *     // Note that the players can collide with ground and enemies, but not with other players.
	     *     player1Shape.collisionMask = ENEMY | GROUND;
	     *     player2Shape.collisionMask = ENEMY | GROUND;
	     *     enemyShape  .collisionMask = PLAYER | GROUND;
	     *     groundShape .collisionMask = PLAYER | ENEMY;
	     *
	     * @example
	     *     // How collision check is done
	     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
	     *         // The shapes will collide
	     *     }
	     */
	    this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : 1;
	
	    /**
	     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.
	     * @property {Boolean} collisionResponse
	     */
	    this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;
	
	    /**
	     * Collision mask of this shape. See .collisionGroup.
	     * @property collisionMask
	     * @type {Number}
	     */
	    this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : 1;
	
	    /**
	     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.
	     * @property material
	     * @type {Material}
	     */
	    this.material = options.material || null;
	
	    /**
	     * Area of this shape.
	     * @property area
	     * @type {Number}
	     */
	    this.area = 0;
	
	    /**
	     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.
	     * @property {Boolean} sensor
	     */
	    this.sensor = options.sensor !== undefined ? options.sensor : false;
	
	    if(this.type){
	        this.updateBoundingRadius();
	    }
	
	    this.updateArea();
	}
	
	Shape.idCounter = 0;
	
	/**
	 * @static
	 * @property {Number} CIRCLE
	 */
	Shape.CIRCLE =      1;
	
	/**
	 * @static
	 * @property {Number} PARTICLE
	 */
	Shape.PARTICLE =    2;
	
	/**
	 * @static
	 * @property {Number} PLANE
	 */
	Shape.PLANE =       4;
	
	/**
	 * @static
	 * @property {Number} CONVEX
	 */
	Shape.CONVEX =      8;
	
	/**
	 * @static
	 * @property {Number} LINE
	 */
	Shape.LINE =        16;
	
	/**
	 * @static
	 * @property {Number} BOX
	 */
	Shape.BOX =   32;
	
	Object.defineProperty(Shape, 'RECTANGLE', {
	    get: function() {
	        console.warn('Shape.RECTANGLE is deprecated, use Shape.BOX instead.');
	        return Shape.BOX;
	    }
	});
	
	/**
	 * @static
	 * @property {Number} CAPSULE
	 */
	Shape.CAPSULE =     64;
	
	/**
	 * @static
	 * @property {Number} HEIGHTFIELD
	 */
	Shape.HEIGHTFIELD = 128;
	
	/**
	 * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href="http://en.wikipedia.org/wiki/List_of_moments_of_inertia">Wikipedia's list of moments of inertia</a>.
	 * @method computeMomentOfInertia
	 * @param  {Number} mass
	 * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.
	 */
	Shape.prototype.computeMomentOfInertia = function(mass){};
	
	/**
	 * Returns the bounding circle radius of this shape.
	 * @method updateBoundingRadius
	 * @return {Number}
	 */
	Shape.prototype.updateBoundingRadius = function(){};
	
	/**
	 * Update the .area property of the shape.
	 * @method updateArea
	 */
	Shape.prototype.updateArea = function(){
	    // To be implemented in all subclasses
	};
	
	/**
	 * Compute the world axis-aligned bounding box (AABB) of this shape.
	 * @method computeAABB
	 * @param  {AABB} out The resulting AABB.
	 * @param  {Array} position World position of the shape.
	 * @param  {Number} angle World angle of the shape.
	 */
	Shape.prototype.computeAABB = function(out, position, angle){
	    // To be implemented in each subclass
	};
	
	/**
	 * Perform raycasting on this shape.
	 * @method raycast
	 * @param  {RayResult} result Where to store the resulting data.
	 * @param  {Ray} ray The Ray that you want to use for raycasting.
	 * @param  {array} position World position of the shape (the .position property will be ignored).
	 * @param  {number} angle World angle of the shape (the .angle property will be ignored).
	 */
	Shape.prototype.raycast = function(result, ray, position, angle){
	    // To be implemented in each subclass
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	
	    /*
	        PolyK library
	        url: http://polyk.ivank.net
	        Released under MIT licence.
	
	        Copyright (c) 2012 Ivan Kuckir
	
	        Permission is hereby granted, free of charge, to any person
	        obtaining a copy of this software and associated documentation
	        files (the "Software"), to deal in the Software without
	        restriction, including without limitation the rights to use,
	        copy, modify, merge, publish, distribute, sublicense, and/or sell
	        copies of the Software, and to permit persons to whom the
	        Software is furnished to do so, subject to the following
	        conditions:
	
	        The above copyright notice and this permission notice shall be
	        included in all copies or substantial portions of the Software.
	
	        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	        OTHER DEALINGS IN THE SOFTWARE.
	    */
	
	    var PolyK = {};
	
	    /*
	        Is Polygon self-intersecting?
	
	        O(n^2)
	    */
	    /*
	    PolyK.IsSimple = function(p)
	    {
	        var n = p.length>>1;
	        if(n<4) return true;
	        var a1 = new PolyK._P(), a2 = new PolyK._P();
	        var b1 = new PolyK._P(), b2 = new PolyK._P();
	        var c = new PolyK._P();
	
	        for(var i=0; i<n; i++)
	        {
	            a1.x = p[2*i  ];
	            a1.y = p[2*i+1];
	            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
	            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }
	
	            for(var j=0; j<n; j++)
	            {
	                if(Math.abs(i-j) < 2) continue;
	                if(j==n-1 && i==0) continue;
	                if(i==n-1 && j==0) continue;
	
	                b1.x = p[2*j  ];
	                b1.y = p[2*j+1];
	                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
	                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }
	
	                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
	            }
	        }
	        return true;
	    }
	
	    PolyK.IsConvex = function(p)
	    {
	        if(p.length<6) return true;
	        var l = p.length - 4;
	        for(var i=0; i<l; i+=2)
	            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
	        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
	        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
	        return true;
	    }
	    */
	    PolyK.GetArea = function(p)
	    {
	        if(p.length <6) return 0;
	        var l = p.length - 2;
	        var sum = 0;
	        for(var i=0; i<l; i+=2)
	            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);
	        sum += (p[0]-p[l]) * (p[l+1]+p[1]);
	        return - sum * 0.5;
	    }
	    /*
	    PolyK.GetAABB = function(p)
	    {
	        var minx = Infinity;
	        var miny = Infinity;
	        var maxx = -minx;
	        var maxy = -miny;
	        for(var i=0; i<p.length; i+=2)
	        {
	            minx = Math.min(minx, p[i  ]);
	            maxx = Math.max(maxx, p[i  ]);
	            miny = Math.min(miny, p[i+1]);
	            maxy = Math.max(maxy, p[i+1]);
	        }
	        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
	    }
	    */
	
	    PolyK.Triangulate = function(p)
	    {
	        var n = p.length>>1;
	        if(n<3) return [];
	        var tgs = [];
	        var avl = [];
	        for(var i=0; i<n; i++) avl.push(i);
	
	        var i = 0;
	        var al = n;
	        while(al > 3)
	        {
	            var i0 = avl[(i+0)%al];
	            var i1 = avl[(i+1)%al];
	            var i2 = avl[(i+2)%al];
	
	            var ax = p[2*i0],  ay = p[2*i0+1];
	            var bx = p[2*i1],  by = p[2*i1+1];
	            var cx = p[2*i2],  cy = p[2*i2+1];
	
	            var earFound = false;
	            if(PolyK._convex(ax, ay, bx, by, cx, cy))
	            {
	                earFound = true;
	                for(var j=0; j<al; j++)
	                {
	                    var vi = avl[j];
	                    if(vi==i0 || vi==i1 || vi==i2) continue;
	                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}
	                }
	            }
	            if(earFound)
	            {
	                tgs.push(i0, i1, i2);
	                avl.splice((i+1)%al, 1);
	                al--;
	                i= 0;
	            }
	            else if(i++ > 3*al) break;      // no convex angles :(
	        }
	        tgs.push(avl[0], avl[1], avl[2]);
	        return tgs;
	    }
	    /*
	    PolyK.ContainsPoint = function(p, px, py)
	    {
	        var n = p.length>>1;
	        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
	        var depth = 0;
	        for(var i=0; i<n; i++)
	        {
	            ax = bx;  ay = by;
	            bx = p[2*i  ] - px;
	            by = p[2*i+1] - py;
	            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
	            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
	            if(ax< 0 && bx< 0) continue;
	
	            var lx = ax + (bx-ax)*(-ay)/(by-ay);
	            if(lx>0) depth++;
	        }
	        return (depth & 1) == 1;
	    }
	
	    PolyK.Slice = function(p, ax, ay, bx, by)
	    {
	        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];
	
	        var a = new PolyK._P(ax, ay);
	        var b = new PolyK._P(bx, by);
	        var iscs = [];  // intersections
	        var ps = [];    // points
	        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));
	
	        for(var i=0; i<ps.length; i++)
	        {
	            var isc = new PolyK._P(0,0);
	            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);
	
	            if(isc)
	            {
	                isc.flag = true;
	                iscs.push(isc);
	                ps.splice(i+1,0,isc);
	                i++;
	            }
	        }
	        if(iscs.length == 0) return [p.slice(0)];
	        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }
	        iscs.sort(comp);
	
	        var pgs = [];
	        var dir = 0;
	        while(iscs.length > 0)
	        {
	            var n = ps.length;
	            var i0 = iscs[0];
	            var i1 = iscs[1];
	            var ind0 = ps.indexOf(i0);
	            var ind1 = ps.indexOf(i1);
	            var solved = false;
	
	            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
	            else
	            {
	                i0 = iscs[1];
	                i1 = iscs[0];
	                ind0 = ps.indexOf(i0);
	                ind1 = ps.indexOf(i1);
	                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
	            }
	            if(solved)
	            {
	                dir--;
	                var pgn = PolyK._getPoints(ps, ind0, ind1);
	                pgs.push(pgn);
	                ps = PolyK._getPoints(ps, ind1, ind0);
	                i0.flag = i1.flag = false;
	                iscs.splice(0,2);
	                if(iscs.length == 0) pgs.push(ps);
	            }
	            else { dir++; iscs.reverse(); }
	            if(dir>1) break;
	        }
	        var result = [];
	        for(var i=0; i<pgs.length; i++)
	        {
	            var pg = pgs[i];
	            var npg = [];
	            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
	            result.push(npg);
	        }
	        return result;
	    }
	
	    PolyK.Raycast = function(p, x, y, dx, dy, isc)
	    {
	        var l = p.length - 2;
	        var tp = PolyK._tp;
	        var a1 = tp[0], a2 = tp[1],
	        b1 = tp[2], b2 = tp[3], c = tp[4];
	        a1.x = x; a1.y = y;
	        a2.x = x+dx; a2.y = y+dy;
	
	        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
	        isc.dist = Infinity;
	
	        for(var i=0; i<l; i+=2)
	        {
	            b1.x = p[i  ];  b1.y = p[i+1];
	            b2.x = p[i+2];  b2.y = p[i+3];
	            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
	            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
	        }
	        b1.x = b2.x;  b1.y = b2.y;
	        b2.x = p[0];  b2.y = p[1];
	        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
	        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);
	
	        return (isc.dist != Infinity) ? isc : null;
	    }
	
	    PolyK.ClosestEdge = function(p, x, y, isc)
	    {
	        var l = p.length - 2;
	        var tp = PolyK._tp;
	        var a1 = tp[0],
	        b1 = tp[2], b2 = tp[3], c = tp[4];
	        a1.x = x; a1.y = y;
	
	        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
	        isc.dist = Infinity;
	
	        for(var i=0; i<l; i+=2)
	        {
	            b1.x = p[i  ];  b1.y = p[i+1];
	            b2.x = p[i+2];  b2.y = p[i+3];
	            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);
	        }
	        b1.x = b2.x;  b1.y = b2.y;
	        b2.x = p[0];  b2.y = p[1];
	        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);
	
	        var idst = 1/isc.dist;
	        isc.norm.x = (x-isc.point.x)*idst;
	        isc.norm.y = (y-isc.point.y)*idst;
	        return isc;
	    }
	
	    PolyK._pointLineDist = function(p, a, b, edge, isc)
	    {
	        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;
	
	        var A = x - x1;
	        var B = y - y1;
	        var C = x2 - x1;
	        var D = y2 - y1;
	
	        var dot = A * C + B * D;
	        var len_sq = C * C + D * D;
	        var param = dot / len_sq;
	
	        var xx, yy;
	
	        if (param < 0 || (x1 == x2 && y1 == y2)) {
	            xx = x1;
	            yy = y1;
	        }
	        else if (param > 1) {
	            xx = x2;
	            yy = y2;
	        }
	        else {
	            xx = x1 + param * C;
	            yy = y1 + param * D;
	        }
	
	        var dx = x - xx;
	        var dy = y - yy;
	        var dst = Math.sqrt(dx * dx + dy * dy);
	        if(dst<isc.dist)
	        {
	            isc.dist = dst;
	            isc.edge = edge;
	            isc.point.x = xx;
	            isc.point.y = yy;
	        }
	    }
	
	    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)
	    {
	        var nrl = PolyK._P.dist(a1, c);
	        if(nrl<isc.dist)
	        {
	            var ibl = 1/PolyK._P.dist(b1, b2);
	            var nx = -(b2.y-b1.y)*ibl;
	            var ny =  (b2.x-b1.x)*ibl;
	            var ddot = 2*(dx*nx+dy*ny);
	            isc.dist = nrl;
	            isc.norm.x = nx;
	            isc.norm.y = ny;
	            isc.refl.x = -ddot*nx+dx;
	            isc.refl.y = -ddot*ny+dy;
	            isc.edge = edge;
	        }
	    }
	
	    PolyK._getPoints = function(ps, ind0, ind1)
	    {
	        var n = ps.length;
	        var nps = [];
	        if(ind1<ind0) ind1 += n;
	        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
	        return nps;
	    }
	
	    PolyK._firstWithFlag = function(ps, ind)
	    {
	        var n = ps.length;
	        while(true)
	        {
	            ind = (ind+1)%n;
	            if(ps[ind].flag) return ind;
	        }
	    }
	    */
	    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
	    {
	        var v0x = cx-ax;
	        var v0y = cy-ay;
	        var v1x = bx-ax;
	        var v1y = by-ay;
	        var v2x = px-ax;
	        var v2y = py-ay;
	
	        var dot00 = v0x*v0x+v0y*v0y;
	        var dot01 = v0x*v1x+v0y*v1y;
	        var dot02 = v0x*v2x+v0y*v2y;
	        var dot11 = v1x*v1x+v1y*v1y;
	        var dot12 = v1x*v2x+v1y*v2y;
	
	        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
	        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
	        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
	
	        // Check if point is in triangle
	        return (u >= 0) && (v >= 0) && (u + v < 1);
	    }
	    /*
	    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)
	    {
	        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
	        var day = (a1.y-a2.y), dby = (b1.y-b2.y);
	
	        var Den = dax*dby - day*dbx;
	        if (Den == 0) return null;  // parallel
	
	        var A = (a1.x * a2.y - a1.y * a2.x);
	        var B = (b1.x * b2.y - b1.y * b2.x);
	
	        var I = c;
	        var iDen = 1/Den;
	        I.x = ( A*dbx - dax*B ) * iDen;
	        I.y = ( A*dby - day*B ) * iDen;
	
	        if(!PolyK._InRect(I, b1, b2)) return null;
	        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
	        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
	        return I;
	    }
	
	    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)
	    {
	        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
	        var day = (a1.y-a2.y), dby = (b1.y-b2.y);
	
	        var Den = dax*dby - day*dbx;
	        if (Den == 0) return null;  // parallel
	
	        var A = (a1.x * a2.y - a1.y * a2.x);
	        var B = (b1.x * b2.y - b1.y * b2.x);
	
	        var I = c;
	        I.x = ( A*dbx - dax*B ) / Den;
	        I.y = ( A*dby - day*B ) / Den;
	
	        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;
	        return null;
	    }
	
	    PolyK._InRect = function(a, b, c)
	    {
	        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
	        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));
	
	        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
	        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
	        return true;
	        return false;
	    }
	    */
	    PolyK._convex = function(ax, ay, bx, by, cx, cy)
	    {
	        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;
	    }
	    /*
	    PolyK._P = function(x,y)
	    {
	        this.x = x;
	        this.y = y;
	        this.flag = false;
	    }
	    PolyK._P.prototype.toString = function()
	    {
	        return "Point ["+this.x+", "+this.y+"]";
	    }
	    PolyK._P.dist = function(a,b)
	    {
	        var dx = b.x-a.x;
	        var dy = b.y-a.y;
	        return Math.sqrt(dx*dx + dy*dy);
	    }
	
	    PolyK._tp = [];
	    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));
	        */
	
	module.exports = PolyK;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4);
	var Ray = __webpack_require__(19);
	
	module.exports = RaycastResult;
	
	/**
	 * Storage for Ray casting hit data.
	 * @class RaycastResult
	 * @constructor
	 */
	function RaycastResult(){
	
		/**
		 * The normal of the hit, oriented in world space.
		 * @property {array} normal
		 */
		this.normal = vec2.create();
	
		/**
		 * The hit shape, or null.
		 * @property {Shape} shape
		 */
		this.shape = null;
	
		/**
		 * The hit body, or null.
		 * @property {Body} body
		 */
		this.body = null;
	
		/**
		 * The index of the hit triangle, if the hit shape was indexable.
		 * @property {number} faceIndex
		 * @default -1
		 */
		this.faceIndex = -1;
	
		/**
		 * Distance to the hit, as a fraction. 0 is at the "from" point, 1 is at the "to" point. Will be set to -1 if there was no hit yet.
		 * @property {number} fraction
		 * @default -1
		 */
		this.fraction = -1;
	
		/**
		 * If the ray should stop traversing.
		 * @readonly
		 * @property {Boolean} isStopped
		 */
		this.isStopped = false;
	}
	
	/**
	 * Reset all result data. Must be done before re-using the result object.
	 * @method reset
	 */
	RaycastResult.prototype.reset = function () {
		vec2.set(this.normal, 0, 0);
		this.shape = null;
		this.body = null;
		this.faceIndex = -1;
		this.fraction = -1;
		this.isStopped = false;
	};
	
	/**
	 * Get the distance to the hit point.
	 * @method getHitDistance
	 * @param {Ray} ray
	 */
	RaycastResult.prototype.getHitDistance = function (ray) {
		return vec2.distance(ray.from, ray.to) * this.fraction;
	};
	
	/**
	 * Returns true if the ray hit something since the last reset().
	 * @method hasHit
	 */
	RaycastResult.prototype.hasHit = function () {
		return this.fraction !== -1;
	};
	
	/**
	 * Get world hit point.
	 * @method getHitPoint
	 * @param {array} out
	 * @param {Ray} ray
	 */
	RaycastResult.prototype.getHitPoint = function (out, ray) {
		vec2.lerp(out, ray.from, ray.to, this.fraction);
	};
	
	/**
	 * Can be called while iterating over hits to stop searching for hit points.
	 * @method stop
	 */
	RaycastResult.prototype.stop = function(){
		this.isStopped = true;
	};
	
	/**
	 * @method shouldStop
	 * @private
	 * @param {Ray} ray
	 * @return {boolean}
	 */
	RaycastResult.prototype.shouldStop = function(ray){
		return this.isStopped || (this.fraction !== -1 && ray.mode === Ray.ANY);
	};
	
	/**
	 * @method set
	 * @private
	 * @param {array} normal
	 * @param {Shape} shape
	 * @param {Body} body
	 * @param {number} fraction
	 */
	RaycastResult.prototype.set = function(
		normal,
		shape,
		body,
		fraction,
		faceIndex
	){
		vec2.copy(this.normal, normal);
		this.shape = shape;
		this.body = body;
		this.fraction = fraction;
		this.faceIndex = faceIndex;
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Ray;
	
	var vec2 = __webpack_require__(4);
	var RaycastResult = __webpack_require__(18);
	var Shape = __webpack_require__(16);
	var AABB = __webpack_require__(20);
	
	/**
	 * A line with a start and end point that is used to intersect shapes. For an example, see {{#crossLink "World/raycast:method"}}World.raycast{{/crossLink}}
	 * @class Ray
	 * @constructor
	 * @param {object} [options]
	 * @param {array} [options.from]
	 * @param {array} [options.to]
	 * @param {boolean} [options.checkCollisionResponse=true]
	 * @param {boolean} [options.skipBackfaces=false]
	 * @param {number} [options.collisionMask=-1]
	 * @param {number} [options.collisionGroup=-1]
	 * @param {number} [options.mode=Ray.ANY]
	 * @param {number} [options.callback]
	 */
	function Ray(options){
	    options = options || {};
	
	    /**
	     * Ray start point.
	     * @property {array} from
	     */
	    this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();
	
	    /**
	     * Ray end point
	     * @property {array} to
	     */
	    this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();
	
	    /**
	     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
	     * @property {Boolean} checkCollisionResponse
	     */
	    this.checkCollisionResponse = options.checkCollisionResponse !== undefined ? options.checkCollisionResponse : true;
	
	    /**
	     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
	     * @property {Boolean} skipBackfaces
	     */
	    this.skipBackfaces = !!options.skipBackfaces;
	
	    /**
	     * @property {number} collisionMask
	     * @default -1
	     */
	    this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : -1;
	
	    /**
	     * @property {number} collisionGroup
	     * @default -1
	     */
	    this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : -1;
	
	    /**
	     * The intersection mode. Should be {{#crossLink "Ray/ANY:property"}}Ray.ANY{{/crossLink}}, {{#crossLink "Ray/ALL:property"}}Ray.ALL{{/crossLink}} or {{#crossLink "Ray/CLOSEST:property"}}Ray.CLOSEST{{/crossLink}}.
	     * @property {number} mode
	     */
	    this.mode = options.mode !== undefined ? options.mode : Ray.ANY;
	
	    /**
	     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
	     * @property {Function} callback
	     */
	    this.callback = options.callback || function(result){};
	
	    /**
	     * @readOnly
	     * @property {array} direction
	     */
	    this.direction = vec2.create();
	
	    /**
	     * Length of the ray
	     * @readOnly
	     * @property {number} length
	     */
	    this.length = 1;
	
	    this.update();
	}
	Ray.prototype.constructor = Ray;
	
	/**
	 * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.
	 * @static
	 * @property {Number} CLOSEST
	 */
	Ray.CLOSEST = 1;
	
	/**
	 * This raycasting mode will make the Ray stop when it finds the first intersection point.
	 * @static
	 * @property {Number} ANY
	 */
	Ray.ANY = 2;
	
	/**
	 * This raycasting mode will traverse all intersection points and executes a callback for each one.
	 * @static
	 * @property {Number} ALL
	 */
	Ray.ALL = 4;
	
	/**
	 * Should be called if you change the from or to point.
	 * @method update
	 */
	Ray.prototype.update = function(){
	
	    // Update .direction and .length
	    var d = this.direction;
	    vec2.sub(d, this.to, this.from);
	    this.length = vec2.length(d);
	    vec2.normalize(d, d);
	
	};
	
	/**
	 * @method intersectBodies
	 * @param {Array} bodies An array of Body objects.
	 */
	Ray.prototype.intersectBodies = function (result, bodies) {
	    for (var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {
	        var body = bodies[i];
	        var aabb = body.getAABB();
	        if(aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)){
	            this.intersectBody(result, body);
	        }
	    }
	};
	
	var intersectBody_worldPosition = vec2.create();
	
	/**
	 * Shoot a ray at a body, get back information about the hit.
	 * @method intersectBody
	 * @private
	 * @param {Body} body
	 */
	Ray.prototype.intersectBody = function (result, body) {
	    var checkCollisionResponse = this.checkCollisionResponse;
	
	    if(checkCollisionResponse && !body.collisionResponse){
	        return;
	    }
	
	    var worldPosition = intersectBody_worldPosition;
	
	    for (var i = 0, N = body.shapes.length; i < N; i++) {
	        var shape = body.shapes[i];
	
	        if(checkCollisionResponse && !shape.collisionResponse){
	            continue; // Skip
	        }
	
	        if((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0){
	            continue;
	        }
	
	        // Get world angle and position of the shape
	        vec2.rotate(worldPosition, shape.position, body.angle);
	        vec2.add(worldPosition, worldPosition, body.position);
	        var worldAngle = shape.angle + body.angle;
	
	        this.intersectShape(
	            result,
	            shape,
	            worldAngle,
	            worldPosition,
	            body
	        );
	
	        if(result.shouldStop(this)){
	            break;
	        }
	    }
	};
	
	/**
	 * @method intersectShape
	 * @private
	 * @param {Shape} shape
	 * @param {number} angle
	 * @param {array} position
	 * @param {Body} body
	 */
	Ray.prototype.intersectShape = function(result, shape, angle, position, body){
	    var from = this.from;
	
	    // Checking radius
	    var distance = distanceFromIntersectionSquared(from, this.direction, position);
	    if (distance > shape.boundingRadius * shape.boundingRadius) {
	        return;
	    }
	
	    this._currentBody = body;
	    this._currentShape = shape;
	
	    shape.raycast(result, this, position, angle);
	
	    this._currentBody = this._currentShape = null;
	};
	
	/**
	 * Get the AABB of the ray.
	 * @method getAABB
	 * @param  {AABB} aabb
	 */
	Ray.prototype.getAABB = function(result){
	    var to = this.to;
	    var from = this.from;
	    vec2.set(
	        result.lowerBound,
	        Math.min(to[0], from[0]),
	        Math.min(to[1], from[1])
	    );
	    vec2.set(
	        result.upperBound,
	        Math.max(to[0], from[0]),
	        Math.max(to[1], from[1])
	    );
	};
	
	var hitPointWorld = vec2.create();
	
	/**
	 * @method reportIntersection
	 * @private
	 * @param  {number} fraction
	 * @param  {array} normal
	 * @param  {number} [faceIndex=-1]
	 * @return {boolean} True if the intersections should continue
	 */
	Ray.prototype.reportIntersection = function(result, fraction, normal, faceIndex){
	    var from = this.from;
	    var to = this.to;
	    var shape = this._currentShape;
	    var body = this._currentBody;
	
	    // Skip back faces?
	    if(this.skipBackfaces && vec2.dot(normal, this.direction) > 0){
	        return;
	    }
	
	    switch(this.mode){
	
	    case Ray.ALL:
	        result.set(
	            normal,
	            shape,
	            body,
	            fraction,
	            faceIndex
	        );
	        this.callback(result);
	        break;
	
	    case Ray.CLOSEST:
	
	        // Store if closer than current closest
	        if(fraction < result.fraction || !result.hasHit()){
	            result.set(
	                normal,
	                shape,
	                body,
	                fraction,
	                faceIndex
	            );
	        }
	        break;
	
	    case Ray.ANY:
	
	        // Report and stop.
	        result.set(
	            normal,
	            shape,
	            body,
	            fraction,
	            faceIndex
	        );
	        break;
	    }
	};
	
	var v0 = vec2.create(),
	    intersect = vec2.create();
	function distanceFromIntersectionSquared(from, direction, position) {
	
	    // v0 is vector from from to position
	    vec2.sub(v0, position, from);
	    var dot = vec2.dot(v0, direction);
	
	    // intersect = direction * dot + from
	    vec2.scale(intersect, direction, dot);
	    vec2.add(intersect, intersect, from);
	
	    return vec2.squaredDistance(position, intersect);
	}
	


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4)
	,   Utils = __webpack_require__(5);
	
	module.exports = AABB;
	
	/**
	 * Axis aligned bounding box class.
	 * @class AABB
	 * @constructor
	 * @param {Object}  [options]
	 * @param {Array}   [options.upperBound]
	 * @param {Array}   [options.lowerBound]
	 */
	function AABB(options){
	
	    /**
	     * The lower bound of the bounding box.
	     * @property lowerBound
	     * @type {Array}
	     */
	    this.lowerBound = vec2.create();
	    if(options && options.lowerBound){
	        vec2.copy(this.lowerBound, options.lowerBound);
	    }
	
	    /**
	     * The upper bound of the bounding box.
	     * @property upperBound
	     * @type {Array}
	     */
	    this.upperBound = vec2.create();
	    if(options && options.upperBound){
	        vec2.copy(this.upperBound, options.upperBound);
	    }
	}
	
	var tmp = vec2.create();
	
	/**
	 * Set the AABB bounds from a set of points, transformed by the given position and angle.
	 * @method setFromPoints
	 * @param {Array} points An array of vec2's.
	 * @param {Array} position
	 * @param {number} angle
	 * @param {number} skinSize Some margin to be added to the AABB.
	 */
	AABB.prototype.setFromPoints = function(points, position, angle, skinSize){
	    var l = this.lowerBound,
	        u = this.upperBound;
	
	    if(typeof(angle) !== "number"){
	        angle = 0;
	    }
	
	    // Set to the first point
	    if(angle !== 0){
	        vec2.rotate(l, points[0], angle);
	    } else {
	        vec2.copy(l, points[0]);
	    }
	    vec2.copy(u, l);
	
	    // Compute cosines and sines just once
	    var cosAngle = Math.cos(angle),
	        sinAngle = Math.sin(angle);
	    for(var i = 1; i<points.length; i++){
	        var p = points[i];
	
	        if(angle !== 0){
	            var x = p[0],
	                y = p[1];
	            tmp[0] = cosAngle * x -sinAngle * y;
	            tmp[1] = sinAngle * x +cosAngle * y;
	            p = tmp;
	        }
	
	        for(var j=0; j<2; j++){
	            if(p[j] > u[j]){
	                u[j] = p[j];
	            }
	            if(p[j] < l[j]){
	                l[j] = p[j];
	            }
	        }
	    }
	
	    // Add offset
	    if(position){
	        vec2.add(this.lowerBound, this.lowerBound, position);
	        vec2.add(this.upperBound, this.upperBound, position);
	    }
	
	    if(skinSize){
	        this.lowerBound[0] -= skinSize;
	        this.lowerBound[1] -= skinSize;
	        this.upperBound[0] += skinSize;
	        this.upperBound[1] += skinSize;
	    }
	};
	
	/**
	 * Copy bounds from an AABB to this AABB
	 * @method copy
	 * @param  {AABB} aabb
	 */
	AABB.prototype.copy = function(aabb){
	    vec2.copy(this.lowerBound, aabb.lowerBound);
	    vec2.copy(this.upperBound, aabb.upperBound);
	};
	
	/**
	 * Extend this AABB so that it covers the given AABB too.
	 * @method extend
	 * @param  {AABB} aabb
	 */
	AABB.prototype.extend = function(aabb){
	    // Loop over x and y
	    var i = 2;
	    while(i--){
	        // Extend lower bound
	        var l = aabb.lowerBound[i];
	        if(this.lowerBound[i] > l){
	            this.lowerBound[i] = l;
	        }
	
	        // Upper
	        var u = aabb.upperBound[i];
	        if(this.upperBound[i] < u){
	            this.upperBound[i] = u;
	        }
	    }
	};
	
	/**
	 * Returns true if the given AABB overlaps this AABB.
	 * @method overlaps
	 * @param  {AABB} aabb
	 * @return {Boolean}
	 */
	AABB.prototype.overlaps = function(aabb){
	    var l1 = this.lowerBound,
	        u1 = this.upperBound,
	        l2 = aabb.lowerBound,
	        u2 = aabb.upperBound;
	
	    //      l2        u2
	    //      |---------|
	    // |--------|
	    // l1       u1
	
	    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
	           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
	};
	
	/**
	 * @method containsPoint
	 * @param  {Array} point
	 * @return {boolean}
	 */
	AABB.prototype.containsPoint = function(point){
	    var l = this.lowerBound,
	        u = this.upperBound;
	    return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];
	};
	
	/**
	 * Check if the AABB is hit by a ray.
	 * @method overlapsRay
	 * @param  {Ray} ray
	 * @return {number} -1 if no hit, a number between 0 and 1 if hit.
	 */
	AABB.prototype.overlapsRay = function(ray){
	    var t = 0;
	
	    // ray.direction is unit direction vector of ray
	    var dirFracX = 1 / ray.direction[0];
	    var dirFracY = 1 / ray.direction[1];
	
	    // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
	    var t1 = (this.lowerBound[0] - ray.from[0]) * dirFracX;
	    var t2 = (this.upperBound[0] - ray.from[0]) * dirFracX;
	    var t3 = (this.lowerBound[1] - ray.from[1]) * dirFracY;
	    var t4 = (this.upperBound[1] - ray.from[1]) * dirFracY;
	
	    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
	    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));
	
	    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
	    if (tmax < 0){
	        //t = tmax;
	        return -1;
	    }
	
	    // if tmin > tmax, ray doesn't intersect AABB
	    if (tmin > tmax){
	        //t = tmax;
	        return -1;
	    }
	
	    return tmin;
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	/**
	 * Base class for objects that dispatches events.
	 * @class EventEmitter
	 * @constructor
	 */
	var EventEmitter = function () {};
	
	module.exports = EventEmitter;
	
	EventEmitter.prototype = {
	    constructor: EventEmitter,
	
	    /**
	     * Add an event listener
	     * @method on
	     * @param  {String} type
	     * @param  {Function} listener
	     * @return {EventEmitter} The self object, for chainability.
	     */
	    on: function ( type, listener, context ) {
	        listener.context = context || this;
	        if ( this._listeners === undefined ){
	            this._listeners = {};
	        }
	        var listeners = this._listeners;
	        if ( listeners[ type ] === undefined ) {
	            listeners[ type ] = [];
	        }
	        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	            listeners[ type ].push( listener );
	        }
	        return this;
	    },
	
	    /**
	     * Check if an event listener is added
	     * @method has
	     * @param  {String} type
	     * @param  {Function} listener
	     * @return {Boolean}
	     */
	    has: function ( type, listener ) {
	        if ( this._listeners === undefined ){
	            return false;
	        }
	        var listeners = this._listeners;
	        if(listener){
	            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	                return true;
	            }
	        } else {
	            if ( listeners[ type ] !== undefined ) {
	                return true;
	            }
	        }
	
	        return false;
	    },
	
	    /**
	     * Remove an event listener
	     * @method off
	     * @param  {String} type
	     * @param  {Function} listener
	     * @return {EventEmitter} The self object, for chainability.
	     */
	    off: function ( type, listener ) {
	        if ( this._listeners === undefined ){
	            return this;
	        }
	        var listeners = this._listeners;
	        var index = listeners[ type ].indexOf( listener );
	        if ( index !== - 1 ) {
	            listeners[ type ].splice( index, 1 );
	        }
	        return this;
	    },
	
	    /**
	     * Emit an event.
	     * @method emit
	     * @param  {Object} event
	     * @param  {String} event.type
	     * @return {EventEmitter} The self object, for chainability.
	     */
	    emit: function ( event ) {
	        if ( this._listeners === undefined ){
	            return this;
	        }
	        var listeners = this._listeners;
	        var listenerArray = listeners[ event.type ];
	        if ( listenerArray !== undefined ) {
	            event.target = this;
	            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
	                var listener = listenerArray[ i ];
	                listener.call( listener.context, event );
	            }
	        }
	        return this;
	    }
	};


/***/ },
/* 22 */
/***/ function(module, exports) {

	module.exports = Pool;
	
	/**
	 * @class Object pooling utility.
	 */
	function Pool(options) {
		options = options || {};
	
		/**
		 * @property {Array} objects
		 * @type {Array}
		 */
		this.objects = [];
	
		if(options.size !== undefined){
			this.resize(options.size);
		}
	}
	
	/**
	 * @method resize
	 * @param {number} size
	 * @return {Pool} Self, for chaining
	 */
	Pool.prototype.resize = function (size) {
		var objects = this.objects;
	
		while (objects.length > size) {
			objects.pop();
		}
	
		while (objects.length < size) {
			objects.push(this.create());
		}
	
		return this;
	};
	
	/**
	 * Get an object from the pool or create a new instance.
	 * @method get
	 * @return {Object}
	 */
	Pool.prototype.get = function () {
		var objects = this.objects;
		return objects.length ? objects.pop() : this.create();
	};
	
	/**
	 * Clean up and put the object back into the pool for later use.
	 * @method release
	 * @param {Object} object
	 * @return {Pool} Self for chaining
	 */
	Pool.prototype.release = function (object) {
		this.destroy(object);
		this.objects.push(object);
		return this;
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var FrictionEquation = __webpack_require__(24);
	var Pool = __webpack_require__(22);
	
	module.exports = FrictionEquationPool;
	
	/**
	 * @class
	 */
	function FrictionEquationPool() {
		Pool.apply(this, arguments);
	}
	FrictionEquationPool.prototype = new Pool();
	FrictionEquationPool.prototype.constructor = FrictionEquationPool;
	
	/**
	 * @method create
	 * @return {FrictionEquation}
	 */
	FrictionEquationPool.prototype.create = function () {
		return new FrictionEquation();
	};
	
	/**
	 * @method destroy
	 * @param {FrictionEquation} equation
	 * @return {FrictionEquationPool}
	 */
	FrictionEquationPool.prototype.destroy = function (equation) {
		equation.bodyA = equation.bodyB = null;
		return this;
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4)
	,   Equation = __webpack_require__(8)
	,   Utils = __webpack_require__(5);
	
	module.exports = FrictionEquation;
	
	/**
	 * Constrains the slipping in a contact along a tangent
	 *
	 * @class FrictionEquation
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Number} slipForce
	 * @extends Equation
	 */
	function FrictionEquation(bodyA, bodyB, slipForce){
	    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);
	
	    /**
	     * Relative vector from center of body A to the contact point, world oriented.
	     * @property contactPointA
	     * @type {Array}
	     */
	    this.contactPointA = vec2.create();
	
	    /**
	     * Relative vector from center of body B to the contact point, world oriented.
	     * @property contactPointB
	     * @type {Array}
	     */
	    this.contactPointB = vec2.create();
	
	    /**
	     * Tangent vector that the friction force will act along. World oriented.
	     * @property t
	     * @type {Array}
	     */
	    this.t = vec2.create();
	
	    /**
	     * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
	     * @property contactEquations
	     * @type {ContactEquation}
	     */
	    this.contactEquations = [];
	
	    /**
	     * The shape in body i that triggered this friction.
	     * @property shapeA
	     * @type {Shape}
	     * @todo Needed? The shape can be looked up via contactEquation.shapeA...
	     */
	    this.shapeA = null;
	
	    /**
	     * The shape in body j that triggered this friction.
	     * @property shapeB
	     * @type {Shape}
	     * @todo Needed? The shape can be looked up via contactEquation.shapeB...
	     */
	    this.shapeB = null;
	
	    /**
	     * The friction coefficient to use.
	     * @property frictionCoefficient
	     * @type {Number}
	     */
	    this.frictionCoefficient = 0.3;
	}
	FrictionEquation.prototype = new Equation();
	FrictionEquation.prototype.constructor = FrictionEquation;
	
	/**
	 * Set the slipping condition for the constraint. The friction force cannot be
	 * larger than this value.
	 * @method setSlipForce
	 * @param  {Number} slipForce
	 */
	FrictionEquation.prototype.setSlipForce = function(slipForce){
	    this.maxForce = slipForce;
	    this.minForce = -slipForce;
	};
	
	/**
	 * Get the max force for the constraint.
	 * @method getSlipForce
	 * @return {Number}
	 */
	FrictionEquation.prototype.getSlipForce = function(){
	    return this.maxForce;
	};
	
	FrictionEquation.prototype.computeB = function(a,b,h){
	    var bi = this.bodyA,
	        bj = this.bodyB,
	        ri = this.contactPointA,
	        rj = this.contactPointB,
	        t = this.t,
	        G = this.G;
	
	    // G = [-t -rixt t rjxt]
	    // And remember, this is a pure velocity constraint, g is always zero!
	    G[0] = -t[0];
	    G[1] = -t[1];
	    G[2] = -vec2.crossLength(ri,t);
	    G[3] = t[0];
	    G[4] = t[1];
	    G[5] = vec2.crossLength(rj,t);
	
	    var GW = this.computeGW(),
	        GiMf = this.computeGiMf();
	
	    var B = /* - g * a  */ - GW * b - h*GiMf;
	
	    return B;
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var Utils = __webpack_require__(5);
	
	module.exports = TupleDictionary;
	
	/**
	 * @class TupleDictionary
	 * @constructor
	 */
	function TupleDictionary() {
	
	    /**
	     * The data storage
	     * @property data
	     * @type {Object}
	     */
	    this.data = {};
	
	    /**
	     * Keys that are currently used.
	     * @property {Array} keys
	     */
	    this.keys = [];
	}
	
	/**
	 * Generate a key given two integers
	 * @method getKey
	 * @param  {number} i
	 * @param  {number} j
	 * @return {string}
	 */
	TupleDictionary.prototype.getKey = function(id1, id2) {
	    id1 = id1|0;
	    id2 = id2|0;
	
	    if ( (id1|0) === (id2|0) ){
	        return -1;
	    }
	
	    // valid for values < 2^16
	    return ((id1|0) > (id2|0) ?
	        (id1 << 16) | (id2 & 0xFFFF) :
	        (id2 << 16) | (id1 & 0xFFFF))|0
	        ;
	};
	
	/**
	 * @method getByKey
	 * @param  {Number} key
	 * @return {Object}
	 */
	TupleDictionary.prototype.getByKey = function(key) {
	    key = key|0;
	    return this.data[key];
	};
	
	/**
	 * @method get
	 * @param  {Number} i
	 * @param  {Number} j
	 * @return {Number}
	 */
	TupleDictionary.prototype.get = function(i, j) {
	    return this.data[this.getKey(i, j)];
	};
	
	/**
	 * Set a value.
	 * @method set
	 * @param  {Number} i
	 * @param  {Number} j
	 * @param {Number} value
	 */
	TupleDictionary.prototype.set = function(i, j, value) {
	    if(!value){
	        throw new Error("No data!");
	    }
	
	    var key = this.getKey(i, j);
	
	    // Check if key already exists
	    if(!this.data[key]){
	        this.keys.push(key);
	    }
	
	    this.data[key] = value;
	
	    return key;
	};
	
	/**
	 * Remove all data.
	 * @method reset
	 */
	TupleDictionary.prototype.reset = function() {
	    var data = this.data,
	        keys = this.keys;
	
	    var l = keys.length;
	    while(l--) {
	        delete data[keys[l]];
	    }
	
	    keys.length = 0;
	};
	
	/**
	 * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
	 * @method copy
	 * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
	 */
	TupleDictionary.prototype.copy = function(dict) {
	    this.reset();
	    Utils.appendArray(this.keys, dict.keys);
	    var l = dict.keys.length;
	    while(l--){
	        var key = dict.keys[l];
	        this.data[key] = dict.data[key];
	    }
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var Shape = __webpack_require__(16)
	,    vec2 = __webpack_require__(4);
	
	module.exports = Circle;
	
	/**
	 * Circle shape class.
	 * @class Circle
	 * @extends Shape
	 * @constructor
	 * @param {options} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
	 * @param {number} [options.radius=1] The radius of this circle
	 *
	 * @example
	 *     var circleShape = new Circle({ radius: 1 });
	 *     body.addShape(circleShape);
	 */
	function Circle(options){
	    if(typeof(arguments[0]) === 'number'){
	        options = {
	            radius: arguments[0]
	        };
	        console.warn('The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })');
	    }
	    options = options || {};
	
	    /**
	     * The radius of the circle.
	     * @property radius
	     * @type {number}
	     */
	    this.radius = options.radius || 1;
	
	    options.type = Shape.CIRCLE;
	    Shape.call(this, options);
	}
	Circle.prototype = new Shape();
	Circle.prototype.constructor = Circle;
	
	/**
	 * @method computeMomentOfInertia
	 * @param  {Number} mass
	 * @return {Number}
	 */
	Circle.prototype.computeMomentOfInertia = function(mass){
	    var r = this.radius;
	    return mass * r * r / 2;
	};
	
	/**
	 * @method updateBoundingRadius
	 * @return {Number}
	 */
	Circle.prototype.updateBoundingRadius = function(){
	    this.boundingRadius = this.radius;
	};
	
	/**
	 * @method updateArea
	 * @return {Number}
	 */
	Circle.prototype.updateArea = function(){
	    this.area = Math.PI * this.radius * this.radius;
	};
	
	/**
	 * @method computeAABB
	 * @param  {AABB}   out      The resulting AABB.
	 * @param  {Array}  position
	 * @param  {Number} angle
	 */
	Circle.prototype.computeAABB = function(out, position, angle){
	    var r = this.radius;
	    vec2.set(out.upperBound,  r,  r);
	    vec2.set(out.lowerBound, -r, -r);
	    if(position){
	        vec2.add(out.lowerBound, out.lowerBound, position);
	        vec2.add(out.upperBound, out.upperBound, position);
	    }
	};
	
	var Ray_intersectSphere_intersectionPoint = vec2.create();
	var Ray_intersectSphere_normal = vec2.create();
	
	/**
	 * @method raycast
	 * @param  {RaycastResult} result
	 * @param  {Ray} ray
	 * @param  {array} position
	 * @param  {number} angle
	 */
	Circle.prototype.raycast = function(result, ray, position, angle){
	    var from = ray.from,
	        to = ray.to,
	        r = this.radius;
	
	    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
	    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
	    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);
	    var delta = Math.pow(b, 2) - 4 * a * c;
	
	    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
	    var normal = Ray_intersectSphere_normal;
	
	    if(delta < 0){
	        // No intersection
	        return;
	
	    } else if(delta === 0){
	        // single intersection point
	        vec2.lerp(intersectionPoint, from, to, delta);
	
	        vec2.sub(normal, intersectionPoint, position);
	        vec2.normalize(normal,normal);
	
	        ray.reportIntersection(result, delta, normal, -1);
	
	    } else {
	        var sqrtDelta = Math.sqrt(delta);
	        var inv2a = 1 / (2 * a);
	        var d1 = (- b - sqrtDelta) * inv2a;
	        var d2 = (- b + sqrtDelta) * inv2a;
	
	        if(d1 >= 0 && d1 <= 1){
	            vec2.lerp(intersectionPoint, from, to, d1);
	
	            vec2.sub(normal, intersectionPoint, position);
	            vec2.normalize(normal,normal);
	
	            ray.reportIntersection(result, d1, normal, -1);
	
	            if(result.shouldStop(ray)){
	                return;
	            }
	        }
	
	        if(d2 >= 0 && d2 <= 1){
	            vec2.lerp(intersectionPoint, from, to, d2);
	
	            vec2.sub(normal, intersectionPoint, position);
	            vec2.normalize(normal,normal);
	
	            ray.reportIntersection(result, d2, normal, -1);
	        }
	    }
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4)
	,   Shape = __webpack_require__(16)
	,   Convex = __webpack_require__(15);
	
	module.exports = Box;
	
	/**
	 * Box shape class.
	 * @class Box
	 * @constructor
	 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
	 * @param {Number} [options.width=1] Total width of the box
	 * @param {Number} [options.height=1] Total height of the box
	 * @extends Convex
	 */
	function Box(options){
	    if(typeof(arguments[0]) === 'number' && typeof(arguments[1]) === 'number'){
	        options = {
	            width: arguments[0],
	            height: arguments[1]
	        };
	        console.warn('The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })');
	    }
	    options = options || {};
	
	    /**
	     * Total width of the box
	     * @property width
	     * @type {Number}
	     */
	    var width = this.width = options.width || 1;
	
	    /**
	     * Total height of the box
	     * @property height
	     * @type {Number}
	     */
	    var height = this.height = options.height || 1;
	
	    var verts = [
	        vec2.fromValues(-width/2, -height/2),
	        vec2.fromValues( width/2, -height/2),
	        vec2.fromValues( width/2,  height/2),
	        vec2.fromValues(-width/2,  height/2)
	    ];
	    var axes = [
	        vec2.fromValues(1, 0),
	        vec2.fromValues(0, 1)
	    ];
	
	    options.vertices = verts;
	    options.axes = axes;
	    options.type = Shape.BOX;
	    Convex.call(this, options);
	}
	Box.prototype = new Convex();
	Box.prototype.constructor = Box;
	
	/**
	 * Compute moment of inertia
	 * @method computeMomentOfInertia
	 * @param  {Number} mass
	 * @return {Number}
	 */
	Box.prototype.computeMomentOfInertia = function(mass){
	    var w = this.width,
	        h = this.height;
	    return mass * (h*h + w*w) / 12;
	};
	
	/**
	 * Update the bounding radius
	 * @method updateBoundingRadius
	 */
	Box.prototype.updateBoundingRadius = function(){
	    var w = this.width,
	        h = this.height;
	    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;
	};
	
	var corner1 = vec2.create(),
	    corner2 = vec2.create(),
	    corner3 = vec2.create(),
	    corner4 = vec2.create();
	
	/**
	 * @method computeAABB
	 * @param  {AABB}   out      The resulting AABB.
	 * @param  {Array}  position
	 * @param  {Number} angle
	 */
	Box.prototype.computeAABB = function(out, position, angle){
	    out.setFromPoints(this.vertices,position,angle,0);
	};
	
	Box.prototype.updateArea = function(){
	    this.area = this.width * this.height;
	};
	


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var Equation = __webpack_require__(8),
	    vec2 = __webpack_require__(4);
	
	module.exports = AngleLockEquation;
	
	/**
	 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
	 *
	 * @class AngleLockEquation
	 * @constructor
	 * @extends Equation
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Object} [options]
	 * @param {Number} [options.angle] Angle to add to the local vector in body A.
	 * @param {Number} [options.ratio] Gear ratio
	 */
	function AngleLockEquation(bodyA, bodyB, options){
	    options = options || {};
	    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);
	    this.angle = options.angle || 0;
	
	    /**
	     * The gear ratio.
	     * @property {Number} ratio
	     * @private
	     * @see setRatio
	     */
	    this.ratio = typeof(options.ratio)==="number" ? options.ratio : 1;
	
	    this.setRatio(this.ratio);
	}
	AngleLockEquation.prototype = new Equation();
	AngleLockEquation.prototype.constructor = AngleLockEquation;
	
	AngleLockEquation.prototype.computeGq = function(){
	    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
	};
	
	/**
	 * Set the gear ratio for this equation
	 * @method setRatio
	 * @param {Number} ratio
	 */
	AngleLockEquation.prototype.setRatio = function(ratio){
	    var G = this.G;
	    G[2] =  ratio;
	    G[5] = -1;
	    this.ratio = ratio;
	};
	
	/**
	 * Set the max force for the equation.
	 * @method setMaxTorque
	 * @param {Number} torque
	 */
	AngleLockEquation.prototype.setMaxTorque = function(torque){
	    this.maxForce =  torque;
	    this.minForce = -torque;
	};


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4);
	var Body = __webpack_require__(9);
	
	module.exports = Broadphase;
	
	/**
	 * Base class for broadphase implementations.
	 * @class Broadphase
	 * @constructor
	 */
	function Broadphase(type){
	
	    this.type = type;
	
	    /**
	     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
	     * @property result
	     * @type {Array}
	     */
	    this.result = [];
	
	    /**
	     * The world to search for collision pairs in. To change it, use .setWorld()
	     * @property world
	     * @type {World}
	     * @readOnly
	     */
	    this.world = null;
	
	    /**
	     * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.
	     * @property {Number} boundingVolumeType
	     */
	    this.boundingVolumeType = Broadphase.AABB;
	}
	
	/**
	 * Axis aligned bounding box type.
	 * @static
	 * @property {Number} AABB
	 */
	Broadphase.AABB = 1;
	
	/**
	 * Bounding circle type.
	 * @static
	 * @property {Number} BOUNDING_CIRCLE
	 */
	Broadphase.BOUNDING_CIRCLE = 2;
	
	/**
	 * Set the world that we are searching for collision pairs in.
	 * @method setWorld
	 * @param  {World} world
	 */
	Broadphase.prototype.setWorld = function(world){
	    this.world = world;
	};
	
	/**
	 * Get all potential intersecting body pairs.
	 * @method getCollisionPairs
	 * @param  {World} world The world to search in.
	 * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
	 */
	Broadphase.prototype.getCollisionPairs = function(world){};
	
	var dist = vec2.create();
	
	/**
	 * Check whether the bounding radius of two bodies overlap.
	 * @method  boundingRadiusCheck
	 * @param  {Body} bodyA
	 * @param  {Body} bodyB
	 * @return {Boolean}
	 */
	Broadphase.boundingRadiusCheck = function(bodyA, bodyB){
	    vec2.sub(dist, bodyA.position, bodyB.position);
	    var d2 = vec2.squaredLength(dist),
	        r = bodyA.boundingRadius + bodyB.boundingRadius;
	    return d2 <= r*r;
	};
	
	/**
	 * Check whether the bounding radius of two bodies overlap.
	 * @method  boundingRadiusCheck
	 * @param  {Body} bodyA
	 * @param  {Body} bodyB
	 * @return {Boolean}
	 */
	Broadphase.aabbCheck = function(bodyA, bodyB){
	    return bodyA.getAABB().overlaps(bodyB.getAABB());
	};
	
	/**
	 * Check whether the bounding radius of two bodies overlap.
	 * @method  boundingRadiusCheck
	 * @param  {Body} bodyA
	 * @param  {Body} bodyB
	 * @return {Boolean}
	 */
	Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){
	    var result;
	
	    switch(this.boundingVolumeType){
	    case Broadphase.BOUNDING_CIRCLE:
	        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);
	        break;
	    case Broadphase.AABB:
	        result = Broadphase.aabbCheck(bodyA,bodyB);
	        break;
	    default:
	        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);
	    }
	    return result;
	};
	
	/**
	 * Check whether two bodies are allowed to collide at all.
	 * @method  canCollide
	 * @param  {Body} bodyA
	 * @param  {Body} bodyB
	 * @return {Boolean}
	 */
	Broadphase.canCollide = function(bodyA, bodyB){
	    var KINEMATIC = Body.KINEMATIC;
	    var STATIC = Body.STATIC;
	
	    // Cannot collide static bodies
	    if(bodyA.type === STATIC && bodyB.type === STATIC){
	        return false;
	    }
	
	    // Cannot collide static vs kinematic bodies
	    if( (bodyA.type === KINEMATIC && bodyB.type === STATIC) ||
	        (bodyA.type === STATIC    && bodyB.type === KINEMATIC)){
	        return false;
	    }
	
	    // Cannot collide kinematic vs kinematic
	    if(bodyA.type === KINEMATIC && bodyB.type === KINEMATIC){
	        return false;
	    }
	
	    // Cannot collide both sleeping bodies
	    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){
	        return false;
	    }
	
	    // Cannot collide if one is static and the other is sleeping
	    if( (bodyA.sleepState === Body.SLEEPING && bodyB.type === STATIC) ||
	        (bodyB.sleepState === Body.SLEEPING && bodyA.type === STATIC)){
	        return false;
	    }
	
	    return true;
	};
	
	Broadphase.NAIVE = 1;
	Broadphase.SAP = 2;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var Shape = __webpack_require__(16)
	,   vec2 = __webpack_require__(4);
	
	module.exports = Capsule;
	
	/**
	 * Capsule shape class.
	 * @class Capsule
	 * @constructor
	 * @extends Shape
	 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
	 * @param {Number} [options.length=1] The distance between the end points
	 * @param {Number} [options.radius=1] Radius of the capsule
	 * @example
	 *     var capsuleShape = new Capsule({
	 *         length: 1,
	 *         radius: 2
	 *     });
	 *     body.addShape(capsuleShape);
	 */
	function Capsule(options){
	    if(typeof(arguments[0]) === 'number' && typeof(arguments[1]) === 'number'){
	        options = {
	            length: arguments[0],
	            radius: arguments[1]
	        };
	        console.warn('The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })');
	    }
	    options = options || {};
	
	    /**
	     * The distance between the end points.
	     * @property {Number} length
	     */
	    this.length = options.length || 1;
	
	    /**
	     * The radius of the capsule.
	     * @property {Number} radius
	     */
	    this.radius = options.radius || 1;
	
	    options.type = Shape.CAPSULE;
	    Shape.call(this, options);
	}
	Capsule.prototype = new Shape();
	Capsule.prototype.constructor = Capsule;
	
	/**
	 * Compute the mass moment of inertia of the Capsule.
	 * @method conputeMomentOfInertia
	 * @param  {Number} mass
	 * @return {Number}
	 * @todo
	 */
	Capsule.prototype.computeMomentOfInertia = function(mass){
	    // Approximate with rectangle
	    var r = this.radius,
	        w = this.length + r, // 2*r is too much, 0 is too little
	        h = r*2;
	    return mass * (h*h + w*w) / 12;
	};
	
	/**
	 * @method updateBoundingRadius
	 */
	Capsule.prototype.updateBoundingRadius = function(){
	    this.boundingRadius = this.radius + this.length/2;
	};
	
	/**
	 * @method updateArea
	 */
	Capsule.prototype.updateArea = function(){
	    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
	};
	
	var r = vec2.create();
	
	/**
	 * @method computeAABB
	 * @param  {AABB}   out      The resulting AABB.
	 * @param  {Array}  position
	 * @param  {Number} angle
	 */
	Capsule.prototype.computeAABB = function(out, position, angle){
	    var radius = this.radius;
	
	    // Compute center position of one of the the circles, world oriented, but with local offset
	    vec2.set(r,this.length / 2,0);
	    if(angle !== 0){
	        vec2.rotate(r,r,angle);
	    }
	
	    // Get bounds
	    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),
	                              Math.max(r[1]+radius, -r[1]+radius));
	    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),
	                              Math.min(r[1]-radius, -r[1]-radius));
	
	    // Add offset
	    vec2.add(out.lowerBound, out.lowerBound, position);
	    vec2.add(out.upperBound, out.upperBound, position);
	};
	
	var intersectCapsule_hitPointWorld = vec2.create();
	var intersectCapsule_normal = vec2.create();
	var intersectCapsule_l0 = vec2.create();
	var intersectCapsule_l1 = vec2.create();
	var intersectCapsule_unit_y = vec2.fromValues(0,1);
	
	/**
	 * @method raycast
	 * @param  {RaycastResult} result
	 * @param  {Ray} ray
	 * @param  {array} position
	 * @param  {number} angle
	 */
	Capsule.prototype.raycast = function(result, ray, position, angle){
	    var from = ray.from;
	    var to = ray.to;
	    var direction = ray.direction;
	
	    var hitPointWorld = intersectCapsule_hitPointWorld;
	    var normal = intersectCapsule_normal;
	    var l0 = intersectCapsule_l0;
	    var l1 = intersectCapsule_l1;
	
	    // The sides
	    var halfLen = this.length / 2;
	    for(var i=0; i<2; i++){
	
	        // get start and end of the line
	        var y = this.radius * (i*2-1);
	        vec2.set(l0, -halfLen, y);
	        vec2.set(l1, halfLen, y);
	        vec2.toGlobalFrame(l0, l0, position, angle);
	        vec2.toGlobalFrame(l1, l1, position, angle);
	
	        var delta = vec2.getLineSegmentsIntersectionFraction(from, to, l0, l1);
	        if(delta >= 0){
	            vec2.rotate(normal, intersectCapsule_unit_y, angle);
	            vec2.scale(normal, normal, (i*2-1));
	            ray.reportIntersection(result, delta, normal, -1);
	            if(result.shouldStop(ray)){
	                return;
	            }
	        }
	    }
	
	    // Circles
	    var diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);
	    for(var i=0; i<2; i++){
	        vec2.set(l0, halfLen * (i*2-1), 0);
	        vec2.toGlobalFrame(l0, l0, position, angle);
	
	        var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
	        var b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));
	        var c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);
	        var delta = Math.pow(b, 2) - 4 * a * c;
	
	        if(delta < 0){
	            // No intersection
	            continue;
	
	        } else if(delta === 0){
	            // single intersection point
	            vec2.lerp(hitPointWorld, from, to, delta);
	
	            if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){
	                vec2.sub(normal, hitPointWorld, l0);
	                vec2.normalize(normal,normal);
	                ray.reportIntersection(result, delta, normal, -1);
	                if(result.shouldStop(ray)){
	                    return;
	                }
	            }
	
	        } else {
	            var sqrtDelta = Math.sqrt(delta);
	            var inv2a = 1 / (2 * a);
	            var d1 = (- b - sqrtDelta) * inv2a;
	            var d2 = (- b + sqrtDelta) * inv2a;
	
	            if(d1 >= 0 && d1 <= 1){
	                vec2.lerp(hitPointWorld, from, to, d1);
	                if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){
	                    vec2.sub(normal, hitPointWorld, l0);
	                    vec2.normalize(normal,normal);
	                    ray.reportIntersection(result, d1, normal, -1);
	                    if(result.shouldStop(ray)){
	                        return;
	                    }
	                }
	            }
	
	            if(d2 >= 0 && d2 <= 1){
	                vec2.lerp(hitPointWorld, from, to, d2);
	                if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){
	                    vec2.sub(normal, hitPointWorld, l0);
	                    vec2.normalize(normal,normal);
	                    ray.reportIntersection(result, d2, normal, -1);
	                    if(result.shouldStop(ray)){
	                        return;
	                    }
	                }
	            }
	        }
	    }
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Constraint;
	
	var Utils = __webpack_require__(5);
	
	/**
	 * Base constraint class.
	 *
	 * @class Constraint
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Number} type
	 * @param {Object} [options]
	 * @param {Object} [options.collideConnected=true]
	 */
	function Constraint(bodyA, bodyB, type, options){
	
	    /**
	     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.
	     * @property {number} type
	     */
	    this.type = type;
	
	    options = Utils.defaults(options,{
	        collideConnected : true,
	        wakeUpBodies : true,
	    });
	
	    /**
	     * Equations to be solved in this constraint
	     *
	     * @property equations
	     * @type {Array}
	     */
	    this.equations = [];
	
	    /**
	     * First body participating in the constraint.
	     * @property bodyA
	     * @type {Body}
	     */
	    this.bodyA = bodyA;
	
	    /**
	     * Second body participating in the constraint.
	     * @property bodyB
	     * @type {Body}
	     */
	    this.bodyB = bodyB;
	
	    /**
	     * Set to true if you want the connected bodies to collide.
	     * @property collideConnected
	     * @type {Boolean}
	     * @default true
	     */
	    this.collideConnected = options.collideConnected;
	
	    // Wake up bodies when connected
	    if(options.wakeUpBodies){
	        if(bodyA){
	            bodyA.wakeUp();
	        }
	        if(bodyB){
	            bodyB.wakeUp();
	        }
	    }
	}
	
	/**
	 * Updates the internal constraint parameters before solve.
	 * @method update
	 */
	Constraint.prototype.update = function(){
	    throw new Error("method update() not implmemented in this Constraint subclass!");
	};
	
	/**
	 * @static
	 * @property {number} DISTANCE
	 */
	Constraint.DISTANCE = 1;
	
	/**
	 * @static
	 * @property {number} GEAR
	 */
	Constraint.GEAR = 2;
	
	/**
	 * @static
	 * @property {number} LOCK
	 */
	Constraint.LOCK = 3;
	
	/**
	 * @static
	 * @property {number} PRISMATIC
	 */
	Constraint.PRISMATIC = 4;
	
	/**
	 * @static
	 * @property {number} REVOLUTE
	 */
	Constraint.REVOLUTE = 5;
	
	/**
	 * Set stiffness for this constraint.
	 * @method setStiffness
	 * @param {Number} stiffness
	 */
	Constraint.prototype.setStiffness = function(stiffness){
	    var eqs = this.equations;
	    for(var i=0; i !== eqs.length; i++){
	        var eq = eqs[i];
	        eq.stiffness = stiffness;
	        eq.needsUpdate = true;
	    }
	};
	
	/**
	 * Set relaxation for this constraint.
	 * @method setRelaxation
	 * @param {Number} relaxation
	 */
	Constraint.prototype.setRelaxation = function(relaxation){
	    var eqs = this.equations;
	    for(var i=0; i !== eqs.length; i++){
	        var eq = eqs[i];
	        eq.relaxation = relaxation;
	        eq.needsUpdate = true;
	    }
	};


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var Material = __webpack_require__(33);
	var Equation = __webpack_require__(8);
	
	module.exports = ContactMaterial;
	
	/**
	 * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.
	 * @class ContactMaterial
	 * @constructor
	 * @param {Material} materialA
	 * @param {Material} materialB
	 * @param {Object}   [options]
	 * @param {Number}   [options.friction=0.3]       Friction coefficient.
	 * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
	 * @param {Number}   [options.stiffness]          ContactEquation stiffness.
	 * @param {Number}   [options.relaxation]         ContactEquation relaxation.
	 * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
	 * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
	 * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
	 * @author schteppe
	 */
	function ContactMaterial(materialA, materialB, options){
	    options = options || {};
	
	    if(!(materialA instanceof Material) || !(materialB instanceof Material)){
	        throw new Error("First two arguments must be Material instances.");
	    }
	
	    /**
	     * The contact material identifier
	     * @property id
	     * @type {Number}
	     */
	    this.id = ContactMaterial.idCounter++;
	
	    /**
	     * First material participating in the contact material
	     * @property materialA
	     * @type {Material}
	     */
	    this.materialA = materialA;
	
	    /**
	     * Second material participating in the contact material
	     * @property materialB
	     * @type {Material}
	     */
	    this.materialB = materialB;
	
	    /**
	     * Friction to use in the contact of these two materials
	     * @property friction
	     * @type {Number}
	     */
	    this.friction    =  typeof(options.friction)    !== "undefined" ?   Number(options.friction)    : 0.3;
	
	    /**
	     * Restitution to use in the contact of these two materials
	     * @property restitution
	     * @type {Number}
	     */
	    this.restitution =  typeof(options.restitution) !== "undefined" ?   Number(options.restitution) : 0.0;
	
	    /**
	     * Stiffness of the resulting ContactEquation that this ContactMaterial generate
	     * @property stiffness
	     * @type {Number}
	     */
	    this.stiffness =            typeof(options.stiffness)           !== "undefined" ?   Number(options.stiffness)   : Equation.DEFAULT_STIFFNESS;
	
	    /**
	     * Relaxation of the resulting ContactEquation that this ContactMaterial generate
	     * @property relaxation
	     * @type {Number}
	     */
	    this.relaxation =           typeof(options.relaxation)          !== "undefined" ?   Number(options.relaxation)  : Equation.DEFAULT_RELAXATION;
	
	    /**
	     * Stiffness of the resulting FrictionEquation that this ContactMaterial generate
	     * @property frictionStiffness
	     * @type {Number}
	     */
	    this.frictionStiffness =    typeof(options.frictionStiffness)   !== "undefined" ?   Number(options.frictionStiffness)   : Equation.DEFAULT_STIFFNESS;
	
	    /**
	     * Relaxation of the resulting FrictionEquation that this ContactMaterial generate
	     * @property frictionRelaxation
	     * @type {Number}
	     */
	    this.frictionRelaxation =   typeof(options.frictionRelaxation)  !== "undefined" ?   Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;
	
	    /**
	     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
	     * @property {Number} surfaceVelocity
	     */
	    this.surfaceVelocity = typeof(options.surfaceVelocity)    !== "undefined" ?   Number(options.surfaceVelocity)    : 0;
	
	    /**
	     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
	     * @property contactSkinSize
	     * @type {Number}
	     */
	    this.contactSkinSize = 0.005;
	}
	
	ContactMaterial.idCounter = 0;


/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = Material;
	
	/**
	 * Defines a physics material.
	 * @class Material
	 * @constructor
	 * @param {number} id Material identifier
	 * @author schteppe
	 */
	function Material(id){
	    /**
	     * The material identifier
	     * @property id
	     * @type {Number}
	     */
	    this.id = id || Material.idCounter++;
	}
	
	Material.idCounter = 0;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var Constraint = __webpack_require__(31)
	,   Equation = __webpack_require__(8)
	,   vec2 = __webpack_require__(4)
	,   Utils = __webpack_require__(5);
	
	module.exports = DistanceConstraint;
	
	/**
	 * Constraint that tries to keep the distance between two bodies constant.
	 *
	 * @class DistanceConstraint
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {object} [options]
	 * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
	 * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
	 * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
	 * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
	 * @extends Constraint
	 *
	 * @example
	 *     // If distance is not given as an option, then the current distance between the bodies is used.
	 *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
	 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
	 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
	 *     var constraint = new DistanceConstraint(bodyA, bodyB);
	 *     world.addConstraint(constraint);
	 *
	 * @example
	 *     // Manually set the distance and anchors
	 *     var constraint = new DistanceConstraint(bodyA, bodyB, {
	 *         distance: 1,          // Distance to keep between the points
	 *         localAnchorA: [1, 0], // Point on bodyA
	 *         localAnchorB: [-1, 0] // Point on bodyB
	 *     });
	 *     world.addConstraint(constraint);
	 */
	function DistanceConstraint(bodyA,bodyB,options){
	    options = Utils.defaults(options,{
	        localAnchorA:[0,0],
	        localAnchorB:[0,0]
	    });
	
	    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);
	
	    /**
	     * Local anchor in body A.
	     * @property localAnchorA
	     * @type {Array}
	     */
	    this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);
	
	    /**
	     * Local anchor in body B.
	     * @property localAnchorB
	     * @type {Array}
	     */
	    this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);
	
	    var localAnchorA = this.localAnchorA;
	    var localAnchorB = this.localAnchorB;
	
	    /**
	     * The distance to keep.
	     * @property distance
	     * @type {Number}
	     */
	    this.distance = 0;
	
	    if(typeof(options.distance) === 'number'){
	        this.distance = options.distance;
	    } else {
	        // Use the current world distance between the world anchor points.
	        var worldAnchorA = vec2.create(),
	            worldAnchorB = vec2.create(),
	            r = vec2.create();
	
	        // Transform local anchors to world
	        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
	        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);
	
	        vec2.add(r, bodyB.position, worldAnchorB);
	        vec2.sub(r, r, worldAnchorA);
	        vec2.sub(r, r, bodyA.position);
	
	        this.distance = vec2.length(r);
	    }
	
	    var maxForce;
	    if(typeof(options.maxForce)==="undefined" ){
	        maxForce = Number.MAX_VALUE;
	    } else {
	        maxForce = options.maxForce;
	    }
	
	    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction
	    this.equations = [ normal ];
	
	    /**
	     * Max force to apply.
	     * @property {number} maxForce
	     */
	    this.maxForce = maxForce;
	
	    // g = (xi - xj).dot(n)
	    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'
	
	    // ...and if we were to include offset points:
	    // g =
	    //      (xj + rj - xi - ri).dot(n) - distance
	    //
	    // dg/dt =
	    //      (vj + wj x rj - vi - wi x ri).dot(n) =
	    //      { term 2 is near zero } =
	    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
	    //      G * W
	    //
	    // => G = [-n -rixn n rjxn]
	
	    var r = vec2.create();
	    var ri = vec2.create(); // worldAnchorA
	    var rj = vec2.create(); // worldAnchorB
	    var that = this;
	    normal.computeGq = function(){
	        var bodyA = this.bodyA,
	            bodyB = this.bodyB,
	            xi = bodyA.position,
	            xj = bodyB.position;
	
	        // Transform local anchors to world
	        vec2.rotate(ri, localAnchorA, bodyA.angle);
	        vec2.rotate(rj, localAnchorB, bodyB.angle);
	
	        vec2.add(r, xj, rj);
	        vec2.sub(r, r, ri);
	        vec2.sub(r, r, xi);
	
	        //vec2.sub(r, bodyB.position, bodyA.position);
	        return vec2.length(r) - that.distance;
	    };
	
	    // Make the contact constraint bilateral
	    this.setMaxForce(maxForce);
	
	    /**
	     * If the upper limit is enabled or not.
	     * @property {Boolean} upperLimitEnabled
	     */
	    this.upperLimitEnabled = false;
	
	    /**
	     * The upper constraint limit.
	     * @property {number} upperLimit
	     */
	    this.upperLimit = 1;
	
	    /**
	     * If the lower limit is enabled or not.
	     * @property {Boolean} lowerLimitEnabled
	     */
	    this.lowerLimitEnabled = false;
	
	    /**
	     * The lower constraint limit.
	     * @property {number} lowerLimit
	     */
	    this.lowerLimit = 0;
	
	    /**
	     * Current constraint position. This is equal to the current distance between the world anchor points.
	     * @property {number} position
	     */
	    this.position = 0;
	}
	DistanceConstraint.prototype = new Constraint();
	DistanceConstraint.prototype.constructor = DistanceConstraint;
	
	/**
	 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
	 * @method update
	 */
	var n = vec2.create();
	var ri = vec2.create(); // worldAnchorA
	var rj = vec2.create(); // worldAnchorB
	DistanceConstraint.prototype.update = function(){
	    var normal = this.equations[0],
	        bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        distance = this.distance,
	        xi = bodyA.position,
	        xj = bodyB.position,
	        normalEquation = this.equations[0],
	        G = normal.G;
	
	    // Transform local anchors to world
	    vec2.rotate(ri, this.localAnchorA, bodyA.angle);
	    vec2.rotate(rj, this.localAnchorB, bodyB.angle);
	
	    // Get world anchor points and normal
	    vec2.add(n, xj, rj);
	    vec2.sub(n, n, ri);
	    vec2.sub(n, n, xi);
	    this.position = vec2.length(n);
	
	    var violating = false;
	    if(this.upperLimitEnabled){
	        if(this.position > this.upperLimit){
	            normalEquation.maxForce = 0;
	            normalEquation.minForce = -this.maxForce;
	            this.distance = this.upperLimit;
	            violating = true;
	        }
	    }
	
	    if(this.lowerLimitEnabled){
	        if(this.position < this.lowerLimit){
	            normalEquation.maxForce = this.maxForce;
	            normalEquation.minForce = 0;
	            this.distance = this.lowerLimit;
	            violating = true;
	        }
	    }
	
	    if((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){
	        // No constraint needed.
	        normalEquation.enabled = false;
	        return;
	    }
	
	    normalEquation.enabled = true;
	
	    vec2.normalize(n,n);
	
	    // Caluclate cross products
	    var rixn = vec2.crossLength(ri, n),
	        rjxn = vec2.crossLength(rj, n);
	
	    // G = [-n -rixn n rjxn]
	    G[0] = -n[0];
	    G[1] = -n[1];
	    G[2] = -rixn;
	    G[3] = n[0];
	    G[4] = n[1];
	    G[5] = rjxn;
	};
	
	/**
	 * Set the max force to be used
	 * @method setMaxForce
	 * @param {Number} maxForce
	 */
	DistanceConstraint.prototype.setMaxForce = function(maxForce){
	    var normal = this.equations[0];
	    normal.minForce = -maxForce;
	    normal.maxForce =  maxForce;
	};
	
	/**
	 * Get the max force
	 * @method getMaxForce
	 * @return {Number}
	 */
	DistanceConstraint.prototype.getMaxForce = function(){
	    var normal = this.equations[0];
	    return normal.maxForce;
	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var Constraint = __webpack_require__(31)
	,   Equation = __webpack_require__(8)
	,   AngleLockEquation = __webpack_require__(28)
	,   vec2 = __webpack_require__(4);
	
	module.exports = GearConstraint;
	
	/**
	 * Constrains the angle of two bodies to each other to be equal. If a gear ratio is not one, the angle of bodyA must be a multiple of the angle of bodyB.
	 * @class GearConstraint
	 * @constructor
	 * @author schteppe
	 * @param {Body}            bodyA
	 * @param {Body}            bodyB
	 * @param {Object}          [options]
	 * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
	 * @param {Number}          [options.ratio=1] Gear ratio.
	 * @param {Number}          [options.maxTorque] Maximum torque to apply.
	 * @extends Constraint
	 *
	 * @example
	 *     var constraint = new GearConstraint(bodyA, bodyB);
	 *     world.addConstraint(constraint);
	 *
	 * @example
	 *     var constraint = new GearConstraint(bodyA, bodyB, {
	 *         ratio: 2,
	 *         maxTorque: 1000
	 *     });
	 *     world.addConstraint(constraint);
	 */
	function GearConstraint(bodyA, bodyB, options){
	    options = options || {};
	
	    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);
	
	    /**
	     * The gear ratio.
	     * @property ratio
	     * @type {Number}
	     */
	    this.ratio = options.ratio !== undefined ? options.ratio : 1;
	
	    /**
	     * The relative angle
	     * @property angle
	     * @type {Number}
	     */
	    this.angle = options.angle !== undefined ? options.angle : bodyB.angle - this.ratio * bodyA.angle;
	
	    // Send same parameters to the equation
	    options.angle = this.angle;
	    options.ratio = this.ratio;
	
	    this.equations = [
	        new AngleLockEquation(bodyA,bodyB,options),
	    ];
	
	    // Set max torque
	    if(options.maxTorque !== undefined){
	        this.setMaxTorque(options.maxTorque);
	    }
	}
	GearConstraint.prototype = new Constraint();
	GearConstraint.prototype.constructor = GearConstraint;
	
	GearConstraint.prototype.update = function(){
	    var eq = this.equations[0];
	    if(eq.ratio !== this.ratio){
	        eq.setRatio(this.ratio);
	    }
	    eq.angle = this.angle;
	};
	
	/**
	 * Set the max torque for the constraint.
	 * @method setMaxTorque
	 * @param {Number} torque
	 */
	GearConstraint.prototype.setMaxTorque = function(torque){
	    this.equations[0].setMaxTorque(torque);
	};
	
	/**
	 * Get the max torque for the constraint.
	 * @method getMaxTorque
	 * @return {Number}
	 */
	GearConstraint.prototype.getMaxTorque = function(torque){
	    return this.equations[0].maxForce;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4)
	,   Solver = __webpack_require__(37)
	,   Utils = __webpack_require__(5)
	,   FrictionEquation = __webpack_require__(24);
	
	module.exports = GSSolver;
	
	/**
	 * Iterative Gauss-Seidel constraint equation solver.
	 *
	 * @class GSSolver
	 * @constructor
	 * @extends Solver
	 * @param {Object} [options]
	 * @param {Number} [options.iterations=10]
	 * @param {Number} [options.tolerance=0]
	 */
	function GSSolver(options){
	    Solver.call(this,options,Solver.GS);
	    options = options || {};
	
	    /**
	     * The max number of iterations to do when solving. More gives better results, but is more expensive.
	     * @property iterations
	     * @type {Number}
	     */
	    this.iterations = options.iterations || 10;
	
	    /**
	     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.
	     * @property tolerance
	     * @type {Number}
	     * @default 1e-7
	     */
	    this.tolerance = options.tolerance || 1e-7;
	
	    this.arrayStep = 30;
	    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
	    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);
	    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);
	
	    /**
	     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.
	     * @property useZeroRHS
	     * @type {Boolean}
	     */
	    this.useZeroRHS = false;
	
	    /**
	     * Number of solver iterations that are done to approximate normal forces. When these iterations are done, friction force will be computed from the contact normal forces. These friction forces will override any other friction forces set from the World for example.
	     * The solver will use less iterations if the solution is below the .tolerance.
	     * @property frictionIterations
	     * @type {Number}
	     */
	    this.frictionIterations = 0;
	
	    /**
	     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
	     * @property {Number} usedIterations
	     */
	    this.usedIterations = 0;
	}
	GSSolver.prototype = new Solver();
	GSSolver.prototype.constructor = GSSolver;
	
	function setArrayZero(array){
	    var l = array.length;
	    while(l--){
	        array[l] = +0.0;
	    }
	}
	
	/**
	 * Solve the system of equations
	 * @method solve
	 * @param  {Number}  h       Time step
	 * @param  {World}   world    World to solve
	 */
	GSSolver.prototype.solve = function(h, world){
	
	    this.sortEquations();
	
	    var iter = 0,
	        maxIter = this.iterations,
	        maxFrictionIter = this.frictionIterations,
	        equations = this.equations,
	        Neq = equations.length,
	        tolSquared = Math.pow(this.tolerance*Neq, 2),
	        bodies = world.bodies,
	        Nbodies = world.bodies.length,
	        add = vec2.add,
	        set = vec2.set,
	        useZeroRHS = this.useZeroRHS,
	        lambda = this.lambda;
	
	    this.usedIterations = 0;
	
	    if(Neq){
	        for(var i=0; i!==Nbodies; i++){
	            var b = bodies[i];
	
	            // Update solve mass
	            b.updateSolveMassProperties();
	        }
	    }
	
	    // Things that does not change during iteration can be computed once
	    if(lambda.length < Neq){
	        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);
	        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);
	        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);
	    }
	    setArrayZero(lambda);
	    var invCs = this.invCs,
	        Bs = this.Bs,
	        lambda = this.lambda;
	
	    for(var i=0; i!==equations.length; i++){
	        var c = equations[i];
	        if(c.timeStep !== h || c.needsUpdate){
	            c.timeStep = h;
	            c.update();
	        }
	        Bs[i] =     c.computeB(c.a,c.b,h);
	        invCs[i] =  c.computeInvC(c.epsilon);
	    }
	
	    var q, B, c, deltalambdaTot,i,j;
	
	    if(Neq !== 0){
	
	        for(i=0; i!==Nbodies; i++){
	            var b = bodies[i];
	
	            // Reset vlambda
	            b.resetConstraintVelocity();
	        }
	
	        if(maxFrictionIter){
	            // Iterate over contact equations to get normal forces
	            for(iter=0; iter!==maxFrictionIter; iter++){
	
	                // Accumulate the total error for each iteration.
	                deltalambdaTot = 0.0;
	
	                for(j=0; j!==Neq; j++){
	                    c = equations[j];
	
	                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
	                    deltalambdaTot += Math.abs(deltalambda);
	                }
	
	                this.usedIterations++;
	
	                // If the total error is small enough - stop iterate
	                if(deltalambdaTot*deltalambdaTot <= tolSquared){
	                    break;
	                }
	            }
	
	            GSSolver.updateMultipliers(equations, lambda, 1/h);
	
	            // Set computed friction force
	            for(j=0; j!==Neq; j++){
	                var eq = equations[j];
	                if(eq instanceof FrictionEquation){
	                    var f = 0.0;
	                    for(var k=0; k!==eq.contactEquations.length; k++){
	                        f += eq.contactEquations[k].multiplier;
	                    }
	                    f *= eq.frictionCoefficient / eq.contactEquations.length;
	                    eq.maxForce =  f;
	                    eq.minForce = -f;
	                }
	            }
	        }
	
	        // Iterate over all equations
	        for(iter=0; iter!==maxIter; iter++){
	
	            // Accumulate the total error for each iteration.
	            deltalambdaTot = 0.0;
	
	            for(j=0; j!==Neq; j++){
	                c = equations[j];
	
	                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
	                deltalambdaTot += Math.abs(deltalambda);
	            }
	
	            this.usedIterations++;
	
	            // If the total error is small enough - stop iterate
	            if(deltalambdaTot*deltalambdaTot <= tolSquared){
	                break;
	            }
	        }
	
	        // Add result to velocity
	        for(i=0; i!==Nbodies; i++){
	            bodies[i].addConstraintVelocity();
	        }
	
	        GSSolver.updateMultipliers(equations, lambda, 1/h);
	    }
	};
	
	// Sets the .multiplier property of each equation
	GSSolver.updateMultipliers = function(equations, lambda, invDt){
	    // Set the .multiplier property of each equation
	    var l = equations.length;
	    while(l--){
	        equations[l].multiplier = lambda[l] * invDt;
	    }
	};
	
	GSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){
	    // Compute iteration
	    var B = Bs[j],
	        invC = invCs[j],
	        lambdaj = lambda[j],
	        GWlambda = eq.computeGWlambda();
	
	    var maxForce = eq.maxForce,
	        minForce = eq.minForce;
	
	    if(useZeroRHS){
	        B = 0;
	    }
	
	    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );
	
	    // Clamp if we are not within the min/max interval
	    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
	    if(lambdaj_plus_deltalambda < minForce*dt){
	        deltalambda = minForce*dt - lambdaj;
	    } else if(lambdaj_plus_deltalambda > maxForce*dt){
	        deltalambda = maxForce*dt - lambdaj;
	    }
	    lambda[j] += deltalambda;
	    eq.addToWlambda(deltalambda);
	
	    return deltalambda;
	};


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var Utils = __webpack_require__(5)
	,   EventEmitter = __webpack_require__(21);
	
	module.exports = Solver;
	
	/**
	 * Base class for constraint solvers.
	 * @class Solver
	 * @constructor
	 * @extends EventEmitter
	 */
	function Solver(options,type){
	    options = options || {};
	
	    EventEmitter.call(this);
	
	    this.type = type;
	
	    /**
	     * Current equations in the solver.
	     *
	     * @property equations
	     * @type {Array}
	     */
	    this.equations = [];
	
	    /**
	     * Function that is used to sort all equations before each solve.
	     * @property equationSortFunction
	     * @type {function|boolean}
	     */
	    this.equationSortFunction = options.equationSortFunction || false;
	}
	Solver.prototype = new EventEmitter();
	Solver.prototype.constructor = Solver;
	
	/**
	 * Method to be implemented in each subclass
	 * @method solve
	 * @param  {Number} dt
	 * @param  {World} world
	 */
	Solver.prototype.solve = function(dt,world){
	    throw new Error("Solver.solve should be implemented by subclasses!");
	};
	
	var mockWorld = {bodies:[]};
	
	/**
	 * Solves all constraints in an island.
	 * @method solveIsland
	 * @param  {Number} dt
	 * @param  {Island} island
	 */
	Solver.prototype.solveIsland = function(dt,island){
	
	    this.removeAllEquations();
	
	    if(island.equations.length){
	        // Add equations to solver
	        this.addEquations(island.equations);
	        mockWorld.bodies.length = 0;
	        island.getBodies(mockWorld.bodies);
	
	        // Solve
	        if(mockWorld.bodies.length){
	            this.solve(dt,mockWorld);
	        }
	    }
	};
	
	/**
	 * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
	 * @method sortEquations
	 */
	Solver.prototype.sortEquations = function(){
	    if(this.equationSortFunction){
	        this.equations.sort(this.equationSortFunction);
	    }
	};
	
	/**
	 * Add an equation to be solved.
	 *
	 * @method addEquation
	 * @param {Equation} eq
	 */
	Solver.prototype.addEquation = function(eq){
	    if(eq.enabled){
	        this.equations.push(eq);
	    }
	};
	
	/**
	 * Add equations. Same as .addEquation, but this time the argument is an array of Equations
	 *
	 * @method addEquations
	 * @param {Array} eqs
	 */
	Solver.prototype.addEquations = function(eqs){
	    //Utils.appendArray(this.equations,eqs);
	    for(var i=0, N=eqs.length; i!==N; i++){
	        var eq = eqs[i];
	        if(eq.enabled){
	            this.equations.push(eq);
	        }
	    }
	};
	
	/**
	 * Remove an equation.
	 *
	 * @method removeEquation
	 * @param {Equation} eq
	 */
	Solver.prototype.removeEquation = function(eq){
	    var i = this.equations.indexOf(eq);
	    if(i !== -1){
	        this.equations.splice(i,1);
	    }
	};
	
	/**
	 * Remove all currently added equations.
	 *
	 * @method removeAllEquations
	 */
	Solver.prototype.removeAllEquations = function(){
	    this.equations.length=0;
	};
	
	Solver.GS = 1;
	Solver.ISLAND = 2;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var Shape = __webpack_require__(16)
	,    vec2 = __webpack_require__(4)
	,    Utils = __webpack_require__(5);
	
	module.exports = Heightfield;
	
	/**
	 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
	 * @class Heightfield
	 * @extends Shape
	 * @constructor
	 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
	 * @param {array} [options.heights] An array of Y values that will be used to construct the terrain.
	 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
	 * @param {Number} [options.maxValue] Maximum value.
	 * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
	 *
	 * @example
	 *     // Generate some height data (y-values).
	 *     var heights = [];
	 *     for(var i = 0; i < 1000; i++){
	 *         var y = 0.5 * Math.cos(0.2 * i);
	 *         heights.push(y);
	 *     }
	 *
	 *     // Create the heightfield shape
	 *     var heightfieldShape = new Heightfield({
	 *         heights: heights,
	 *         elementWidth: 1 // Distance between the data points in X direction
	 *     });
	 *     var heightfieldBody = new Body();
	 *     heightfieldBody.addShape(heightfieldShape);
	 *     world.addBody(heightfieldBody);
	 *
	 * @todo Should use a scale property with X and Y direction instead of just elementWidth
	 */
	function Heightfield(options){
	    if(Array.isArray(arguments[0])){
	        options = {
	            heights: arguments[0]
	        };
	
	        if(typeof(arguments[1]) === 'object'){
	            for(var key in arguments[1]){
	                options[key] = arguments[1][key];
	            }
	        }
	
	        console.warn('The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })');
	    }
	    options = options || {};
	
	    /**
	     * An array of numbers, or height values, that are spread out along the x axis.
	     * @property {array} heights
	     */
	    this.heights = options.heights ? options.heights.slice(0) : [];
	
	    /**
	     * Max value of the heights
	     * @property {number} maxValue
	     */
	    this.maxValue = options.maxValue || null;
	
	    /**
	     * Max value of the heights
	     * @property {number} minValue
	     */
	    this.minValue = options.minValue || null;
	
	    /**
	     * The width of each element
	     * @property {number} elementWidth
	     */
	    this.elementWidth = options.elementWidth || 0.1;
	
	    if(options.maxValue === undefined || options.minValue === undefined){
	        this.updateMaxMinValues();
	    }
	
	    options.type = Shape.HEIGHTFIELD;
	    Shape.call(this, options);
	}
	Heightfield.prototype = new Shape();
	Heightfield.prototype.constructor = Heightfield;
	
	/**
	 * Update the .minValue and the .maxValue
	 * @method updateMaxMinValues
	 */
	Heightfield.prototype.updateMaxMinValues = function(){
	    var data = this.heights;
	    var maxValue = data[0];
	    var minValue = data[0];
	    for(var i=0; i !== data.length; i++){
	        var v = data[i];
	        if(v > maxValue){
	            maxValue = v;
	        }
	        if(v < minValue){
	            minValue = v;
	        }
	    }
	    this.maxValue = maxValue;
	    this.minValue = minValue;
	};
	
	/**
	 * @method computeMomentOfInertia
	 * @param  {Number} mass
	 * @return {Number}
	 */
	Heightfield.prototype.computeMomentOfInertia = function(mass){
	    return Number.MAX_VALUE;
	};
	
	Heightfield.prototype.updateBoundingRadius = function(){
	    this.boundingRadius = Number.MAX_VALUE;
	};
	
	Heightfield.prototype.updateArea = function(){
	    var data = this.heights,
	        area = 0;
	    for(var i=0; i<data.length-1; i++){
	        area += (data[i]+data[i+1]) / 2 * this.elementWidth;
	    }
	    this.area = area;
	};
	
	var points = [
	    vec2.create(),
	    vec2.create(),
	    vec2.create(),
	    vec2.create()
	];
	
	/**
	 * @method computeAABB
	 * @param  {AABB}   out      The resulting AABB.
	 * @param  {Array}  position
	 * @param  {Number} angle
	 */
	Heightfield.prototype.computeAABB = function(out, position, angle){
	    vec2.set(points[0], 0, this.maxValue);
	    vec2.set(points[1], this.elementWidth * this.heights.length, this.maxValue);
	    vec2.set(points[2], this.elementWidth * this.heights.length, this.minValue);
	    vec2.set(points[3], 0, this.minValue);
	    out.setFromPoints(points, position, angle);
	};
	
	/**
	 * Get a line segment in the heightfield
	 * @method getLineSegment
	 * @param  {array} start Where to store the resulting start point
	 * @param  {array} end Where to store the resulting end point
	 * @param  {number} i
	 */
	Heightfield.prototype.getLineSegment = function(start, end, i){
	    var data = this.heights;
	    var width = this.elementWidth;
	    vec2.set(start, i * width, data[i]);
	    vec2.set(end, (i + 1) * width, data[i + 1]);
	};
	
	Heightfield.prototype.getSegmentIndex = function(position){
	    return Math.floor(position[0] / this.elementWidth);
	};
	
	Heightfield.prototype.getClampedSegmentIndex = function(position){
	    var i = this.getSegmentIndex(position);
	    i = Math.min(this.heights.length, Math.max(i, 0)); // clamp
	    return i;
	};
	
	var intersectHeightfield_hitPointWorld = vec2.create();
	var intersectHeightfield_worldNormal = vec2.create();
	var intersectHeightfield_l0 = vec2.create();
	var intersectHeightfield_l1 = vec2.create();
	var intersectHeightfield_localFrom = vec2.create();
	var intersectHeightfield_localTo = vec2.create();
	var intersectHeightfield_unit_y = vec2.fromValues(0,1);
	
	// Returns 1 if the lines intersect, otherwise 0.
	function getLineSegmentsIntersection (out, p0, p1, p2, p3) {
	
	    var s1_x, s1_y, s2_x, s2_y;
	    s1_x = p1[0] - p0[0];
	    s1_y = p1[1] - p0[1];
	    s2_x = p3[0] - p2[0];
	    s2_y = p3[1] - p2[1];
	
	    var s, t;
	    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
	    t = ( s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
	    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected
	        var intX = p0[0] + (t * s1_x);
	        var intY = p0[1] + (t * s1_y);
	        out[0] = intX;
	        out[1] = intY;
	        return t;
	    }
	    return -1; // No collision
	}
	
	/**
	 * @method raycast
	 * @param  {RayResult} result
	 * @param  {Ray} ray
	 * @param  {array} position
	 * @param  {number} angle
	 */
	Heightfield.prototype.raycast = function(result, ray, position, angle){
	    var from = ray.from;
	    var to = ray.to;
	    var direction = ray.direction;
	
	    var hitPointWorld = intersectHeightfield_hitPointWorld;
	    var worldNormal = intersectHeightfield_worldNormal;
	    var l0 = intersectHeightfield_l0;
	    var l1 = intersectHeightfield_l1;
	    var localFrom = intersectHeightfield_localFrom;
	    var localTo = intersectHeightfield_localTo;
	
	    // get local ray start and end
	    vec2.toLocalFrame(localFrom, from, position, angle);
	    vec2.toLocalFrame(localTo, to, position, angle);
	
	    // Get the segment range
	    var i0 = this.getClampedSegmentIndex(localFrom);
	    var i1 = this.getClampedSegmentIndex(localTo);
	    if(i0 > i1){
	        var tmp = i0;
	        i0 = i1;
	        i1 = tmp;
	    }
	
	    // The segments
	    for(var i=0; i<this.heights.length - 1; i++){
	        this.getLineSegment(l0, l1, i);
	        var t = vec2.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);
	        if(t >= 0){
	            vec2.sub(worldNormal, l1, l0);
	            vec2.rotate(worldNormal, worldNormal, angle + Math.PI / 2);
	            vec2.normalize(worldNormal, worldNormal);
	            ray.reportIntersection(result, t, worldNormal, -1);
	            if(result.shouldStop(ray)){
	                return;
	            }
	        }
	    }
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var Shape = __webpack_require__(16)
	,   vec2 = __webpack_require__(4);
	
	module.exports = Line;
	
	/**
	 * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
	 * @class Line
	 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
	 * @param {Number} [options.length=1] The total length of the line
	 * @extends Shape
	 * @constructor
	 */
	function Line(options){
	    if(typeof(arguments[0]) === 'number'){
	        options = {
	            length: arguments[0]
	        };
	        console.warn('The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })');
	    }
	    options = options || {};
	
	    /**
	     * Length of this line
	     * @property {Number} length
	     * @default 1
	     */
	    this.length = options.length || 1;
	
	    options.type = Shape.LINE;
	    Shape.call(this, options);
	}
	Line.prototype = new Shape();
	Line.prototype.constructor = Line;
	
	Line.prototype.computeMomentOfInertia = function(mass){
	    return mass * Math.pow(this.length,2) / 12;
	};
	
	Line.prototype.updateBoundingRadius = function(){
	    this.boundingRadius = this.length/2;
	};
	
	var points = [vec2.create(),vec2.create()];
	
	/**
	 * @method computeAABB
	 * @param  {AABB}   out      The resulting AABB.
	 * @param  {Array}  position
	 * @param  {Number} angle
	 */
	Line.prototype.computeAABB = function(out, position, angle){
	    var l2 = this.length / 2;
	    vec2.set(points[0], -l2,  0);
	    vec2.set(points[1],  l2,  0);
	    out.setFromPoints(points,position,angle,0);
	};
	
	var raycast_hitPoint = vec2.create();
	var raycast_normal = vec2.create();
	var raycast_l0 = vec2.create();
	var raycast_l1 = vec2.create();
	var raycast_unit_y = vec2.fromValues(0,1);
	
	/**
	 * @method raycast
	 * @param  {RaycastResult} result
	 * @param  {Ray} ray
	 * @param  {number} angle
	 * @param  {array} position
	 */
	Line.prototype.raycast = function(result, ray, position, angle){
	    var from = ray.from;
	    var to = ray.to;
	
	    var l0 = raycast_l0;
	    var l1 = raycast_l1;
	
	    // get start and end of the line
	    var halfLen = this.length / 2;
	    vec2.set(l0, -halfLen, 0);
	    vec2.set(l1, halfLen, 0);
	    vec2.toGlobalFrame(l0, l0, position, angle);
	    vec2.toGlobalFrame(l1, l1, position, angle);
	
	    var fraction = vec2.getLineSegmentsIntersectionFraction(l0, l1, from, to);
	    if(fraction >= 0){
	        var normal = raycast_normal;
	        vec2.rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from
	        ray.reportIntersection(result, fraction, normal, -1);
	    }
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var Constraint = __webpack_require__(31)
	,   vec2 = __webpack_require__(4)
	,   Equation = __webpack_require__(8);
	
	module.exports = LockConstraint;
	
	/**
	 * Locks the relative position and rotation between two bodies.
	 *
	 * @class LockConstraint
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Object} [options]
	 * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
	 * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
	 * @param {number} [options.maxForce]
	 * @extends Constraint
	 *
	 * @example
	 *     // Locks the relative position and rotation between bodyA and bodyB
	 *     var constraint = new LockConstraint(bodyA, bodyB);
	 *     world.addConstraint(constraint);
	 */
	function LockConstraint(bodyA, bodyB, options){
	    options = options || {};
	
	    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);
	
	    var maxForce = ( typeof(options.maxForce)==="undefined" ? Number.MAX_VALUE : options.maxForce );
	
	    var localAngleB = options.localAngleB || 0;
	
	    // Use 3 equations:
	    // gx =   (xj - xi - l) * xhat = 0
	    // gy =   (xj - xi - l) * yhat = 0
	    // gr =   (xi - xj + r) * that = 0
	    //
	    // ...where:
	    //   l is the localOffsetB vector rotated to world in bodyA frame
	    //   r is the same vector but reversed and rotated from bodyB frame
	    //   xhat, yhat are world axis vectors
	    //   that is the tangent of r
	    //
	    // For the first two constraints, we get
	    // G*W = (vj - vi - ldot  ) * xhat
	    //     = (vj - vi - wi x l) * xhat
	    //
	    // Since (wi x l) * xhat = (l x xhat) * wi, we get
	    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
	    //
	    // The last constraint gives
	    // GW = (vi - vj + wj x r) * that
	    //    = [  that   0  -that  (r x t) ]
	
	    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),
	        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),
	        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);
	
	    var l = vec2.create(),
	        g = vec2.create(),
	        that = this;
	    x.computeGq = function(){
	        vec2.rotate(l, that.localOffsetB, bodyA.angle);
	        vec2.sub(g, bodyB.position, bodyA.position);
	        vec2.sub(g, g, l);
	        return g[0];
	    };
	    y.computeGq = function(){
	        vec2.rotate(l, that.localOffsetB, bodyA.angle);
	        vec2.sub(g, bodyB.position, bodyA.position);
	        vec2.sub(g, g, l);
	        return g[1];
	    };
	    var r = vec2.create(),
	        t = vec2.create();
	    rot.computeGq = function(){
	        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
	        vec2.scale(r,r,-1);
	        vec2.sub(g,bodyA.position,bodyB.position);
	        vec2.add(g,g,r);
	        vec2.rotate(t,r,-Math.PI/2);
	        vec2.normalize(t,t);
	        return vec2.dot(g,t);
	    };
	
	    /**
	     * The offset of bodyB in bodyA's frame.
	     * @property {Array} localOffsetB
	     */
	    this.localOffsetB = vec2.create();
	    if(options.localOffsetB){
	        vec2.copy(this.localOffsetB, options.localOffsetB);
	    } else {
	        // Construct from current positions
	        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
	        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
	    }
	
	    /**
	     * The offset angle of bodyB in bodyA's frame.
	     * @property {Number} localAngleB
	     */
	    this.localAngleB = 0;
	    if(typeof(options.localAngleB) === 'number'){
	        this.localAngleB = options.localAngleB;
	    } else {
	        // Construct
	        this.localAngleB = bodyB.angle - bodyA.angle;
	    }
	
	    this.equations.push(x, y, rot);
	    this.setMaxForce(maxForce);
	}
	LockConstraint.prototype = new Constraint();
	LockConstraint.prototype.constructor = LockConstraint;
	
	/**
	 * Set the maximum force to be applied.
	 * @method setMaxForce
	 * @param {Number} force
	 */
	LockConstraint.prototype.setMaxForce = function(force){
	    var eqs = this.equations;
	    for(var i=0; i<this.equations.length; i++){
	        eqs[i].maxForce =  force;
	        eqs[i].minForce = -force;
	    }
	};
	
	/**
	 * Get the max force.
	 * @method getMaxForce
	 * @return {Number}
	 */
	LockConstraint.prototype.getMaxForce = function(){
	    return this.equations[0].maxForce;
	};
	
	var l = vec2.create();
	var r = vec2.create();
	var t = vec2.create();
	var xAxis = vec2.fromValues(1,0);
	var yAxis = vec2.fromValues(0,1);
	LockConstraint.prototype.update = function(){
	    var x =   this.equations[0],
	        y =   this.equations[1],
	        rot = this.equations[2],
	        bodyA = this.bodyA,
	        bodyB = this.bodyB;
	
	    vec2.rotate(l,this.localOffsetB,bodyA.angle);
	    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);
	    vec2.scale(r,r,-1);
	
	    vec2.rotate(t,r,Math.PI/2);
	    vec2.normalize(t,t);
	
	    x.G[0] = -1;
	    x.G[1] =  0;
	    x.G[2] = -vec2.crossLength(l,xAxis);
	    x.G[3] =  1;
	
	    y.G[0] =  0;
	    y.G[1] = -1;
	    y.G[2] = -vec2.crossLength(l,yAxis);
	    y.G[4] =  1;
	
	    rot.G[0] =  -t[0];
	    rot.G[1] =  -t[1];
	    rot.G[3] =  t[0];
	    rot.G[4] =  t[1];
	    rot.G[5] =  vec2.crossLength(r,t);
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var Circle = __webpack_require__(26),
	    Plane = __webpack_require__(43),
	    Shape = __webpack_require__(16),
	    Particle = __webpack_require__(42),
	    Broadphase = __webpack_require__(29),
	    vec2 = __webpack_require__(4);
	
	module.exports = NaiveBroadphase;
	
	/**
	 * Naive broadphase implementation. Does N^2 tests.
	 *
	 * @class NaiveBroadphase
	 * @constructor
	 * @extends Broadphase
	 */
	function NaiveBroadphase(){
	    Broadphase.call(this, Broadphase.NAIVE);
	}
	NaiveBroadphase.prototype = new Broadphase();
	NaiveBroadphase.prototype.constructor = NaiveBroadphase;
	
	/**
	 * Get the colliding pairs
	 * @method getCollisionPairs
	 * @param  {World} world
	 * @return {Array}
	 */
	NaiveBroadphase.prototype.getCollisionPairs = function(world){
	    var bodies = world.bodies,
	        result = this.result;
	
	    result.length = 0;
	
	    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){
	        var bi = bodies[i];
	
	        for(var j=0; j<i; j++){
	            var bj = bodies[j];
	
	            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
	                result.push(bi,bj);
	            }
	        }
	    }
	
	    return result;
	};
	
	/**
	 * Returns all the bodies within an AABB.
	 * @method aabbQuery
	 * @param  {World} world
	 * @param  {AABB} aabb
	 * @param {array} result An array to store resulting bodies in.
	 * @return {array}
	 */
	NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
	    result = result || [];
	
	    var bodies = world.bodies;
	    for(var i = 0; i < bodies.length; i++){
	        var b = bodies[i];
	
	        if(b.aabbNeedsUpdate){
	            b.updateAABB();
	        }
	
	        if(b.aabb.overlaps(aabb)){
	            result.push(b);
	        }
	    }
	
	    return result;
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var Shape = __webpack_require__(16)
	,   vec2 = __webpack_require__(4);
	
	module.exports = Particle;
	
	/**
	 * Particle shape class.
	 * @class Particle
	 * @constructor
	 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
	 * @extends Shape
	 */
	function Particle(options){
	    options = options || {};
		options.type = Shape.PARTICLE;
	    Shape.call(this, options);
	}
	Particle.prototype = new Shape();
	Particle.prototype.constructor = Particle;
	
	Particle.prototype.computeMomentOfInertia = function(mass){
	    return 0; // Can't rotate a particle
	};
	
	Particle.prototype.updateBoundingRadius = function(){
	    this.boundingRadius = 0;
	};
	
	/**
	 * @method computeAABB
	 * @param  {AABB}   out
	 * @param  {Array}  position
	 * @param  {Number} angle
	 */
	Particle.prototype.computeAABB = function(out, position, angle){
	    vec2.copy(out.lowerBound, position);
	    vec2.copy(out.upperBound, position);
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var Shape =  __webpack_require__(16)
	,    vec2 =  __webpack_require__(4)
	,    Utils = __webpack_require__(5);
	
	module.exports = Plane;
	
	/**
	 * Plane shape class. The plane is facing in the Y direction.
	 * @class Plane
	 * @extends Shape
	 * @constructor
	 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
	 */
	function Plane(options){
	    options = options || {};
	    options.type = Shape.PLANE;
	    Shape.call(this, options);
	}
	Plane.prototype = new Shape();
	Plane.prototype.constructor = Plane;
	
	/**
	 * Compute moment of inertia
	 * @method computeMomentOfInertia
	 */
	Plane.prototype.computeMomentOfInertia = function(mass){
	    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
	};
	
	/**
	 * Update the bounding radius
	 * @method updateBoundingRadius
	 */
	Plane.prototype.updateBoundingRadius = function(){
	    this.boundingRadius = Number.MAX_VALUE;
	};
	
	/**
	 * @method computeAABB
	 * @param  {AABB}   out
	 * @param  {Array}  position
	 * @param  {Number} angle
	 */
	Plane.prototype.computeAABB = function(out, position, angle){
	    var a = angle % (2 * Math.PI);
	    var set = vec2.set;
	    var max = Number.MAX_VALUE;
	    var lowerBound = out.lowerBound;
	    var upperBound = out.upperBound;
	
	    if(a === 0){
	        // y goes from -inf to 0
	        set(lowerBound, -max, -max);
	        set(upperBound,  max,  0);
	
	    } else if(a === Math.PI / 2){
	
	        // x goes from 0 to inf
	        set(lowerBound, 0, -max);
	        set(upperBound,      max,  max);
	
	    } else if(a === Math.PI){
	
	        // y goes from 0 to inf
	        set(lowerBound, -max, 0);
	        set(upperBound,  max, max);
	
	    } else if(a === 3*Math.PI/2){
	
	        // x goes from -inf to 0
	        set(lowerBound, -max,     -max);
	        set(upperBound,  0,  max);
	
	    } else {
	
	        // Set max bounds
	        set(lowerBound, -max, -max);
	        set(upperBound,  max,  max);
	    }
	
	    vec2.add(lowerBound, lowerBound, position);
	    vec2.add(upperBound, upperBound, position);
	};
	
	Plane.prototype.updateArea = function(){
	    this.area = Number.MAX_VALUE;
	};
	
	var intersectPlane_planePointToFrom = vec2.create();
	var intersectPlane_dir_scaled_with_t = vec2.create();
	var intersectPlane_hitPoint = vec2.create();
	var intersectPlane_normal = vec2.create();
	var intersectPlane_len = vec2.create();
	
	/**
	 * @method raycast
	 * @param  {RayResult} result
	 * @param  {Ray} ray
	 * @param  {array} position
	 * @param  {number} angle
	 */
	Plane.prototype.raycast = function(result, ray, position, angle){
	    var from = ray.from;
	    var to = ray.to;
	    var direction = ray.direction;
	    var planePointToFrom = intersectPlane_planePointToFrom;
	    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;
	    var hitPoint = intersectPlane_hitPoint;
	    var normal = intersectPlane_normal;
	    var len = intersectPlane_len;
	
	    // Get plane normal
	    vec2.set(normal, 0, 1);
	    vec2.rotate(normal, normal, angle);
	
	    vec2.sub(len, from, position);
	    var planeToFrom = vec2.dot(len, normal);
	    vec2.sub(len, to, position);
	    var planeToTo = vec2.dot(len, normal);
	
	    if(planeToFrom * planeToTo > 0){
	        // "from" and "to" are on the same side of the plane... bail out
	        return;
	    }
	
	    if(vec2.squaredDistance(from, to) < planeToFrom * planeToFrom){
	        return;
	    }
	
	    var n_dot_dir = vec2.dot(normal, direction);
	
	    vec2.sub(planePointToFrom, from, position);
	    var t = -vec2.dot(normal, planePointToFrom) / n_dot_dir / ray.length;
	
	    ray.reportIntersection(result, t, normal, -1);
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var Constraint = __webpack_require__(31)
	,   Equation = __webpack_require__(8)
	,   RotationalVelocityEquation = __webpack_require__(45)
	,   RotationalLockEquation = __webpack_require__(46)
	,   vec2 = __webpack_require__(4);
	
	module.exports = RevoluteConstraint;
	
	var worldPivotA = vec2.create(),
	    worldPivotB = vec2.create(),
	    xAxis = vec2.fromValues(1,0),
	    yAxis = vec2.fromValues(0,1),
	    g = vec2.create();
	
	/**
	 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
	 * @class RevoluteConstraint
	 * @constructor
	 * @author schteppe
	 * @param {Body}    bodyA
	 * @param {Body}    bodyB
	 * @param {Object}  [options]
	 * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
	 * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
	 * @param {Array}   [options.localPivotB] See localPivotA.
	 * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
	 * @extends Constraint
	 *
	 * @example
	 *     // This will create a revolute constraint between two bodies with pivot point in between them.
	 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
	 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
	 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
	 *         worldPivot: [0, 0]
	 *     });
	 *     world.addConstraint(constraint);
	 *
	 *     // Using body-local pivot points, the constraint could have been constructed like this:
	 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
	 *         localPivotA: [1, 0],
	 *         localPivotB: [-1, 0]
	 *     });
	 */
	function RevoluteConstraint(bodyA, bodyB, options){
	    options = options || {};
	    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);
	
	    var maxForce = this.maxForce = typeof(options.maxForce) !== "undefined" ? options.maxForce : Number.MAX_VALUE;
	
	    /**
	     * @property {Array} pivotA
	     */
	    this.pivotA = vec2.create();
	
	    /**
	     * @property {Array} pivotB
	     */
	    this.pivotB = vec2.create();
	
	    if(options.worldPivot){
	        // Compute pivotA and pivotB
	        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
	        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
	        // Rotate to local coordinate system
	        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
	        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
	    } else {
	        // Get pivotA and pivotB
	        vec2.copy(this.pivotA, options.localPivotA);
	        vec2.copy(this.pivotB, options.localPivotB);
	    }
	
	    // Equations to be fed to the solver
	    var eqs = this.equations = [
	        new Equation(bodyA,bodyB,-maxForce,maxForce),
	        new Equation(bodyA,bodyB,-maxForce,maxForce),
	    ];
	
	    var x = eqs[0];
	    var y = eqs[1];
	    var that = this;
	
	    x.computeGq = function(){
	        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
	        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
	        vec2.add(g, bodyB.position, worldPivotB);
	        vec2.sub(g, g, bodyA.position);
	        vec2.sub(g, g, worldPivotA);
	        return vec2.dot(g,xAxis);
	    };
	
	    y.computeGq = function(){
	        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
	        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
	        vec2.add(g, bodyB.position, worldPivotB);
	        vec2.sub(g, g, bodyA.position);
	        vec2.sub(g, g, worldPivotA);
	        return vec2.dot(g,yAxis);
	    };
	
	    y.minForce = x.minForce = -maxForce;
	    y.maxForce = x.maxForce =  maxForce;
	
	    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);
	
	    /**
	     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.
	     * @property {Boolean} motorEnabled
	     * @readOnly
	     */
	    this.motorEnabled = false;
	
	    /**
	     * The constraint position.
	     * @property angle
	     * @type {Number}
	     * @readOnly
	     */
	    this.angle = 0;
	
	    /**
	     * Set to true to enable lower limit
	     * @property lowerLimitEnabled
	     * @type {Boolean}
	     */
	    this.lowerLimitEnabled = false;
	
	    /**
	     * Set to true to enable upper limit
	     * @property upperLimitEnabled
	     * @type {Boolean}
	     */
	    this.upperLimitEnabled = false;
	
	    /**
	     * The lower limit on the constraint angle.
	     * @property lowerLimit
	     * @type {Boolean}
	     */
	    this.lowerLimit = 0;
	
	    /**
	     * The upper limit on the constraint angle.
	     * @property upperLimit
	     * @type {Boolean}
	     */
	    this.upperLimit = 0;
	
	    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);
	    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);
	    this.upperLimitEquation.minForce = 0;
	    this.lowerLimitEquation.maxForce = 0;
	}
	RevoluteConstraint.prototype = new Constraint();
	RevoluteConstraint.prototype.constructor = RevoluteConstraint;
	
	/**
	 * Set the constraint angle limits.
	 * @method setLimits
	 * @param {number} lower Lower angle limit.
	 * @param {number} upper Upper angle limit.
	 */
	RevoluteConstraint.prototype.setLimits = function (lower, upper) {
	    if(typeof(lower) === 'number'){
	        this.lowerLimit = lower;
	        this.lowerLimitEnabled = true;
	    } else {
	        this.lowerLimit = lower;
	        this.lowerLimitEnabled = false;
	    }
	
	    if(typeof(upper) === 'number'){
	        this.upperLimit = upper;
	        this.upperLimitEnabled = true;
	    } else {
	        this.upperLimit = upper;
	        this.upperLimitEnabled = false;
	    }
	};
	
	RevoluteConstraint.prototype.update = function(){
	    var bodyA =  this.bodyA,
	        bodyB =  this.bodyB,
	        pivotA = this.pivotA,
	        pivotB = this.pivotB,
	        eqs =    this.equations,
	        normal = eqs[0],
	        tangent= eqs[1],
	        x = eqs[0],
	        y = eqs[1],
	        upperLimit = this.upperLimit,
	        lowerLimit = this.lowerLimit,
	        upperLimitEquation = this.upperLimitEquation,
	        lowerLimitEquation = this.lowerLimitEquation;
	
	    var relAngle = this.angle = bodyB.angle - bodyA.angle;
	
	    if(this.upperLimitEnabled && relAngle > upperLimit){
	        upperLimitEquation.angle = upperLimit;
	        if(eqs.indexOf(upperLimitEquation) === -1){
	            eqs.push(upperLimitEquation);
	        }
	    } else {
	        var idx = eqs.indexOf(upperLimitEquation);
	        if(idx !== -1){
	            eqs.splice(idx,1);
	        }
	    }
	
	    if(this.lowerLimitEnabled && relAngle < lowerLimit){
	        lowerLimitEquation.angle = lowerLimit;
	        if(eqs.indexOf(lowerLimitEquation) === -1){
	            eqs.push(lowerLimitEquation);
	        }
	    } else {
	        var idx = eqs.indexOf(lowerLimitEquation);
	        if(idx !== -1){
	            eqs.splice(idx,1);
	        }
	    }
	
	    /*
	
	    The constraint violation is
	
	        g = xj + rj - xi - ri
	
	    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:
	
	        gdot = vj + wj x rj - vi - wi x ri
	
	    We split this into x and y directions. (let x and y be unit vectors along the respective axes)
	
	        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
	                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
	                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
	                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
	                 = G*W
	
	    ...and similar for y. We have then identified the jacobian entries for x and y directions:
	
	        Gx = [ x   (rj x x)   -x   -(ri x x)]
	        Gy = [ y   (rj x y)   -y   -(ri x y)]
	
	     */
	
	    vec2.rotate(worldPivotA, pivotA, bodyA.angle);
	    vec2.rotate(worldPivotB, pivotB, bodyB.angle);
	
	    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc
	
	    x.G[0] = -1;
	    x.G[1] =  0;
	    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);
	    x.G[3] =  1;
	    x.G[4] =  0;
	    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);
	
	    y.G[0] =  0;
	    y.G[1] = -1;
	    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);
	    y.G[3] =  0;
	    y.G[4] =  1;
	    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);
	};
	
	/**
	 * Enable the rotational motor
	 * @method enableMotor
	 */
	RevoluteConstraint.prototype.enableMotor = function(){
	    if(this.motorEnabled){
	        return;
	    }
	    this.equations.push(this.motorEquation);
	    this.motorEnabled = true;
	};
	
	/**
	 * Disable the rotational motor
	 * @method disableMotor
	 */
	RevoluteConstraint.prototype.disableMotor = function(){
	    if(!this.motorEnabled){
	        return;
	    }
	    var i = this.equations.indexOf(this.motorEquation);
	    this.equations.splice(i,1);
	    this.motorEnabled = false;
	};
	
	/**
	 * Check if the motor is enabled.
	 * @method motorIsEnabled
	 * @deprecated use property motorEnabled instead.
	 * @return {Boolean}
	 */
	RevoluteConstraint.prototype.motorIsEnabled = function(){
	    return !!this.motorEnabled;
	};
	
	/**
	 * Set the speed of the rotational constraint motor
	 * @method setMotorSpeed
	 * @param  {Number} speed
	 */
	RevoluteConstraint.prototype.setMotorSpeed = function(speed){
	    if(!this.motorEnabled){
	        return;
	    }
	    var i = this.equations.indexOf(this.motorEquation);
	    this.equations[i].relativeVelocity = speed;
	};
	
	/**
	 * Get the speed of the rotational constraint motor
	 * @method getMotorSpeed
	 * @return {Number} The current speed, or false if the motor is not enabled.
	 */
	RevoluteConstraint.prototype.getMotorSpeed = function(){
	    if(!this.motorEnabled){
	        return false;
	    }
	    return this.motorEquation.relativeVelocity;
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var Equation = __webpack_require__(8),
	    vec2 = __webpack_require__(4);
	
	module.exports = RotationalVelocityEquation;
	
	/**
	 * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
	 *
	 * @class RotationalVelocityEquation
	 * @constructor
	 * @extends Equation
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function RotationalVelocityEquation(bodyA, bodyB){
	    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
	    this.relativeVelocity = 1;
	    this.ratio = 1;
	}
	RotationalVelocityEquation.prototype = new Equation();
	RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
	RotationalVelocityEquation.prototype.computeB = function(a,b,h){
	    var G = this.G;
	    G[2] = -1;
	    G[5] = this.ratio;
	
	    var GiMf = this.computeGiMf();
	    var GW = this.computeGW();
	    var B = - GW * b - h*GiMf;
	
	    return B;
	};


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var Equation = __webpack_require__(8),
	    vec2 = __webpack_require__(4);
	
	module.exports = RotationalLockEquation;
	
	/**
	 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
	 *
	 * @class RotationalLockEquation
	 * @constructor
	 * @extends Equation
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Object} [options]
	 * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
	 */
	function RotationalLockEquation(bodyA, bodyB, options){
	    options = options || {};
	    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
	
	    /**
	     * @property {number} angle
	     */
	    this.angle = options.angle || 0;
	
	    var G = this.G;
	    G[2] =  1;
	    G[5] = -1;
	}
	RotationalLockEquation.prototype = new Equation();
	RotationalLockEquation.prototype.constructor = RotationalLockEquation;
	
	var worldVectorA = vec2.create(),
	    worldVectorB = vec2.create(),
	    xAxis = vec2.fromValues(1,0),
	    yAxis = vec2.fromValues(0,1);
	RotationalLockEquation.prototype.computeGq = function(){
	    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);
	    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);
	    return vec2.dot(worldVectorA,worldVectorB);
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var Constraint = __webpack_require__(31)
	,   ContactEquation = __webpack_require__(7)
	,   Equation = __webpack_require__(8)
	,   vec2 = __webpack_require__(4)
	,   RotationalLockEquation = __webpack_require__(46);
	
	module.exports = PrismaticConstraint;
	
	/**
	 * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>. Also called "slider constraint".
	 *
	 * @class PrismaticConstraint
	 * @constructor
	 * @extends Constraint
	 * @author schteppe
	 * @param {Body}    bodyA
	 * @param {Body}    bodyB
	 * @param {Object}  [options]
	 * @param {Number}  [options.maxForce]                Max force to be applied by the constraint
	 * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.
	 * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.
	 * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.
	 * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.
	 * @param {Number}  [options.upperLimit]
	 * @param {Number}  [options.lowerLimit]
	 * @todo Ability to create using only a point and a worldAxis
	 */
	function PrismaticConstraint(bodyA, bodyB, options){
	    options = options || {};
	    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);
	
	    // Get anchors
	    var localAnchorA = vec2.fromValues(0,0),
	        localAxisA = vec2.fromValues(1,0),
	        localAnchorB = vec2.fromValues(0,0);
	    if(options.localAnchorA){ vec2.copy(localAnchorA, options.localAnchorA); }
	    if(options.localAxisA){ vec2.copy(localAxisA,   options.localAxisA); }
	    if(options.localAnchorB){ vec2.copy(localAnchorB, options.localAnchorB); }
	
	    /**
	     * @property localAnchorA
	     * @type {Array}
	     */
	    this.localAnchorA = localAnchorA;
	
	    /**
	     * @property localAnchorB
	     * @type {Array}
	     */
	    this.localAnchorB = localAnchorB;
	
	    /**
	     * @property localAxisA
	     * @type {Array}
	     */
	    this.localAxisA = localAxisA;
	
	    /*
	
	    The constraint violation for the common axis point is
	
	        g = ( xj + rj - xi - ri ) * t   :=  gg*t
	
	    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.
	
	        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )
	
	    Note the use of the chain rule. Now we identify the jacobian
	
	        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]
	
	    The rotational part is just a rotation lock.
	
	     */
	
	    var maxForce = this.maxForce = typeof(options.maxForce)!=="undefined" ? options.maxForce : Number.MAX_VALUE;
	
	    // Translational part
	    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);
	    var ri = new vec2.create(),
	        rj = new vec2.create(),
	        gg = new vec2.create(),
	        t =  new vec2.create();
	    trans.computeGq = function(){
	        // g = ( xj + rj - xi - ri ) * t
	        return vec2.dot(gg,t);
	    };
	    trans.updateJacobian = function(){
	        var G = this.G,
	            xi = bodyA.position,
	            xj = bodyB.position;
	        vec2.rotate(ri,localAnchorA,bodyA.angle);
	        vec2.rotate(rj,localAnchorB,bodyB.angle);
	        vec2.add(gg,xj,rj);
	        vec2.sub(gg,gg,xi);
	        vec2.sub(gg,gg,ri);
	        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);
	
	        G[0] = -t[0];
	        G[1] = -t[1];
	        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);
	        G[3] = t[0];
	        G[4] = t[1];
	        G[5] = vec2.crossLength(rj,t);
	    };
	    this.equations.push(trans);
	
	    // Rotational part
	    if(!options.disableRotationalLock){
	        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);
	        this.equations.push(rot);
	    }
	
	    /**
	     * The position of anchor A relative to anchor B, along the constraint axis.
	     * @property position
	     * @type {Number}
	     */
	    this.position = 0;
	
	    // Is this one used at all?
	    this.velocity = 0;
	
	    /**
	     * Set to true to enable lower limit.
	     * @property lowerLimitEnabled
	     * @type {Boolean}
	     */
	    this.lowerLimitEnabled = typeof(options.lowerLimit)!=="undefined" ? true : false;
	
	    /**
	     * Set to true to enable upper limit.
	     * @property upperLimitEnabled
	     * @type {Boolean}
	     */
	    this.upperLimitEnabled = typeof(options.upperLimit)!=="undefined" ? true : false;
	
	    /**
	     * Lower constraint limit. The constraint position is forced to be larger than this value.
	     * @property lowerLimit
	     * @type {Number}
	     */
	    this.lowerLimit = typeof(options.lowerLimit)!=="undefined" ? options.lowerLimit : 0;
	
	    /**
	     * Upper constraint limit. The constraint position is forced to be smaller than this value.
	     * @property upperLimit
	     * @type {Number}
	     */
	    this.upperLimit = typeof(options.upperLimit)!=="undefined" ? options.upperLimit : 1;
	
	    // Equations used for limits
	    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);
	    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);
	
	    // Set max/min forces
	    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
	    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;
	
	    /**
	     * Equation used for the motor.
	     * @property motorEquation
	     * @type {Equation}
	     */
	    this.motorEquation = new Equation(bodyA,bodyB);
	
	    /**
	     * The current motor state. Enable or disable the motor using .enableMotor
	     * @property motorEnabled
	     * @type {Boolean}
	     */
	    this.motorEnabled = false;
	
	    /**
	     * Set the target speed for the motor.
	     * @property motorSpeed
	     * @type {Number}
	     */
	    this.motorSpeed = 0;
	
	    var that = this;
	    var motorEquation = this.motorEquation;
	    var old = motorEquation.computeGW;
	    motorEquation.computeGq = function(){ return 0; };
	    motorEquation.computeGW = function(){
	        var G = this.G,
	            bi = this.bodyA,
	            bj = this.bodyB,
	            vi = bi.velocity,
	            vj = bj.velocity,
	            wi = bi.angularVelocity,
	            wj = bj.angularVelocity;
	        return this.gmult(G,vi,wi,vj,wj) + that.motorSpeed;
	    };
	}
	
	PrismaticConstraint.prototype = new Constraint();
	PrismaticConstraint.prototype.constructor = PrismaticConstraint;
	
	var worldAxisA = vec2.create(),
	    worldAnchorA = vec2.create(),
	    worldAnchorB = vec2.create(),
	    orientedAnchorA = vec2.create(),
	    orientedAnchorB = vec2.create(),
	    tmp = vec2.create();
	
	/**
	 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
	 * @method update
	 */
	PrismaticConstraint.prototype.update = function(){
	    var eqs = this.equations,
	        trans = eqs[0],
	        upperLimit = this.upperLimit,
	        lowerLimit = this.lowerLimit,
	        upperLimitEquation = this.upperLimitEquation,
	        lowerLimitEquation = this.lowerLimitEquation,
	        bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        localAxisA = this.localAxisA,
	        localAnchorA = this.localAnchorA,
	        localAnchorB = this.localAnchorB;
	
	    trans.updateJacobian();
	
	    // Transform local things to world
	    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);
	    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);
	    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);
	    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);
	    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);
	
	    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);
	
	    // Motor
	    if(this.motorEnabled){
	        // G = [ a     a x ri   -a   -a x rj ]
	        var G = this.motorEquation.G;
	        G[0] = worldAxisA[0];
	        G[1] = worldAxisA[1];
	        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);
	        G[3] = -worldAxisA[0];
	        G[4] = -worldAxisA[1];
	        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);
	    }
	
	    /*
	        Limits strategy:
	        Add contact equation, with normal along the constraint axis.
	        min/maxForce is set so the constraint is repulsive in the correct direction.
	        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.
	
	                 ^
	                 |
	      upperLimit x
	                 |    ------
	         anchorB x<---|  B |
	                 |    |    |
	        ------   |    ------
	        |    |   |
	        |  A |-->x anchorA
	        ------   |
	                 x lowerLimit
	                 |
	                axis
	     */
	
	
	    if(this.upperLimitEnabled && relPosition > upperLimit){
	        // Update contact constraint normal, etc
	        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
	        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
	        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
	        vec2.scale(tmp,worldAxisA,upperLimit);
	        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);
	        if(eqs.indexOf(upperLimitEquation) === -1){
	            eqs.push(upperLimitEquation);
	        }
	    } else {
	        var idx = eqs.indexOf(upperLimitEquation);
	        if(idx !== -1){
	            eqs.splice(idx,1);
	        }
	    }
	
	    if(this.lowerLimitEnabled && relPosition < lowerLimit){
	        // Update contact constraint normal, etc
	        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
	        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
	        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
	        vec2.scale(tmp,worldAxisA,lowerLimit);
	        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);
	        if(eqs.indexOf(lowerLimitEquation) === -1){
	            eqs.push(lowerLimitEquation);
	        }
	    } else {
	        var idx = eqs.indexOf(lowerLimitEquation);
	        if(idx !== -1){
	            eqs.splice(idx,1);
	        }
	    }
	};
	
	/**
	 * Enable the motor
	 * @method enableMotor
	 */
	PrismaticConstraint.prototype.enableMotor = function(){
	    if(this.motorEnabled){
	        return;
	    }
	    this.equations.push(this.motorEquation);
	    this.motorEnabled = true;
	};
	
	/**
	 * Disable the rotational motor
	 * @method disableMotor
	 */
	PrismaticConstraint.prototype.disableMotor = function(){
	    if(!this.motorEnabled){
	        return;
	    }
	    var i = this.equations.indexOf(this.motorEquation);
	    this.equations.splice(i,1);
	    this.motorEnabled = false;
	};
	
	/**
	 * Set the constraint limits.
	 * @method setLimits
	 * @param {number} lower Lower limit.
	 * @param {number} upper Upper limit.
	 */
	PrismaticConstraint.prototype.setLimits = function (lower, upper) {
	    if(typeof(lower) === 'number'){
	        this.lowerLimit = lower;
	        this.lowerLimitEnabled = true;
	    } else {
	        this.lowerLimit = lower;
	        this.lowerLimitEnabled = false;
	    }
	
	    if(typeof(upper) === 'number'){
	        this.upperLimit = upper;
	        this.upperLimitEnabled = true;
	    } else {
	        this.upperLimit = upper;
	        this.upperLimitEnabled = false;
	    }
	};
	


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var Utils = __webpack_require__(5)
	,   Broadphase = __webpack_require__(29);
	
	module.exports = SAPBroadphase;
	
	/**
	 * Sweep and prune broadphase along one axis.
	 *
	 * @class SAPBroadphase
	 * @constructor
	 * @extends Broadphase
	 */
	function SAPBroadphase(){
	    Broadphase.call(this,Broadphase.SAP);
	
	    /**
	     * List of bodies currently in the broadphase.
	     * @property axisList
	     * @type {Array}
	     */
	    this.axisList = [];
	
	    /**
	     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.
	     * @property axisIndex
	     * @type {Number}
	     */
	    this.axisIndex = 0;
	
	    var that = this;
	    this._addBodyHandler = function(e){
	        that.axisList.push(e.body);
	    };
	
	    this._removeBodyHandler = function(e){
	        // Remove from list
	        var idx = that.axisList.indexOf(e.body);
	        if(idx !== -1){
	            that.axisList.splice(idx,1);
	        }
	    };
	}
	SAPBroadphase.prototype = new Broadphase();
	SAPBroadphase.prototype.constructor = SAPBroadphase;
	
	/**
	 * Change the world
	 * @method setWorld
	 * @param {World} world
	 */
	SAPBroadphase.prototype.setWorld = function(world){
	    // Clear the old axis array
	    this.axisList.length = 0;
	
	    // Add all bodies from the new world
	    Utils.appendArray(this.axisList, world.bodies);
	
	    // Remove old handlers, if any
	    world
	        .off("addBody",this._addBodyHandler)
	        .off("removeBody",this._removeBodyHandler);
	
	    // Add handlers to update the list of bodies.
	    world.on("addBody",this._addBodyHandler).on("removeBody",this._removeBodyHandler);
	
	    this.world = world;
	};
	
	/**
	 * Sorts bodies along an axis.
	 * @method sortAxisList
	 * @param {Array} a
	 * @param {number} axisIndex
	 * @return {Array}
	 */
	SAPBroadphase.sortAxisList = function(a, axisIndex){
	    axisIndex = axisIndex|0;
	    for(var i=1,l=a.length; i<l; i++) {
	        var v = a[i];
	        for(var j=i - 1;j>=0;j--) {
	            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){
	                break;
	            }
	            a[j+1] = a[j];
	        }
	        a[j+1] = v;
	    }
	    return a;
	};
	
	SAPBroadphase.prototype.sortList = function(){
	    var bodies = this.axisList,
	    axisIndex = this.axisIndex;
	
	    // Sort the lists
	    SAPBroadphase.sortAxisList(bodies, axisIndex);
	};
	
	/**
	 * Get the colliding pairs
	 * @method getCollisionPairs
	 * @param  {World} world
	 * @return {Array}
	 */
	SAPBroadphase.prototype.getCollisionPairs = function(world){
	    var bodies = this.axisList,
	        result = this.result,
	        axisIndex = this.axisIndex;
	
	    result.length = 0;
	
	    // Update all AABBs if needed
	    var l = bodies.length;
	    while(l--){
	        var b = bodies[l];
	        if(b.aabbNeedsUpdate){
	            b.updateAABB();
	        }
	    }
	
	    // Sort the lists
	    this.sortList();
	
	    // Look through the X list
	    for(var i=0, N=bodies.length|0; i!==N; i++){
	        var bi = bodies[i];
	
	        for(var j=i+1; j<N; j++){
	            var bj = bodies[j];
	
	            // Bounds overlap?
	            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
	            if(!overlaps){
	                break;
	            }
	
	            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
	                result.push(bi,bj);
	            }
	        }
	    }
	
	    return result;
	};
	
	/**
	 * Returns all the bodies within an AABB.
	 * @method aabbQuery
	 * @param  {World} world
	 * @param  {AABB} aabb
	 * @param {array} result An array to store resulting bodies in.
	 * @return {array}
	 */
	SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
	    result = result || [];
	
	    this.sortList();
	
	    var axisIndex = this.axisIndex;
	    var axis = 'x';
	    if(axisIndex === 1){ axis = 'y'; }
	    if(axisIndex === 2){ axis = 'z'; }
	
	    var axisList = this.axisList;
	    var lower = aabb.lowerBound[axis];
	    var upper = aabb.upperBound[axis];
	    for(var i = 0; i < axisList.length; i++){
	        var b = axisList[i];
	
	        if(b.aabbNeedsUpdate){
	            b.updateAABB();
	        }
	
	        if(b.aabb.overlaps(aabb)){
	            result.push(b);
	        }
	    }
	
	    return result;
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4);
	var Utils = __webpack_require__(5);
	
	module.exports = Spring;
	
	/**
	 * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.
	 *
	 * @class Spring
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Object} [options]
	 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
	 * @param {number} [options.damping=1]      A number >= 0. Default: 1
	 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
	 * @param {Array}  [options.localAnchorB]
	 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
	 * @param {Array}  [options.worldAnchorB]
	 */
	function Spring(bodyA, bodyB, options){
	    options = Utils.defaults(options,{
	        stiffness: 100,
	        damping: 1,
	    });
	
	    /**
	     * Stiffness of the spring.
	     * @property stiffness
	     * @type {number}
	     */
	    this.stiffness = options.stiffness;
	
	    /**
	     * Damping of the spring.
	     * @property damping
	     * @type {number}
	     */
	    this.damping = options.damping;
	
	    /**
	     * First connected body.
	     * @property bodyA
	     * @type {Body}
	     */
	    this.bodyA = bodyA;
	
	    /**
	     * Second connected body.
	     * @property bodyB
	     * @type {Body}
	     */
	    this.bodyB = bodyB;
	}
	
	/**
	 * Apply the spring force to the connected bodies.
	 * @method applyForce
	 */
	Spring.prototype.applyForce = function(){
	    // To be implemented by subclasses
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4);
	var Utils = __webpack_require__(5);
	var Constraint = __webpack_require__(31);
	var FrictionEquation = __webpack_require__(24);
	var Body = __webpack_require__(9);
	
	module.exports = TopDownVehicle;
	
	/**
	 * @class TopDownVehicle
	 * @constructor
	 * @param {Body} chassisBody A dynamic body, already added to the world.
	 * @param {Object} [options]
	 *
	 * @example
	 *
	 *     // Create a dynamic body for the chassis
	 *     var chassisBody = new Body({
	 *         mass: 1
	 *     });
	 *     var boxShape = new Box({ width: 0.5, height: 1 });
	 *     chassisBody.addShape(boxShape);
	 *     world.addBody(chassisBody);
	 *
	 *     // Create the vehicle
	 *     var vehicle = new TopDownVehicle(chassisBody);
	 *
	 *     // Add one front wheel and one back wheel - we don't actually need four :)
	 *     var frontWheel = vehicle.addWheel({
	 *         localPosition: [0, 0.5] // front
	 *     });
	 *     frontWheel.setSideFriction(4);
	 *
	 *     // Back wheel
	 *     var backWheel = vehicle.addWheel({
	 *         localPosition: [0, -0.5] // back
	 *     });
	 *     backWheel.setSideFriction(3); // Less side friction on back wheel makes it easier to drift
	 *     vehicle.addToWorld(world);
	 *
	 *     // Steer value zero means straight forward. Positive is left and negative right.
	 *     frontWheel.steerValue = Math.PI / 16;
	 *
	 *     // Engine force forward
	 *     backWheel.engineForce = 10;
	 *     backWheel.setBrakeForce(0);
	 */
	function TopDownVehicle(chassisBody, options){
	    options = options || {};
	
	    /**
	     * @property {Body} chassisBody
	     */
	    this.chassisBody = chassisBody;
	
	    /**
	     * @property {Array} wheels
	     */
	    this.wheels = [];
	
	    // A dummy body to constrain the chassis to
	    this.groundBody = new Body({ mass: 0 });
	
	    this.world = null;
	
	    var that = this;
	    this.preStepCallback = function(){
	        that.update();
	    };
	}
	
	/**
	 * @method addToWorld
	 * @param {World} world
	 */
	TopDownVehicle.prototype.addToWorld = function(world){
	    this.world = world;
	    world.addBody(this.groundBody);
	    world.on('preStep', this.preStepCallback);
	    for (var i = 0; i < this.wheels.length; i++) {
	        var wheel = this.wheels[i];
	        world.addConstraint(wheel);
	    }
	};
	
	/**
	 * @method removeFromWorld
	 * @param {World} world
	 */
	TopDownVehicle.prototype.removeFromWorld = function(){
	    var world = this.world;
	    world.removeBody(this.groundBody);
	    world.off('preStep', this.preStepCallback);
	    for (var i = 0; i < this.wheels.length; i++) {
	        var wheel = this.wheels[i];
	        world.removeConstraint(wheel);
	    }
	    this.world = null;
	};
	
	/**
	 * @method addWheel
	 * @param {object} [wheelOptions]
	 * @return {WheelConstraint}
	 */
	TopDownVehicle.prototype.addWheel = function(wheelOptions){
	    var wheel = new WheelConstraint(this,wheelOptions);
	    this.wheels.push(wheel);
	    return wheel;
	};
	
	/**
	 * @method update
	 */
	TopDownVehicle.prototype.update = function(){
	    for (var i = 0; i < this.wheels.length; i++) {
	        this.wheels[i].update();
	    }
	};
	
	/**
	 * @class WheelConstraint
	 * @constructor
	 * @extends {Constraint}
	 * @param {Vehicle} vehicle
	 * @param {object} [options]
	 * @param {Array} [options.localForwardVector]The local wheel forward vector in local body space. Default is zero.
	 * @param {Array} [options.localPosition] The local position of the wheen in the chassis body. Default is zero - the center of the body.
	 * @param {Array} [options.sideFriction=5] The max friction force in the sideways direction.
	 */
	function WheelConstraint(vehicle, options){
	    options = options || {};
	
	    this.vehicle = vehicle;
	
	    this.forwardEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);
	
	    this.sideEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);
	
	    /**
	     * @property {number} steerValue
	     */
	    this.steerValue = 0;
	
	    /**
	     * @property {number} engineForce
	     */
	    this.engineForce = 0;
	
	    this.setSideFriction(options.sideFriction !== undefined ? options.sideFriction : 5);
	
	    /**
	     * @property {Array} localForwardVector
	     */
	    this.localForwardVector = vec2.fromValues(0, 1);
	    if(options.localForwardVector){
	        vec2.copy(this.localForwardVector, options.localForwardVector);
	    }
	
	    /**
	     * @property {Array} localPosition
	     */
	    this.localPosition = vec2.fromValues(0, 0);
	    if(options.localPosition){
	        vec2.copy(this.localPosition, options.localPosition);
	    }
	
	    Constraint.apply(this, vehicle.chassisBody, vehicle.groundBody);
	
	    this.equations.push(
	        this.forwardEquation,
	        this.sideEquation
	    );
	
	    this.setBrakeForce(0);
	}
	WheelConstraint.prototype = new Constraint();
	
	/**
	 * @method setForwardFriction
	 */
	WheelConstraint.prototype.setBrakeForce = function(force){
	    this.forwardEquation.setSlipForce(force);
	};
	
	/**
	 * @method setSideFriction
	 */
	WheelConstraint.prototype.setSideFriction = function(force){
	    this.sideEquation.setSlipForce(force);
	};
	
	var worldVelocity = vec2.create();
	var relativePoint = vec2.create();
	
	/**
	 * @method getSpeed
	 */
	WheelConstraint.prototype.getSpeed = function(){
	    this.vehicle.chassisBody.vectorToWorldFrame(relativePoint, this.localForwardVector);
	    this.vehicle.chassisBody.getVelocityAtPoint(worldVelocity, relativePoint);
	    return vec2.dot(worldVelocity, relativePoint);
	};
	
	var tmpVec = vec2.create();
	
	/**
	 * @method update
	 */
	WheelConstraint.prototype.update = function(){
	
	    // Directional
	    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector);
	    vec2.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2);
	    this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t);
	
	    vec2.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue);
	    vec2.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue);
	
	    // Attachment point
	    this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition);
	    vec2.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB);
	
	    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition);
	    vec2.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA);
	
	    // Add engine force
	    vec2.normalize(tmpVec, this.forwardEquation.t);
	    vec2.scale(tmpVec, tmpVec, this.engineForce);
	
	    this.vehicle.chassisBody.applyForce(tmpVec, this.forwardEquation.contactPointA);
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4);
	var Spring = __webpack_require__(49);
	var Utils = __webpack_require__(5);
	
	module.exports = LinearSpring;
	
	/**
	 * A spring, connecting two bodies.
	 *
	 * The Spring explicitly adds force and angularForce to the bodies.
	 *
	 * @class LinearSpring
	 * @extends Spring
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Object} [options]
	 * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
	 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
	 * @param {number} [options.damping=1]      A number >= 0. Default: 1
	 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
	 * @param {Array}  [options.worldAnchorB]
	 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
	 * @param {Array}  [options.localAnchorB]
	 */
	function LinearSpring(bodyA,bodyB,options){
	    options = options || {};
	
	    Spring.call(this, bodyA, bodyB, options);
	
	    /**
	     * Anchor for bodyA in local bodyA coordinates.
	     * @property localAnchorA
	     * @type {Array}
	     */
	    this.localAnchorA = vec2.fromValues(0,0);
	
	    /**
	     * Anchor for bodyB in local bodyB coordinates.
	     * @property localAnchorB
	     * @type {Array}
	     */
	    this.localAnchorB = vec2.fromValues(0,0);
	
	    if(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA); }
	    if(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB); }
	    if(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA); }
	    if(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB); }
	
	    var worldAnchorA = vec2.create();
	    var worldAnchorB = vec2.create();
	    this.getWorldAnchorA(worldAnchorA);
	    this.getWorldAnchorB(worldAnchorB);
	    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);
	
	    /**
	     * Rest length of the spring.
	     * @property restLength
	     * @type {number}
	     */
	    this.restLength = typeof(options.restLength) === "number" ? options.restLength : worldDistance;
	}
	LinearSpring.prototype = new Spring();
	LinearSpring.prototype.constructor = LinearSpring;
	
	/**
	 * Set the anchor point on body A, using world coordinates.
	 * @method setWorldAnchorA
	 * @param {Array} worldAnchorA
	 */
	LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA){
	    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
	};
	
	/**
	 * Set the anchor point on body B, using world coordinates.
	 * @method setWorldAnchorB
	 * @param {Array} worldAnchorB
	 */
	LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB){
	    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
	};
	
	/**
	 * Get the anchor point on body A, in world coordinates.
	 * @method getWorldAnchorA
	 * @param {Array} result The vector to store the result in.
	 */
	LinearSpring.prototype.getWorldAnchorA = function(result){
	    this.bodyA.toWorldFrame(result, this.localAnchorA);
	};
	
	/**
	 * Get the anchor point on body B, in world coordinates.
	 * @method getWorldAnchorB
	 * @param {Array} result The vector to store the result in.
	 */
	LinearSpring.prototype.getWorldAnchorB = function(result){
	    this.bodyB.toWorldFrame(result, this.localAnchorB);
	};
	
	var applyForce_r =              vec2.create(),
	    applyForce_r_unit =         vec2.create(),
	    applyForce_u =              vec2.create(),
	    applyForce_f =              vec2.create(),
	    applyForce_worldAnchorA =   vec2.create(),
	    applyForce_worldAnchorB =   vec2.create(),
	    applyForce_ri =             vec2.create(),
	    applyForce_rj =             vec2.create(),
	    applyForce_tmp =            vec2.create();
	
	/**
	 * Apply the spring force to the connected bodies.
	 * @method applyForce
	 */
	LinearSpring.prototype.applyForce = function(){
	    var k = this.stiffness,
	        d = this.damping,
	        l = this.restLength,
	        bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        r = applyForce_r,
	        r_unit = applyForce_r_unit,
	        u = applyForce_u,
	        f = applyForce_f,
	        tmp = applyForce_tmp;
	
	    var worldAnchorA = applyForce_worldAnchorA,
	        worldAnchorB = applyForce_worldAnchorB,
	        ri = applyForce_ri,
	        rj = applyForce_rj;
	
	    // Get world anchors
	    this.getWorldAnchorA(worldAnchorA);
	    this.getWorldAnchorB(worldAnchorB);
	
	    // Get offset points
	    vec2.sub(ri, worldAnchorA, bodyA.position);
	    vec2.sub(rj, worldAnchorB, bodyB.position);
	
	    // Compute distance vector between world anchor points
	    vec2.sub(r, worldAnchorB, worldAnchorA);
	    var rlen = vec2.len(r);
	    vec2.normalize(r_unit,r);
	
	    //console.log(rlen)
	    //console.log("A",vec2.str(worldAnchorA),"B",vec2.str(worldAnchorB))
	
	    // Compute relative velocity of the anchor points, u
	    vec2.sub(u, bodyB.velocity, bodyA.velocity);
	    vec2.crossZV(tmp, bodyB.angularVelocity, rj);
	    vec2.add(u, u, tmp);
	    vec2.crossZV(tmp, bodyA.angularVelocity, ri);
	    vec2.sub(u, u, tmp);
	
	    // F = - k * ( x - L ) - D * ( u )
	    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));
	
	    // Add forces to bodies
	    vec2.sub( bodyA.force, bodyA.force, f);
	    vec2.add( bodyB.force, bodyB.force, f);
	
	    // Angular force
	    var ri_x_f = vec2.crossLength(ri, f);
	    var rj_x_f = vec2.crossLength(rj, f);
	    bodyA.angularForce -= ri_x_f;
	    bodyB.angularForce += rj_x_f;
	};


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4);
	var Spring = __webpack_require__(49);
	
	module.exports = RotationalSpring;
	
	/**
	 * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
	 *
	 * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
	 *
	 * @class RotationalSpring
	 * @extends Spring
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Object} [options]
	 * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
	 * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
	 * @param {number} [options.damping=1] A number >= 0.
	 */
	function RotationalSpring(bodyA, bodyB, options){
	    options = options || {};
	
	    Spring.call(this, bodyA, bodyB, options);
	
	    /**
	     * Rest angle of the spring.
	     * @property restAngle
	     * @type {number}
	     */
	    this.restAngle = typeof(options.restAngle) === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
	}
	RotationalSpring.prototype = new Spring();
	RotationalSpring.prototype.constructor = RotationalSpring;
	
	/**
	 * Apply the spring force to the connected bodies.
	 * @method applyForce
	 */
	RotationalSpring.prototype.applyForce = function(){
	    var k = this.stiffness,
	        d = this.damping,
	        l = this.restAngle,
	        bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        x = bodyB.angle - bodyA.angle,
	        u = bodyB.angularVelocity - bodyA.angularVelocity;
	
	    var torque = - k * (x - l) - d * u * 0;
	
	    bodyA.angularForce -= torque;
	    bodyB.angularForce += torque;
	};


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var  GSSolver = __webpack_require__(36)
	,    Solver = __webpack_require__(37)
	,    Ray = __webpack_require__(19)
	,    vec2 = __webpack_require__(4)
	,    Circle = __webpack_require__(26)
	,    Convex = __webpack_require__(15)
	,    Line = __webpack_require__(39)
	,    Plane = __webpack_require__(43)
	,    Capsule = __webpack_require__(30)
	,    Particle = __webpack_require__(42)
	,    EventEmitter = __webpack_require__(21)
	,    Body = __webpack_require__(9)
	,    Shape = __webpack_require__(16)
	,    LinearSpring = __webpack_require__(51)
	,    Material = __webpack_require__(33)
	,    ContactMaterial = __webpack_require__(32)
	,    DistanceConstraint = __webpack_require__(34)
	,    Constraint = __webpack_require__(31)
	,    LockConstraint = __webpack_require__(40)
	,    RevoluteConstraint = __webpack_require__(44)
	,    PrismaticConstraint = __webpack_require__(47)
	,    GearConstraint = __webpack_require__(35)
	,    pkg = __webpack_require__(54)
	,    Broadphase = __webpack_require__(29)
	,    AABB = __webpack_require__(20)
	,    SAPBroadphase = __webpack_require__(48)
	,    Narrowphase = __webpack_require__(3)
	,    Utils = __webpack_require__(5)
	,    OverlapKeeper = __webpack_require__(55)
	,    IslandManager = __webpack_require__(58)
	,    RotationalSpring = __webpack_require__(52);
	
	module.exports = World;
	
	/**
	 * The dynamics world, where all bodies and constraints live.
	 *
	 * @class World
	 * @constructor
	 * @param {Object} [options]
	 * @param {Solver} [options.solver] Defaults to GSSolver.
	 * @param {Array} [options.gravity] Defaults to y=-9.78.
	 * @param {Broadphase} [options.broadphase] Defaults to SAPBroadphase
	 * @param {Boolean} [options.islandSplit=true]
	 * @extends EventEmitter
	 *
	 * @example
	 *     var world = new World({
	 *         gravity: [0, -10],
	 *         broadphase: new SAPBroadphase()
	 *     });
	 *     world.addBody(new Body());
	 */
	function World(options){
	    EventEmitter.apply(this);
	
	    options = options || {};
	
	    /**
	     * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
	     *
	     * @property springs
	     * @type {Array}
	     */
	    this.springs = [];
	
	    /**
	     * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
	     * @property {Array} bodies
	     */
	    this.bodies = [];
	
	    /**
	     * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
	     * @private
	     * @property {Array} disabledBodyCollisionPairs
	     */
	    this.disabledBodyCollisionPairs = [];
	
	    /**
	     * The solver used to satisfy constraints and contacts. Default is {{#crossLink "GSSolver"}}{{/crossLink}}.
	     * @property {Solver} solver
	     */
	    this.solver = options.solver || new GSSolver();
	
	    /**
	     * The narrowphase to use to generate contacts.
	     *
	     * @property narrowphase
	     * @type {Narrowphase}
	     */
	    this.narrowphase = new Narrowphase(this);
	
	    /**
	     * The island manager of this world.
	     * @property {IslandManager} islandManager
	     */
	    this.islandManager = new IslandManager();
	
	    /**
	     * Gravity in the world. This is applied on all bodies in the beginning of each step().
	     *
	     * @property gravity
	     * @type {Array}
	     */
	    this.gravity = vec2.fromValues(0, -9.78);
	    if(options.gravity){
	        vec2.copy(this.gravity, options.gravity);
	    }
	
	    /**
	     * Gravity to use when approximating the friction max force (mu*mass*gravity).
	     * @property {Number} frictionGravity
	     */
	    this.frictionGravity = vec2.length(this.gravity) || 10;
	
	    /**
	     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
	     * @property {Boolean} useWorldGravityAsFrictionGravity
	     * @default true
	     */
	    this.useWorldGravityAsFrictionGravity = true;
	
	    /**
	     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
	     * @property {Boolean} useFrictionGravityOnZeroGravity
	     * @default true
	     */
	    this.useFrictionGravityOnZeroGravity = true;
	
	    /**
	     * The broadphase algorithm to use.
	     *
	     * @property broadphase
	     * @type {Broadphase}
	     */
	    this.broadphase = options.broadphase || new SAPBroadphase();
	    this.broadphase.setWorld(this);
	
	    /**
	     * User-added constraints.
	     *
	     * @property constraints
	     * @type {Array}
	     */
	    this.constraints = [];
	
	    /**
	     * Dummy default material in the world, used in .defaultContactMaterial
	     * @property {Material} defaultMaterial
	     */
	    this.defaultMaterial = new Material();
	
	    /**
	     * The default contact material to use, if no contact material was set for the colliding materials.
	     * @property {ContactMaterial} defaultContactMaterial
	     */
	    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);
	
	    /**
	     * For keeping track of what time step size we used last step
	     * @property lastTimeStep
	     * @type {Number}
	     */
	    this.lastTimeStep = 1/60;
	
	    /**
	     * Enable to automatically apply spring forces each step.
	     * @property applySpringForces
	     * @type {Boolean}
	     * @default true
	     */
	    this.applySpringForces = true;
	
	    /**
	     * Enable to automatically apply body damping each step.
	     * @property applyDamping
	     * @type {Boolean}
	     * @default true
	     */
	    this.applyDamping = true;
	
	    /**
	     * Enable to automatically apply gravity each step.
	     * @property applyGravity
	     * @type {Boolean}
	     * @default true
	     */
	    this.applyGravity = true;
	
	    /**
	     * Enable/disable constraint solving in each step.
	     * @property solveConstraints
	     * @type {Boolean}
	     * @default true
	     */
	    this.solveConstraints = true;
	
	    /**
	     * The ContactMaterials added to the World.
	     * @property contactMaterials
	     * @type {Array}
	     */
	    this.contactMaterials = [];
	
	    /**
	     * World time.
	     * @property time
	     * @type {Number}
	     */
	    this.time = 0.0;
	    this.accumulator = 0;
	
	    /**
	     * Is true during step().
	     * @property {Boolean} stepping
	     */
	    this.stepping = false;
	
	    /**
	     * Bodies that are scheduled to be removed at the end of the step.
	     * @property {Array} bodiesToBeRemoved
	     * @private
	     */
	    this.bodiesToBeRemoved = [];
	
	    /**
	     * Whether to enable island splitting. Island splitting can be an advantage for both precision and performance. See {{#crossLink "IslandManager"}}{{/crossLink}}.
	     * @property {Boolean} islandSplit
	     * @default true
	     */
	    this.islandSplit = typeof(options.islandSplit)!=="undefined" ? !!options.islandSplit : true;
	
	    /**
	     * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
	     * @property emitImpactEvent
	     * @type {Boolean}
	     * @default true
	     */
	    this.emitImpactEvent = true;
	
	    // Id counters
	    this._constraintIdCounter = 0;
	    this._bodyIdCounter = 0;
	
	    /**
	     * Fired after the step().
	     * @event postStep
	     */
	    this.postStepEvent = {
	        type : "postStep"
	    };
	
	    /**
	     * Fired when a body is added to the world.
	     * @event addBody
	     * @param {Body} body
	     */
	    this.addBodyEvent = {
	        type : "addBody",
	        body : null
	    };
	
	    /**
	     * Fired when a body is removed from the world.
	     * @event removeBody
	     * @param {Body} body
	     */
	    this.removeBodyEvent = {
	        type : "removeBody",
	        body : null
	    };
	
	    /**
	     * Fired when a spring is added to the world.
	     * @event addSpring
	     * @param {Spring} spring
	     */
	    this.addSpringEvent = {
	        type : "addSpring",
	        spring : null
	    };
	
	    /**
	     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
	     * @event impact
	     * @param {Body} bodyA
	     * @param {Body} bodyB
	     */
	    this.impactEvent = {
	        type: "impact",
	        bodyA : null,
	        bodyB : null,
	        shapeA : null,
	        shapeB : null,
	        contactEquation : null
	    };
	
	    /**
	     * Fired after the Broadphase has collected collision pairs in the world.
	     * Inside the event handler, you can modify the pairs array as you like, to
	     * prevent collisions between objects that you don't want.
	     * @event postBroadphase
	     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
	     */
	    this.postBroadphaseEvent = {
	        type: "postBroadphase",
	        pairs: null
	    };
	
	    /**
	     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
	     * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
	     * @property sleepMode
	     * @type {number}
	     * @default World.NO_SLEEPING
	     */
	    this.sleepMode = World.NO_SLEEPING;
	
	    /**
	     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
	     * @event beginContact
	     * @param {Shape} shapeA
	     * @param {Shape} shapeB
	     * @param {Body}  bodyA
	     * @param {Body}  bodyB
	     * @param {Array} contactEquations
	     */
	    this.beginContactEvent = {
	        type: "beginContact",
	        shapeA: null,
	        shapeB: null,
	        bodyA: null,
	        bodyB: null,
	        contactEquations: []
	    };
	
	    /**
	     * Fired when two shapes stop overlapping, after the narrowphase (during step).
	     * @event endContact
	     * @param {Shape} shapeA
	     * @param {Shape} shapeB
	     * @param {Body}  bodyA
	     * @param {Body}  bodyB
	     */
	    this.endContactEvent = {
	        type: "endContact",
	        shapeA: null,
	        shapeB: null,
	        bodyA: null,
	        bodyB: null
	    };
	
	    /**
	     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
	     * @event preSolve
	     * @param {Array} contactEquations  An array of contacts to be solved.
	     * @param {Array} frictionEquations An array of friction equations to be solved.
	     */
	    this.preSolveEvent = {
	        type: "preSolve",
	        contactEquations: null,
	        frictionEquations: null
	    };
	
	    // For keeping track of overlapping shapes
	    this.overlappingShapesLastState = { keys:[] };
	    this.overlappingShapesCurrentState = { keys:[] };
	
	    /**
	     * @property {OverlapKeeper} overlapKeeper
	     */
	    this.overlapKeeper = new OverlapKeeper();
	}
	World.prototype = new Object(EventEmitter.prototype);
	World.prototype.constructor = World;
	
	/**
	 * Never deactivate bodies.
	 * @static
	 * @property {number} NO_SLEEPING
	 */
	World.NO_SLEEPING = 1;
	
	/**
	 * Deactivate individual bodies if they are sleepy.
	 * @static
	 * @property {number} BODY_SLEEPING
	 */
	World.BODY_SLEEPING = 2;
	
	/**
	 * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
	 * @static
	 * @property {number} ISLAND_SLEEPING
	 */
	World.ISLAND_SLEEPING = 4;
	
	/**
	 * Add a constraint to the simulation.
	 *
	 * @method addConstraint
	 * @param {Constraint} constraint
	 * @example
	 *     var constraint = new LockConstraint(bodyA, bodyB);
	 *     world.addConstraint(constraint);
	 */
	World.prototype.addConstraint = function(constraint){
	    this.constraints.push(constraint);
	};
	
	/**
	 * Add a ContactMaterial to the simulation.
	 * @method addContactMaterial
	 * @param {ContactMaterial} contactMaterial
	 */
	World.prototype.addContactMaterial = function(contactMaterial){
	    this.contactMaterials.push(contactMaterial);
	};
	
	/**
	 * Removes a contact material
	 *
	 * @method removeContactMaterial
	 * @param {ContactMaterial} cm
	 */
	World.prototype.removeContactMaterial = function(cm){
	    var idx = this.contactMaterials.indexOf(cm);
	    if(idx!==-1){
	        Utils.splice(this.contactMaterials,idx,1);
	    }
	};
	
	/**
	 * Get a contact material given two materials
	 * @method getContactMaterial
	 * @param {Material} materialA
	 * @param {Material} materialB
	 * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
	 * @todo Use faster hash map to lookup from material id's
	 */
	World.prototype.getContactMaterial = function(materialA,materialB){
	    var cmats = this.contactMaterials;
	    for(var i=0, N=cmats.length; i!==N; i++){
	        var cm = cmats[i];
	        if( (cm.materialA.id === materialA.id) && (cm.materialB.id === materialB.id) ||
	            (cm.materialA.id === materialB.id) && (cm.materialB.id === materialA.id) ){
	            return cm;
	        }
	    }
	    return false;
	};
	
	/**
	 * Removes a constraint
	 *
	 * @method removeConstraint
	 * @param {Constraint} constraint
	 */
	World.prototype.removeConstraint = function(constraint){
	    var idx = this.constraints.indexOf(constraint);
	    if(idx!==-1){
	        Utils.splice(this.constraints,idx,1);
	    }
	};
	
	var step_r = vec2.create(),
	    step_runit = vec2.create(),
	    step_u = vec2.create(),
	    step_f = vec2.create(),
	    step_fhMinv = vec2.create(),
	    step_velodt = vec2.create(),
	    step_mg = vec2.create(),
	    xiw = vec2.fromValues(0,0),
	    xjw = vec2.fromValues(0,0),
	    zero = vec2.fromValues(0,0),
	    interpvelo = vec2.fromValues(0,0);
	
	/**
	 * Step the physics world forward in time.
	 *
	 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
	 *
	 * @method step
	 * @param {Number} dt                       The fixed time step size to use.
	 * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
	 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
	 *
	 * @example
	 *     // Simple fixed timestepping without interpolation
	 *     var fixedTimeStep = 1 / 60;
	 *     var world = new World();
	 *     var body = new Body({ mass: 1 });
	 *     world.addBody(body);
	 *
	 *     function animate(){
	 *         requestAnimationFrame(animate);
	 *         world.step(fixedTimeStep);
	 *         renderBody(body.position, body.angle);
	 *     }
	 *
	 *     // Start animation loop
	 *     requestAnimationFrame(animate);
	 *
	 * @example
	 *     // Fixed timestepping with interpolation
	 *     var maxSubSteps = 10;
	 *     var lastTimeSeconds;
	 *
	 *     function animate(t){
	 *         requestAnimationFrame(animate);
	 *         timeSeconds = t / 1000;
	 *         lastTimeSeconds = lastTimeSeconds || timeSeconds;
	 *
	 *         deltaTime = timeSeconds - lastTimeSeconds;
	 *         world.step(fixedTimeStep, deltaTime, maxSubSteps);
	 *
	 *         renderBody(body.interpolatedPosition, body.interpolatedAngle);
	 *     }
	 *
	 *     // Start animation loop
	 *     requestAnimationFrame(animate);
	 *
	 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
	 */
	World.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){
	    maxSubSteps = maxSubSteps || 10;
	    timeSinceLastCalled = timeSinceLastCalled || 0;
	
	    if(timeSinceLastCalled === 0){ // Fixed, simple stepping
	
	        this.internalStep(dt);
	
	        // Increment time
	        this.time += dt;
	
	    } else {
	
	        this.accumulator += timeSinceLastCalled;
	        var substeps = 0;
	        while (this.accumulator >= dt && substeps < maxSubSteps) {
	            // Do fixed steps to catch up
	            this.internalStep(dt);
	            this.time += dt;
	            this.accumulator -= dt;
	            substeps++;
	        }
	
	        var t = (this.accumulator % dt) / dt;
	        for(var j=0; j!==this.bodies.length; j++){
	            var b = this.bodies[j];
	            vec2.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);
	            b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);
	        }
	    }
	};
	
	var endOverlaps = [];
	
	/**
	 * Make a fixed step.
	 * @method internalStep
	 * @param  {number} dt
	 * @private
	 */
	World.prototype.internalStep = function(dt){
	    this.stepping = true;
	
	    var that = this,
	        Nsprings = this.springs.length,
	        springs = this.springs,
	        bodies = this.bodies,
	        g = this.gravity,
	        solver = this.solver,
	        Nbodies = this.bodies.length,
	        broadphase = this.broadphase,
	        np = this.narrowphase,
	        constraints = this.constraints,
	        t0, t1,
	        fhMinv = step_fhMinv,
	        velodt = step_velodt,
	        mg = step_mg,
	        scale = vec2.scale,
	        add = vec2.add,
	        rotate = vec2.rotate,
	        islandManager = this.islandManager;
	
	    this.overlapKeeper.tick();
	
	    this.lastTimeStep = dt;
	
	    // Update approximate friction gravity.
	    if(this.useWorldGravityAsFrictionGravity){
	        var gravityLen = vec2.length(this.gravity);
	        if(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){
	            // Nonzero gravity. Use it.
	            this.frictionGravity = gravityLen;
	        }
	    }
	
	    // Add gravity to bodies
	    if(this.applyGravity){
	        for(var i=0; i!==Nbodies; i++){
	            var b = bodies[i],
	                fi = b.force;
	            if(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){
	                continue;
	            }
	            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g
	            add(fi,fi,mg);
	        }
	    }
	
	    // Add spring forces
	    if(this.applySpringForces){
	        for(var i=0; i!==Nsprings; i++){
	            var s = springs[i];
	            s.applyForce();
	        }
	    }
	
	    if(this.applyDamping){
	        for(var i=0; i!==Nbodies; i++){
	            var b = bodies[i];
	            if(b.type === Body.DYNAMIC){
	                b.applyDamping(dt);
	            }
	        }
	    }
	
	    // Broadphase
	    var result = broadphase.getCollisionPairs(this);
	
	    // Remove ignored collision pairs
	    var ignoredPairs = this.disabledBodyCollisionPairs;
	    for(var i=ignoredPairs.length-2; i>=0; i-=2){
	        for(var j=result.length-2; j>=0; j-=2){
	            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||
	                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){
	                result.splice(j,2);
	            }
	        }
	    }
	
	    // Remove constrained pairs with collideConnected == false
	    var Nconstraints = constraints.length;
	    for(i=0; i!==Nconstraints; i++){
	        var c = constraints[i];
	        if(!c.collideConnected){
	            for(var j=result.length-2; j>=0; j-=2){
	                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||
	                    (c.bodyB === result[j] && c.bodyA === result[j+1])){
	                    result.splice(j,2);
	                }
	            }
	        }
	    }
	
	    // postBroadphase event
	    this.postBroadphaseEvent.pairs = result;
	    this.emit(this.postBroadphaseEvent);
	    this.postBroadphaseEvent.pairs = null;
	
	    // Narrowphase
	    np.reset(this);
	    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){
	        var bi = result[i],
	            bj = result[i+1];
	
	        // Loop over all shapes of body i
	        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){
	            var si = bi.shapes[k],
	                xi = si.position,
	                ai = si.angle;
	
	            // All shapes of body j
	            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){
	                var sj = bj.shapes[l],
	                    xj = sj.position,
	                    aj = sj.angle;
	
	                var cm = this.defaultContactMaterial;
	                if(si.material && sj.material){
	                    var tmp = this.getContactMaterial(si.material,sj.material);
	                    if(tmp){
	                        cm = tmp;
	                    }
	                }
	
	                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);
	            }
	        }
	    }
	
	    // Wake up bodies
	    for(var i=0; i!==Nbodies; i++){
	        var body = bodies[i];
	        if(body._wakeUpAfterNarrowphase){
	            body.wakeUp();
	            body._wakeUpAfterNarrowphase = false;
	        }
	    }
	
	    // Emit end overlap events
	    if(this.has('endContact')){
	        this.overlapKeeper.getEndOverlaps(endOverlaps);
	        var e = this.endContactEvent;
	        var l = endOverlaps.length;
	        while(l--){
	            var data = endOverlaps[l];
	            e.shapeA = data.shapeA;
	            e.shapeB = data.shapeB;
	            e.bodyA = data.bodyA;
	            e.bodyB = data.bodyB;
	            this.emit(e);
	        }
	        endOverlaps.length = 0;
	    }
	
	    var preSolveEvent = this.preSolveEvent;
	    preSolveEvent.contactEquations = np.contactEquations;
	    preSolveEvent.frictionEquations = np.frictionEquations;
	    this.emit(preSolveEvent);
	    preSolveEvent.contactEquations = preSolveEvent.frictionEquations = null;
	
	    // update constraint equations
	    var Nconstraints = constraints.length;
	    for(i=0; i!==Nconstraints; i++){
	        constraints[i].update();
	    }
	
	    if(np.contactEquations.length || np.frictionEquations.length || Nconstraints){
	        if(this.islandSplit){
	            // Split into islands
	            islandManager.equations.length = 0;
	            Utils.appendArray(islandManager.equations, np.contactEquations);
	            Utils.appendArray(islandManager.equations, np.frictionEquations);
	            for(i=0; i!==Nconstraints; i++){
	                Utils.appendArray(islandManager.equations, constraints[i].equations);
	            }
	            islandManager.split(this);
	
	            for(var i=0; i!==islandManager.islands.length; i++){
	                var island = islandManager.islands[i];
	                if(island.equations.length){
	                    solver.solveIsland(dt,island);
	                }
	            }
	
	        } else {
	
	            // Add contact equations to solver
	            solver.addEquations(np.contactEquations);
	            solver.addEquations(np.frictionEquations);
	
	            // Add user-defined constraint equations
	            for(i=0; i!==Nconstraints; i++){
	                solver.addEquations(constraints[i].equations);
	            }
	
	            if(this.solveConstraints){
	                solver.solve(dt,this);
	            }
	
	            solver.removeAllEquations();
	        }
	    }
	
	    // Step forward
	    for(var i=0; i!==Nbodies; i++){
	        var body = bodies[i];
	
	        // if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){
	        body.integrate(dt);
	        // }
	    }
	
	    // Reset force
	    for(var i=0; i!==Nbodies; i++){
	        bodies[i].setZeroForce();
	    }
	
	    // Emit impact event
	    if(this.emitImpactEvent && this.has('impact')){
	        var ev = this.impactEvent;
	        for(var i=0; i!==np.contactEquations.length; i++){
	            var eq = np.contactEquations[i];
	            if(eq.firstImpact){
	                ev.bodyA = eq.bodyA;
	                ev.bodyB = eq.bodyB;
	                ev.shapeA = eq.shapeA;
	                ev.shapeB = eq.shapeB;
	                ev.contactEquation = eq;
	                this.emit(ev);
	            }
	        }
	    }
	
	    // Sleeping update
	    if(this.sleepMode === World.BODY_SLEEPING){
	        for(i=0; i!==Nbodies; i++){
	            bodies[i].sleepTick(this.time, false, dt);
	        }
	    } else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){
	
	        // Tell all bodies to sleep tick but dont sleep yet
	        for(i=0; i!==Nbodies; i++){
	            bodies[i].sleepTick(this.time, true, dt);
	        }
	
	        // Sleep islands
	        for(var i=0; i<this.islandManager.islands.length; i++){
	            var island = this.islandManager.islands[i];
	            if(island.wantsToSleep()){
	                island.sleep();
	            }
	        }
	    }
	
	    this.stepping = false;
	
	    // Remove bodies that are scheduled for removal
	    var bodiesToBeRemoved = this.bodiesToBeRemoved;
	    for(var i=0; i!==bodiesToBeRemoved.length; i++){
	        this.removeBody(bodiesToBeRemoved[i]);
	    }
	    bodiesToBeRemoved.length = 0;
	
	    this.emit(this.postStepEvent);
	};
	
	/**
	 * Runs narrowphase for the shape pair i and j.
	 * @method runNarrowphase
	 * @param  {Narrowphase} np
	 * @param  {Body} bi
	 * @param  {Shape} si
	 * @param  {Array} xi
	 * @param  {Number} ai
	 * @param  {Body} bj
	 * @param  {Shape} sj
	 * @param  {Array} xj
	 * @param  {Number} aj
	 * @param  {Number} mu
	 */
	World.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){
	
	    // Check collision groups and masks
	    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){
	        return;
	    }
	
	    // Get world position and angle of each shape
	    vec2.rotate(xiw, xi, bi.angle);
	    vec2.rotate(xjw, xj, bj.angle);
	    vec2.add(xiw, xiw, bi.position);
	    vec2.add(xjw, xjw, bj.position);
	    var aiw = ai + bi.angle;
	    var ajw = aj + bj.angle;
	
	    np.enableFriction = cm.friction > 0;
	    np.frictionCoefficient = cm.friction;
	    var reducedMass;
	    if(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){
	        reducedMass = bj.mass;
	    } else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){
	        reducedMass = bi.mass;
	    } else {
	        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);
	    }
	    np.slipForce = cm.friction*glen*reducedMass;
	    np.restitution = cm.restitution;
	    np.surfaceVelocity = cm.surfaceVelocity;
	    np.frictionStiffness = cm.frictionStiffness;
	    np.frictionRelaxation = cm.frictionRelaxation;
	    np.stiffness = cm.stiffness;
	    np.relaxation = cm.relaxation;
	    np.contactSkinSize = cm.contactSkinSize;
	    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
	
	    var resolver = np[si.type | sj.type],
	        numContacts = 0;
	    if (resolver) {
	        var sensor = si.sensor || sj.sensor;
	        var numFrictionBefore = np.frictionEquations.length;
	        if (si.type < sj.type) {
	            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);
	        } else {
	            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);
	        }
	        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
	
	        if(numContacts){
	
	            if( bi.allowSleep &&
	                bi.type === Body.DYNAMIC &&
	                bi.sleepState  === Body.SLEEPING &&
	                bj.sleepState  === Body.AWAKE &&
	                bj.type !== Body.STATIC
	            ){
	                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);
	                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
	                if(speedSquaredB >= speedLimitSquaredB*2){
	                    bi._wakeUpAfterNarrowphase = true;
	                }
	            }
	
	            if( bj.allowSleep &&
	                bj.type === Body.DYNAMIC &&
	                bj.sleepState  === Body.SLEEPING &&
	                bi.sleepState  === Body.AWAKE &&
	                bi.type !== Body.STATIC
	            ){
	                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);
	                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
	                if(speedSquaredA >= speedLimitSquaredA*2){
	                    bj._wakeUpAfterNarrowphase = true;
	                }
	            }
	
	            this.overlapKeeper.setOverlapping(bi, si, bj, sj);
	            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){
	
	                // Report new shape overlap
	                var e = this.beginContactEvent;
	                e.shapeA = si;
	                e.shapeB = sj;
	                e.bodyA = bi;
	                e.bodyB = bj;
	
	                // Reset contact equations
	                e.contactEquations.length = 0;
	
	                if(typeof(numContacts)==="number"){
	                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){
	                        e.contactEquations.push(np.contactEquations[i]);
	                    }
	                }
	
	                this.emit(e);
	            }
	
	            // divide the max friction force by the number of contacts
	            if(typeof(numContacts)==="number" && numFrictionEquations > 1){ // Why divide by 1?
	                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){
	                    var f = np.frictionEquations[i];
	                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);
	                }
	            }
	        }
	    }
	
	};
	
	/**
	 * Add a spring to the simulation
	 *
	 * @method addSpring
	 * @param {Spring} spring
	 */
	World.prototype.addSpring = function(spring){
	    this.springs.push(spring);
	    var evt = this.addSpringEvent;
	    evt.spring = spring;
	    this.emit(evt);
	    evt.spring = null;
	};
	
	/**
	 * Remove a spring
	 *
	 * @method removeSpring
	 * @param {Spring} spring
	 */
	World.prototype.removeSpring = function(spring){
	    var idx = this.springs.indexOf(spring);
	    if(idx !== -1){
	        Utils.splice(this.springs,idx,1);
	    }
	};
	
	/**
	 * Add a body to the simulation
	 *
	 * @method addBody
	 * @param {Body} body
	 *
	 * @example
	 *     var world = new World(),
	 *         body = new Body();
	 *     world.addBody(body);
	 * @todo What if this is done during step?
	 */
	World.prototype.addBody = function(body){
	    if(this.bodies.indexOf(body) === -1){
	        this.bodies.push(body);
	        body.world = this;
	        var evt = this.addBodyEvent;
	        evt.body = body;
	        this.emit(evt);
	        evt.body = null;
	    }
	};
	
	/**
	 * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.
	 *
	 * @method removeBody
	 * @param {Body} body
	 */
	World.prototype.removeBody = function(body){
	    if(this.stepping){
	        this.bodiesToBeRemoved.push(body);
	    } else {
	        body.world = null;
	        var idx = this.bodies.indexOf(body);
	        if(idx!==-1){
	            Utils.splice(this.bodies,idx,1);
	            this.removeBodyEvent.body = body;
	            body.resetConstraintVelocity();
	            this.emit(this.removeBodyEvent);
	            this.removeBodyEvent.body = null;
	        }
	    }
	};
	
	/**
	 * Get a body by its id.
	 * @method getBodyById
	 * @param {number} id
	 * @return {Body} The body, or false if it was not found.
	 */
	World.prototype.getBodyById = function(id){
	    var bodies = this.bodies;
	    for(var i=0; i<bodies.length; i++){
	        var b = bodies[i];
	        if(b.id === id){
	            return b;
	        }
	    }
	    return false;
	};
	
	/**
	 * Disable collision between two bodies
	 * @method disableBodyCollision
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	World.prototype.disableBodyCollision = function(bodyA,bodyB){
	    this.disabledBodyCollisionPairs.push(bodyA,bodyB);
	};
	
	/**
	 * Enable collisions between the given two bodies
	 * @method enableBodyCollision
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	World.prototype.enableBodyCollision = function(bodyA,bodyB){
	    var pairs = this.disabledBodyCollisionPairs;
	    for(var i=0; i<pairs.length; i+=2){
	        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){
	            pairs.splice(i,2);
	            return;
	        }
	    }
	};
	
	/**
	 * Resets the World, removes all bodies, constraints and springs.
	 *
	 * @method clear
	 */
	World.prototype.clear = function(){
	
	    this.time = 0;
	
	    // Remove all solver equations
	    if(this.solver && this.solver.equations.length){
	        this.solver.removeAllEquations();
	    }
	
	    // Remove all constraints
	    var cs = this.constraints;
	    for(var i=cs.length-1; i>=0; i--){
	        this.removeConstraint(cs[i]);
	    }
	
	    // Remove all bodies
	    var bodies = this.bodies;
	    for(var i=bodies.length-1; i>=0; i--){
	        this.removeBody(bodies[i]);
	    }
	
	    // Remove all springs
	    var springs = this.springs;
	    for(var i=springs.length-1; i>=0; i--){
	        this.removeSpring(springs[i]);
	    }
	
	    // Remove all contact materials
	    var cms = this.contactMaterials;
	    for(var i=cms.length-1; i>=0; i--){
	        this.removeContactMaterial(cms[i]);
	    }
	
	    World.apply(this);
	};
	
	var hitTest_tmp1 = vec2.create(),
	    hitTest_zero = vec2.fromValues(0,0),
	    hitTest_tmp2 = vec2.fromValues(0,0);
	
	/**
	 * Test if a world point overlaps bodies
	 * @method hitTest
	 * @param  {Array}  worldPoint  Point to use for intersection tests
	 * @param  {Array}  bodies      A list of objects to check for intersection
	 * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
	 * @return {Array}              Array of bodies that overlap the point
	 * @todo Should use an api similar to the raycast function
	 * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient
	 */
	World.prototype.hitTest = function(worldPoint,bodies,precision){
	    precision = precision || 0;
	
	    // Create a dummy particle body with a particle shape to test against the bodies
	    var pb = new Body({ position:worldPoint }),
	        ps = new Particle(),
	        px = worldPoint,
	        pa = 0,
	        x = hitTest_tmp1,
	        zero = hitTest_zero,
	        tmp = hitTest_tmp2;
	    pb.addShape(ps);
	
	    var n = this.narrowphase,
	        result = [];
	
	    // Check bodies
	    for(var i=0, N=bodies.length; i!==N; i++){
	        var b = bodies[i];
	
	        for(var j=0, NS=b.shapes.length; j!==NS; j++){
	            var s = b.shapes[j];
	
	            // Get shape world position + angle
	            vec2.rotate(x, s.position, b.angle);
	            vec2.add(x, x, b.position);
	            var a = s.angle + b.angle;
	
	            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||
	                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||
	                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||
	                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||
	                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)
	                ){
	                result.push(b);
	            }
	        }
	    }
	
	    return result;
	};
	
	/**
	 * Set the stiffness for all equations and contact materials.
	 * @method setGlobalStiffness
	 * @param {Number} stiffness
	 */
	World.prototype.setGlobalStiffness = function(stiffness){
	
	    // Set for all constraints
	    var constraints = this.constraints;
	    for(var i=0; i !== constraints.length; i++){
	        var c = constraints[i];
	        for(var j=0; j !== c.equations.length; j++){
	            var eq = c.equations[j];
	            eq.stiffness = stiffness;
	            eq.needsUpdate = true;
	        }
	    }
	
	    // Set for all contact materials
	    var contactMaterials = this.contactMaterials;
	    for(var i=0; i !== contactMaterials.length; i++){
	        var c = contactMaterials[i];
	        c.stiffness = c.frictionStiffness = stiffness;
	    }
	
	    // Set for default contact material
	    var c = this.defaultContactMaterial;
	    c.stiffness = c.frictionStiffness = stiffness;
	};
	
	/**
	 * Set the relaxation for all equations and contact materials.
	 * @method setGlobalRelaxation
	 * @param {Number} relaxation
	 */
	World.prototype.setGlobalRelaxation = function(relaxation){
	
	    // Set for all constraints
	    for(var i=0; i !== this.constraints.length; i++){
	        var c = this.constraints[i];
	        for(var j=0; j !== c.equations.length; j++){
	            var eq = c.equations[j];
	            eq.relaxation = relaxation;
	            eq.needsUpdate = true;
	        }
	    }
	
	    // Set for all contact materials
	    for(var i=0; i !== this.contactMaterials.length; i++){
	        var c = this.contactMaterials[i];
	        c.relaxation = c.frictionRelaxation = relaxation;
	    }
	
	    // Set for default contact material
	    var c = this.defaultContactMaterial;
	    c.relaxation = c.frictionRelaxation = relaxation;
	};
	
	var tmpAABB = new AABB();
	var tmpArray = [];
	
	/**
	 * Ray cast against all bodies in the world.
	 * @method raycast
	 * @param  {RaycastResult} result
	 * @param  {Ray} ray
	 * @return {boolean} True if any body was hit.
	 *
	 * @example
	 *     var ray = new Ray({
	 *         mode: Ray.CLOSEST, // or ANY
	 *         from: [0, 0],
	 *         to: [10, 0],
	 *     });
	 *     var result = new RaycastResult();
	 *     world.raycast(result, ray);
	 *
	 *     // Get the hit point
	 *     var hitPoint = vec2.create();
	 *     result.getHitPoint(hitPoint, ray);
	 *     console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
	 *
	 * @example
	 *     var ray = new Ray({
	 *         mode: Ray.ALL,
	 *         from: [0, 0],
	 *         to: [10, 0],
	 *         callback: function(result){
	 *
	 *             // Print some info about the hit
	 *             console.log('Hit body and shape: ', result.body, result.shape);
	 *
	 *             // Get the hit point
	 *             var hitPoint = vec2.create();
	 *             result.getHitPoint(hitPoint, ray);
	 *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
	 *
	 *             // If you are happy with the hits you got this far, you can stop the traversal here:
	 *             result.stop();
	 *         }
	 *     });
	 *     var result = new RaycastResult();
	 *     world.raycast(result, ray);
	 */
	World.prototype.raycast = function(result, ray){
	
	    // Get all bodies within the ray AABB
	    ray.getAABB(tmpAABB);
	    this.broadphase.aabbQuery(this, tmpAABB, tmpArray);
	    ray.intersectBodies(result, tmpArray);
	    tmpArray.length = 0;
	
	    return result.hasHit();
	};


/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = {
		"name": "p2",
		"version": "0.7.0",
		"description": "A JavaScript 2D physics engine.",
		"author": {
			"name": "Stefan Hedman",
			"email": "schteppe@gmail.com",
			"url": "http://steffe.se"
		},
		"keywords": [
			"p2.js",
			"p2",
			"physics",
			"engine",
			"2d"
		],
		"main": "./src/p2.js",
		"engines": {
			"node": "*"
		},
		"repository": {
			"type": "git",
			"url": "https://github.com/schteppe/p2.js.git"
		},
		"bugs": {
			"url": "https://github.com/schteppe/p2.js/issues"
		},
		"licenses": [
			{
				"type": "MIT"
			}
		],
		"devDependencies": {
			"grunt": "^0.4.5",
			"grunt-contrib-jshint": "^0.11.2",
			"grunt-contrib-nodeunit": "^0.4.1",
			"grunt-contrib-uglify": "~0.4.0",
			"grunt-contrib-watch": "~0.5.0",
			"grunt-browserify": "~2.0.1",
			"grunt-contrib-concat": "^0.4.0"
		},
		"dependencies": {
			"poly-decomp": "0.1.0"
		},
		"homepage": "https://github.com/schteppe/p2.js",
		"_id": "p2@0.7.0",
		"dist": {
			"shasum": "9c22688084944705a2e8dedb98d7629364572e6b",
			"tarball": "http://registry.npmjs.org/p2/-/p2-0.7.0.tgz"
		},
		"_from": "p2@*",
		"_npmVersion": "1.4.3",
		"_npmUser": {
			"name": "schteppe",
			"email": "schteppe@gmail.com"
		},
		"maintainers": [
			{
				"name": "schteppe",
				"email": "schteppe@gmail.com"
			}
		],
		"directories": {},
		"_shasum": "9c22688084944705a2e8dedb98d7629364572e6b",
		"_resolved": "https://registry.npmjs.org/p2/-/p2-0.7.0.tgz"
	}

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var TupleDictionary = __webpack_require__(25);
	var OverlapKeeperRecord = __webpack_require__(56);
	var OverlapKeeperRecordPool = __webpack_require__(57);
	var Utils = __webpack_require__(5);
	
	module.exports = OverlapKeeper;
	
	/**
	 * Keeps track of overlaps in the current state and the last step state.
	 * @class OverlapKeeper
	 * @constructor
	 */
	function OverlapKeeper() {
	    this.overlappingShapesLastState = new TupleDictionary();
	    this.overlappingShapesCurrentState = new TupleDictionary();
	    this.recordPool = new OverlapKeeperRecordPool({ size: 16 });
	    this.tmpDict = new TupleDictionary();
	    this.tmpArray1 = [];
	}
	
	/**
	 * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
	 * @method tick
	 */
	OverlapKeeper.prototype.tick = function() {
	    var last = this.overlappingShapesLastState;
	    var current = this.overlappingShapesCurrentState;
	
	    // Save old objects into pool
	    var l = last.keys.length;
	    while(l--){
	        var key = last.keys[l];
	        var lastObject = last.getByKey(key);
	        var currentObject = current.getByKey(key);
	        if(lastObject){
	            // The record is only used in the "last" dict, and will be removed. We might as well pool it.
	            this.recordPool.release(lastObject);
	        }
	    }
	
	    // Clear last object
	    last.reset();
	
	    // Transfer from new object to old
	    last.copy(current);
	
	    // Clear current object
	    current.reset();
	};
	
	/**
	 * @method setOverlapping
	 * @param {Body} bodyA
	 * @param {Body} shapeA
	 * @param {Body} bodyB
	 * @param {Body} shapeB
	 */
	OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
	    var last = this.overlappingShapesLastState;
	    var current = this.overlappingShapesCurrentState;
	
	    // Store current contact state
	    if(!current.get(shapeA.id, shapeB.id)){
	        var data = this.recordPool.get();
	        data.set(bodyA, shapeA, bodyB, shapeB);
	        current.set(shapeA.id, shapeB.id, data);
	    }
	};
	
	OverlapKeeper.prototype.getNewOverlaps = function(result){
	    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
	};
	
	OverlapKeeper.prototype.getEndOverlaps = function(result){
	    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
	};
	
	/**
	 * Checks if two bodies are currently overlapping.
	 * @method bodiesAreOverlapping
	 * @param  {Body} bodyA
	 * @param  {Body} bodyB
	 * @return {boolean}
	 */
	OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB){
	    var current = this.overlappingShapesCurrentState;
	    var l = current.keys.length;
	    while(l--){
	        var key = current.keys[l];
	        var data = current.data[key];
	        if((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){
	            return true;
	        }
	    }
	    return false;
	};
	
	OverlapKeeper.prototype.getDiff = function(dictA, dictB, result){
	    var result = result || [];
	    var last = dictA;
	    var current = dictB;
	
	    result.length = 0;
	
	    var l = current.keys.length;
	    while(l--){
	        var key = current.keys[l];
	        var data = current.data[key];
	
	        if(!data){
	            throw new Error('Key '+key+' had no data!');
	        }
	
	        var lastData = last.data[key];
	        if(!lastData){
	            // Not overlapping in last state, but in current.
	            result.push(data);
	        }
	    }
	
	    return result;
	};
	
	OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){
	    var idA = shapeA.id|0,
	        idB = shapeB.id|0;
	    var last = this.overlappingShapesLastState;
	    var current = this.overlappingShapesCurrentState;
	    // Not in last but in new
	    return !!!last.get(idA, idB) && !!current.get(idA, idB);
	};
	
	OverlapKeeper.prototype.getNewBodyOverlaps = function(result){
	    this.tmpArray1.length = 0;
	    var overlaps = this.getNewOverlaps(this.tmpArray1);
	    return this.getBodyDiff(overlaps, result);
	};
	
	OverlapKeeper.prototype.getEndBodyOverlaps = function(result){
	    this.tmpArray1.length = 0;
	    var overlaps = this.getEndOverlaps(this.tmpArray1);
	    return this.getBodyDiff(overlaps, result);
	};
	
	OverlapKeeper.prototype.getBodyDiff = function(overlaps, result){
	    result = result || [];
	    var accumulator = this.tmpDict;
	
	    var l = overlaps.length;
	
	    while(l--){
	        var data = overlaps[l];
	
	        // Since we use body id's for the accumulator, these will be a subset of the original one
	        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);
	    }
	
	    l = accumulator.keys.length;
	    while(l--){
	        var data = accumulator.getByKey(accumulator.keys[l]);
	        if(data){
	            result.push(data.bodyA, data.bodyB);
	        }
	    }
	
	    accumulator.reset();
	
	    return result;
	};


/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = OverlapKeeperRecord;
	
	/**
	 * Overlap data container for the OverlapKeeper
	 * @class OverlapKeeperRecord
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Shape} shapeA
	 * @param {Body} bodyB
	 * @param {Shape} shapeB
	 */
	function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){
	    /**
	     * @property {Shape} shapeA
	     */
	    this.shapeA = shapeA;
	    /**
	     * @property {Shape} shapeB
	     */
	    this.shapeB = shapeB;
	    /**
	     * @property {Body} bodyA
	     */
	    this.bodyA = bodyA;
	    /**
	     * @property {Body} bodyB
	     */
	    this.bodyB = bodyB;
	}
	
	/**
	 * Set the data for the record
	 * @method set
	 * @param {Body} bodyA
	 * @param {Shape} shapeA
	 * @param {Body} bodyB
	 * @param {Shape} shapeB
	 */
	OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){
	    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
	};


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var OverlapKeeperRecord = __webpack_require__(56);
	var Pool = __webpack_require__(22);
	
	module.exports = OverlapKeeperRecordPool;
	
	/**
	 * @class
	 */
	function OverlapKeeperRecordPool() {
		Pool.apply(this, arguments);
	}
	OverlapKeeperRecordPool.prototype = new Pool();
	OverlapKeeperRecordPool.prototype.constructor = OverlapKeeperRecordPool;
	
	/**
	 * @method create
	 * @return {OverlapKeeperRecord}
	 */
	OverlapKeeperRecordPool.prototype.create = function () {
		return new OverlapKeeperRecord();
	};
	
	/**
	 * @method destroy
	 * @param {OverlapKeeperRecord} record
	 * @return {OverlapKeeperRecordPool}
	 */
	OverlapKeeperRecordPool.prototype.destroy = function (record) {
		record.bodyA = record.bodyB = record.shapeA = record.shapeB = null;
		return this;
	};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(4)
	,   Island = __webpack_require__(61)
	,   IslandNode = __webpack_require__(60)
	,   IslandNodePool = __webpack_require__(59)
	,   IslandPool = __webpack_require__(62)
	,   Body = __webpack_require__(9);
	
	module.exports = IslandManager;
	
	/**
	 * Splits the system of bodies and equations into independent islands
	 *
	 * @class IslandManager
	 * @constructor
	 * @param {Object} [options]
	 * @extends Solver
	 */
	function IslandManager(options){
	
	    /**
	     * @property nodePool
	     * @type {IslandNodePool}
	     */
	    this.nodePool = new IslandNodePool({ size: 16 });
	
	    /**
	     * @property islandPool
	     * @type {IslandPool}
	     */
	    this.islandPool = new IslandPool({ size: 8 });
	
	    /**
	     * The equations to split. Manually fill this array before running .split().
	     * @property {Array} equations
	     */
	    this.equations = [];
	
	    /**
	     * The resulting {{#crossLink "Island"}}{{/crossLink}}s.
	     * @property {Array} islands
	     */
	    this.islands = [];
	
	    /**
	     * The resulting graph nodes.
	     * @property {Array} nodes
	     */
	    this.nodes = [];
	
	    /**
	     * The node queue, used when traversing the graph of nodes.
	     * @private
	     * @property {Array} queue
	     */
	    this.queue = [];
	}
	
	/**
	 * Get an unvisited node from a list of nodes.
	 * @static
	 * @method getUnvisitedNode
	 * @param  {Array} nodes
	 * @return {IslandNode|boolean} The node if found, else false.
	 */
	IslandManager.getUnvisitedNode = function(nodes){
	    var Nnodes = nodes.length;
	    for(var i=0; i!==Nnodes; i++){
	        var node = nodes[i];
	        if(!node.visited && node.body.type === Body.DYNAMIC){
	            return node;
	        }
	    }
	    return false;
	};
	
	/**
	 * Visit a node.
	 * @method visit
	 * @param  {IslandNode} node
	 * @param  {Array} bds
	 * @param  {Array} eqs
	 */
	IslandManager.prototype.visit = function (node,bds,eqs){
	    bds.push(node.body);
	    var Neqs = node.equations.length;
	    for(var i=0; i!==Neqs; i++){
	        var eq = node.equations[i];
	        if(eqs.indexOf(eq) === -1){ // Already added?
	            eqs.push(eq);
	        }
	    }
	};
	
	/**
	 * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.
	 * @method bfs
	 * @param  {IslandNode} root The node to start from
	 * @param  {Array} bds  An array to append resulting Bodies to.
	 * @param  {Array} eqs  An array to append resulting Equations to.
	 */
	IslandManager.prototype.bfs = function(root,bds,eqs){
	
	    // Reset the visit queue
	    var queue = this.queue;
	    queue.length = 0;
	
	    // Add root node to queue
	    queue.push(root);
	    root.visited = true;
	    this.visit(root,bds,eqs);
	
	    // Process all queued nodes
	    while(queue.length) {
	
	        // Get next node in the queue
	        var node = queue.pop();
	
	        // Visit unvisited neighboring nodes
	        var child;
	        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {
	            child.visited = true;
	            this.visit(child,bds,eqs);
	
	            // Only visit the children of this node if it's dynamic
	            if(child.body.type === Body.DYNAMIC){
	                queue.push(child);
	            }
	        }
	    }
	};
	
	/**
	 * Split the world into independent islands. The result is stored in .islands.
	 * @method split
	 * @param  {World} world
	 * @return {Array} The generated islands
	 */
	IslandManager.prototype.split = function(world){
	    var bodies = world.bodies,
	        nodes = this.nodes,
	        equations = this.equations;
	
	    // Move old nodes to the node pool
	    while(nodes.length){
	        this.nodePool.release(nodes.pop());
	    }
	
	    // Create needed nodes, reuse if possible
	    for(var i=0; i!==bodies.length; i++){
	        var node = this.nodePool.get();
	        node.body = bodies[i];
	        nodes.push(node);
	        // if(this.nodePool.length){
	        //     var node = this.nodePool.pop();
	        //     node.reset();
	        //     node.body = bodies[i];
	        //     nodes.push(node);
	        // } else {
	        //     nodes.push(new IslandNode(bodies[i]));
	        // }
	    }
	
	    // Add connectivity data. Each equation connects 2 bodies.
	    for(var k=0; k!==equations.length; k++){
	        var eq=equations[k],
	            i=bodies.indexOf(eq.bodyA),
	            j=bodies.indexOf(eq.bodyB),
	            ni=nodes[i],
	            nj=nodes[j];
	        ni.neighbors.push(nj);
	        nj.neighbors.push(ni);
	        ni.equations.push(eq);
	        nj.equations.push(eq);
	    }
	
	    // Move old islands to the island pool
	    var islands = this.islands;
	    for(var i=0; i<islands.length; i++){
	        this.islandPool.release(islands[i]);
	    }
	    islands.length = 0;
	
	    // Get islands
	    var child;
	    while((child = IslandManager.getUnvisitedNode(nodes))){
	
	        // Create new island
	        var island = this.islandPool.get();
	
	        // Get all equations and bodies in this island
	        this.bfs(child, island.bodies, island.equations);
	
	        islands.push(island);
	    }
	
	    return islands;
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var IslandNode = __webpack_require__(60);
	var Pool = __webpack_require__(22);
	
	module.exports = IslandNodePool;
	
	/**
	 * @class
	 */
	function IslandNodePool() {
		Pool.apply(this, arguments);
	}
	IslandNodePool.prototype = new Pool();
	IslandNodePool.prototype.constructor = IslandNodePool;
	
	/**
	 * @method create
	 * @return {IslandNode}
	 */
	IslandNodePool.prototype.create = function () {
		return new IslandNode();
	};
	
	/**
	 * @method destroy
	 * @param {IslandNode} node
	 * @return {IslandNodePool}
	 */
	IslandNodePool.prototype.destroy = function (node) {
		node.reset();
		return this;
	};


/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports = IslandNode;
	
	/**
	 * Holds a body and keeps track of some additional properties needed for graph traversal.
	 * @class IslandNode
	 * @constructor
	 * @param {Body} body
	 */
	function IslandNode(body){
	
		/**
		 * The body that is contained in this node.
		 * @property {Body} body
		 */
	    this.body = body;
	
	    /**
	     * Neighboring IslandNodes
	     * @property {Array} neighbors
	     */
	    this.neighbors = [];
	
	    /**
	     * Equations connected to this node.
	     * @property {Array} equations
	     */
	    this.equations = [];
	
	    /**
	     * If this node was visiting during the graph traversal.
	     * @property visited
	     * @type {Boolean}
	     */
	    this.visited = false;
	}
	
	/**
	 * Clean this node from bodies and equations.
	 * @method reset
	 */
	IslandNode.prototype.reset = function(){
	    this.equations.length = 0;
	    this.neighbors.length = 0;
	    this.visited = false;
	    this.body = null;
	};


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var Body = __webpack_require__(9);
	
	module.exports = Island;
	
	/**
	 * An island of bodies connected with equations.
	 * @class Island
	 * @constructor
	 */
	function Island(){
	
	    /**
	     * Current equations in this island.
	     * @property equations
	     * @type {Array}
	     */
	    this.equations = [];
	
	    /**
	     * Current bodies in this island.
	     * @property bodies
	     * @type {Array}
	     */
	    this.bodies = [];
	}
	
	/**
	 * Clean this island from bodies and equations.
	 * @method reset
	 */
	Island.prototype.reset = function(){
	    this.equations.length = this.bodies.length = 0;
	};
	
	var bodyIds = [];
	
	/**
	 * Get all unique bodies in this island.
	 * @method getBodies
	 * @return {Array} An array of Body
	 */
	Island.prototype.getBodies = function(result){
	    var bodies = result || [],
	        eqs = this.equations;
	    bodyIds.length = 0;
	    for(var i=0; i!==eqs.length; i++){
	        var eq = eqs[i];
	        if(bodyIds.indexOf(eq.bodyA.id)===-1){
	            bodies.push(eq.bodyA);
	            bodyIds.push(eq.bodyA.id);
	        }
	        if(bodyIds.indexOf(eq.bodyB.id)===-1){
	            bodies.push(eq.bodyB);
	            bodyIds.push(eq.bodyB.id);
	        }
	    }
	    return bodies;
	};
	
	/**
	 * Check if the entire island wants to sleep.
	 * @method wantsToSleep
	 * @return {Boolean}
	 */
	Island.prototype.wantsToSleep = function(){
	    for(var i=0; i<this.bodies.length; i++){
	        var b = this.bodies[i];
	        if(b.type === Body.DYNAMIC && !b.wantsToSleep){
	            return false;
	        }
	    }
	    return true;
	};
	
	/**
	 * Make all bodies in the island sleep.
	 * @method sleep
	 */
	Island.prototype.sleep = function(){
	    for(var i=0; i<this.bodies.length; i++){
	        var b = this.bodies[i];
	        b.sleep();
	    }
	    return true;
	};


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var Island = __webpack_require__(61);
	var Pool = __webpack_require__(22);
	
	module.exports = IslandPool;
	
	/**
	 * @class
	 */
	function IslandPool() {
		Pool.apply(this, arguments);
	}
	IslandPool.prototype = new Pool();
	IslandPool.prototype.constructor = IslandPool;
	
	/**
	 * @method create
	 * @return {Island}
	 */
	IslandPool.prototype.create = function () {
		return new Island();
	};
	
	/**
	 * @method destroy
	 * @param {Island} island
	 * @return {IslandPool}
	 */
	IslandPool.prototype.destroy = function (island) {
		island.reset();
		return this;
	};


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {//THREE imported globally in webpack.config.js:25
	var animator_1 = __webpack_require__(66);
	var end_1 = __webpack_require__(67);
	var shaders_1 = __webpack_require__(69);
	__webpack_require__(70);
	__webpack_require__(71);
	__webpack_require__(65);
	__webpack_require__(72);
	__webpack_require__(73);
	__webpack_require__(74);
	__webpack_require__(75);
	var Display3D = (function () {
	    function Display3D() {
	        var _this = this;
	        this.resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
	        this.scene = new THREE.Scene();
	        this.cameraRadius = 10;
	        this.camera = new THREE.PerspectiveCamera(75, this.resolution.x / this.resolution.y, 1, 1000);
	        this.camera.position.y = Display3D.scale * 2.5;
	        this.renderer = new THREE.WebGLRenderer({ precision: "lowp" });
	        this.renderer.setPixelRatio(window.devicePixelRatio);
	        this.renderer.setSize(this.resolution.x, this.resolution.y);
	        this.renderer.setClearColor(0xffffff);
	        this.scene.fog = new THREE.FogExp2(0xffffff, 0.004);
	        document.body.appendChild(this.renderer.domElement);
	        window.addEventListener('resize', function () {
	            _this.resolution.set(window.innerWidth, window.innerHeight);
	            _this.camera.aspect = _this.resolution.x / _this.resolution.y;
	            _this.camera.updateProjectionMatrix();
	            _this.renderer.setSize(_this.resolution.x, _this.resolution.y);
	        }, false);
	        this.mazeHolder = new THREE.Object3D();
	        this.scene.add(this.mazeHolder);
	        this.scene.add(new THREE.AmbientLight(0x999999));
	        this.animator = new animator_1.Animator();
	        this.glitch = false;
	        this.initSpaceMaterial();
	        this.initPlayer();
	        this.initProtoGalaxy();
	        this.initGlitch();
	        this.initMorphingSphere();
	    }
	    Display3D.prototype.initShadowLight = function () {
	        this.renderer.shadowMapEnabled = true;
	        this.renderer.shadowMapType = THREE.PCFShadowMap;
	        var shadowLight = new THREE.DirectionalLight(0, 1);
	        shadowLight.position.set(this.player.position.x, 50 * Display3D.scale, this.player.position.z);
	        shadowLight.castShadow = true;
	        shadowLight.onlyShadow = true;
	        shadowLight.shadowDarkness = .25;
	        shadowLight.shadowMapWidth = 512;
	        shadowLight.shadowMapHeight = 512;
	        shadowLight.target = this.player;
	        this.scene.add(shadowLight);
	    };
	    Display3D.prototype.initSpaceMaterial = function () {
	        this.spaceMaterial = new THREE.ShaderMaterial({
	            vertexShader: shaders_1.spaceVertexShader,
	            fragmentShader: shaders_1.spaceFragmentShader,
	            uniforms: {
	                iResolution: { type: 'v2', value: this.resolution },
	                iGlobalTime: { type: 'f', value: 0 },
	                fogDensity: { type: "f", value: 0 },
	                fogColor: { type: "c", value: new THREE.Vector3() },
	            },
	            fog: true
	        });
	    };
	    Display3D.prototype.initPlayer = function () {
	        var _this = this;
	        var playerSphere = new THREE.Mesh(new THREE.SphereGeometry(Display3D.scale / 8, 16, 16), this.spaceMaterial);
	        this.player = new THREE.Object3D();
	        this.player.position.y = 0;
	        this.player.add(playerSphere);
	        this.scene.add(this.player);
	        this.finalHead = new end_1.HeadObject();
	        this.finalHead.load().then(function () {
	            _this.finalHead.lowpoly(6);
	            _this.finalHead.colorize();
	            var meshGeometry = new THREE.OctahedronGeometry(2.33, 0);
	            meshGeometry.morphTargets.push({ name: "head", vertices: _this.finalHead.getMorphTargets(meshGeometry.vertices.length) });
	            _this.playerWire = new THREE.Mesh(meshGeometry, new THREE.MeshBasicMaterial({ color: 0, wireframe: true, morphTargets: true }));
	            _this.playerWire.scale.set(Display3D.scale / 7, Display3D.scale / 7, Display3D.scale / 7);
	            _this.player.add(_this.playerWire);
	            _this.finalHead.mesh.scale.set(Display3D.scale / 7, Display3D.scale / 7, Display3D.scale / 7);
	            _this.animator.play({
	                func: function (dt) {
	                    _this.player.position.y = Math.sin(dt * Math.PI * 2) * Display3D.scale / 16;
	                    _this.playerWire.rotation.z = dt * Math.PI;
	                },
	                duration: 2500,
	                loop: true,
	                object: _this.player
	            });
	        });
	    };
	    Display3D.prototype.addEnvironment = function (w, h) {
	        var plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(w * Display3D.scale, h * Display3D.scale), new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
	        plane.rotation.x = Math.PI / 2;
	        plane.position.x = w * Display3D.scale / 2 - Display3D.scale / 2;
	        plane.position.z = h * Display3D.scale / 2 - Display3D.scale / 2;
	        plane.position.y = -Display3D.scale / 2;
	        this.mazeHolder.add(plane);
	        this.initDust(w, h);
	    };
	    Display3D.prototype.addWall = function (x, y) {
	        var wallMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, shading: THREE.FlatShading });
	        var curWall = new THREE.Mesh(new THREE.BoxGeometry(Display3D.scale, Display3D.scale, Display3D.scale), wallMaterial);
	        curWall.position.x = x * Display3D.scale;
	        curWall.position.z = y * Display3D.scale;
	        this.mazeHolder.add(curWall);
	        return curWall;
	    };
	    Display3D.prototype.moveObject = function (displayObj, physObj) {
	        displayObj.position.x = physObj.position[0] * Display3D.scale;
	        displayObj.position.z = physObj.position[1] * Display3D.scale;
	        displayObj.rotation.y = -physObj.angle;
	    };
	    Display3D.prototype.moveCamera = function (q, up) {
	        if (up && this.cameraRadius < 3)
	            this.cameraRadius += .0025;
	        if (!up && this.cameraRadius > 2)
	            this.cameraRadius -= .01;
	        if (this.cameraRadius > 3.01)
	            this.cameraRadius -= .05;
	        this.camera.position.x = this.player.position.x - Math.cos(q) * Display3D.scale * this.cameraRadius;
	        this.camera.position.z = this.player.position.z - Math.sin(q) * Display3D.scale * this.cameraRadius;
	        this.camera.position.y = Display3D.scale * (this.cameraRadius + .5);
	        this.camera.lookAt(new THREE.Vector3(this.player.position.x, Display3D.scale * 1.25, this.player.position.z));
	    };
	    Display3D.prototype.finalCameraMove = function (t, q) {
	        var _this = this;
	        var y = Display3D.scale * (this.cameraRadius + .5);
	        var y2 = Display3D.scale * 1.25;
	        return this.animator.play({
	            func: function (dt) {
	                _this.cameraRadius = dt + 2;
	                _this.camera.position.x = _this.player.position.x - Math.cos(q * (1 - dt)) * Display3D.scale * _this.cameraRadius;
	                _this.camera.position.z = _this.player.position.z - Math.sin(q * (1 - dt)) * Display3D.scale * _this.cameraRadius;
	                _this.camera.position.y = y * (1 - dt);
	                _this.camera.lookAt(new THREE.Vector3(_this.player.position.x, y2 * (1 - dt), _this.player.position.z));
	            },
	            duration: t
	        });
	    };
	    Display3D.prototype.initProtoGalaxy = function () {
	        this.protoGalaxy = new THREE.Mesh(new THREE.SphereGeometry(Display3D.scale / 1.25, 16, 16), this.spaceMaterial);
	    };
	    Display3D.prototype.initGlitch = function () {
	        this.glitchComposer = new THREE.EffectComposer(this.renderer);
	        this.glitchComposer.addPass(new THREE.RenderPass(this.scene, this.camera));
	        var glitchPass = new THREE.GlitchPass();
	        glitchPass.renderToScreen = true;
	        glitchPass.goWild = true;
	        this.glitchComposer.addPass(glitchPass);
	    };
	    Display3D.prototype.glitchMe = function (dt) {
	        var _this = this;
	        this.glitch = true;
	        return this.animator.play({
	            duration: dt,
	            func: function (dt) { _this.glitch = false; },
	            timer: true
	        });
	    };
	    Display3D.prototype.createGalaxy = function (pos) {
	        var _this = this;
	        var material = new THREE.LineBasicMaterial({
	            color: 0x666666,
	            linewidth: 1,
	            fog: true
	        });
	        var geometry = new THREE.Geometry();
	        for (var i = 0; i < 20; i++) {
	            var a = Math.random() * Math.PI;
	            var b = Math.random() * Math.PI;
	            var s1 = Math.random() * Display3D.scale / 10;
	            var s2 = (Math.random() + .5) * Display3D.scale;
	            geometry.vertices.push((new THREE.Vector3()).fromArray(sphericalTo3d(a, b, s1)), (new THREE.Vector3()).fromArray(sphericalTo3d(a, b, s2)));
	        }
	        var lines = new THREE.Line(geometry, material, THREE.LinePieces);
	        lines.position.set(pos.x, pos.y, pos.z);
	        this.scene.add(lines);
	        var g = this.protoGalaxy.clone();
	        g.position.set(pos.x, pos.y, pos.z);
	        this.mazeHolder.add(g);
	        return {
	            animation: this.animator.play({
	                func: function (dt) {
	                    var ql = dt * 50 + 1;
	                    lines.scale.set(ql, ql, ql);
	                    var qg = dt * dt * dt;
	                    g.scale.set(qg, qg, qg);
	                    if (dt > .5)
	                        _this.glitch = true;
	                },
	                duration: 2000 })
	                .then(function () {
	                _this.scene.remove(lines);
	                _this.glitch = false;
	            }),
	            view: g
	        };
	    };
	    Display3D.prototype.initDust = function (w, h) {
	        this.dustGeometry = new THREE.Geometry();
	        for (var i = 0; i < w * h; i++)
	            this.dustGeometry.vertices.push(new THREE.Vector3(Math.random() * (w + 6) * Display3D.scale - Display3D.scale * 3, Math.random() * 6 * Display3D.scale - Display3D.scale * 3, Math.random() * (h + 6) * Display3D.scale - Display3D.scale * 3));
	        this.dustMaterial = new THREE.PointCloudMaterial({
	            size: 1, color: 0xaaaaaa, fog: true });
	        this.moreDust();
	    };
	    Display3D.prototype.moreDust = function () {
	        var p = [];
	        for (var i1 = 0; i1 < 5; i1++)
	            p[i1] = (Math.random() - .5) * Display3D.scale * 6;
	        var body = new THREE.PointCloud(this.dustGeometry, this.dustMaterial);
	        var v1 = new THREE.Vector3(p[0], Display3D.scale * 6, p[1]);
	        var v2 = new THREE.Vector3(p[2], p[3], p[4]);
	        body.position.copy(v1);
	        this.mazeHolder.add(body);
	        var changeSpeed = 5000 + 30000 * Math.random();
	        this.animator.play({
	            func: function (dt) {
	                var v = new THREE.Vector3();
	                var dtEasing = -2 * dt * dt * (2 * dt - 3) / 2;
	                v.subVectors(v2, v1).multiplyScalar(dtEasing).add(v1);
	                body.position.copy(v);
	            },
	            duration: changeSpeed,
	            loop: true
	        });
	        this.animator.play({
	            func: function (_) {
	                v1.copy(v2);
	                v2.set((Math.random() - .5) * Display3D.scale * 6, (Math.random() - .5) * Display3D.scale * 6, (Math.random() - .5) * Display3D.scale * 6);
	            },
	            duration: changeSpeed,
	            loop: true,
	            timer: true
	        });
	    };
	    Display3D.prototype.generateSphere = function (vertices, ilen, klen, rr) {
	        for (var i = 0; i < ilen; i++)
	            for (var k = 0; k < klen; k++) {
	                var i1 = i == ilen - 1 ? 0 : i + 1;
	                var k1 = k == klen - 1 ? 0 : k + 1;
	                var q1 = i / ilen * Math.PI * 2;
	                var q2 = k / klen * Math.PI;
	                var q3 = i1 / ilen * Math.PI * 2;
	                var q4 = k1 / klen * Math.PI;
	                var v1 = sphericalTo3d(q1, q2, rr[i + k * ilen]);
	                var v2 = sphericalTo3d(q3, q2, rr[i1 + k * ilen]);
	                var v3 = sphericalTo3d(q1, q4, rr[i + k1 * ilen]);
	                var v4 = sphericalTo3d(q3, q4, rr[i1 + k1 * ilen]);
	                var offset = (k * ilen + i) * 6 * 3;
	                copy3array(vertices, offset, v3);
	                copy3array(vertices, offset + 3, v2);
	                copy3array(vertices, offset + 6, v1);
	                copy3array(vertices, offset + 9, v2);
	                copy3array(vertices, offset + 12, v3);
	                copy3array(vertices, offset + 15, v4);
	            }
	    };
	    Display3D.prototype.initMorphingSphere = function () {
	        var _this = this;
	        var ilen = 10, klen = 10, r = Display3D.scale / 4;
	        var calm = true, morphing = false;
	        var rr = [];
	        var vertices = new Float32Array(ilen * klen * 6 * 3);
	        for (var i = 0; i < ilen * klen; i++)
	            rr[i] = r;
	        this.generateSphere(vertices, ilen, klen, rr);
	        var geometry = new THREE.BufferGeometry();
	        geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
	        geometry.computeVertexNormals();
	        var material = new THREE.MeshPhongMaterial({
	            specular: 0xffffff,
	            color: 0,
	            shininess: 25 });
	        this.morphingSphere = new THREE.Mesh(geometry, material);
	        var morph = function () {
	            morphing = true;
	            _this.animator.play({
	                func: function (dt) {
	                    if (Math.random() > .7) {
	                        for (var i = 0; i < ilen; i++)
	                            for (var k = 0; k < klen; k++) {
	                                var q = calm ? dt * dt : 1 - dt * dt;
	                                if (i % 2 == 0 && k % 2 == 0)
	                                    rr[i + k * ilen] = r + Math.random() * r * q * 2;
	                                else
	                                    rr[i + k * ilen] = r * (1 - q / 2);
	                            }
	                        _this.generateSphere(vertices, ilen, klen, rr);
	                        geometry.attributes['position'].needsUpdate = true;
	                        geometry.computeVertexNormals();
	                    }
	                },
	                duration: 2500,
	                object: _this.morphingSphere
	            }).then(function () { morphing = false; calm = !calm; });
	        };
	        this.animator.play({
	            func: function (dt) {
	                if (Math.random() > .8 && !morphing)
	                    morph();
	            },
	            duration: 500,
	            loop: true,
	            timer: true
	        });
	    };
	    Display3D.prototype.addMorphingSphere = function (x, y) {
	        var s = this.morphingSphere.clone();
	        s.position.x = x * Display3D.scale;
	        s.position.z = y * Display3D.scale;
	        this.mazeHolder.add(s);
	        this.animator.play({
	            func: function (dt) {
	                s.rotation.x = dt * Math.PI;
	                s.rotation.z = dt * Math.PI * 2;
	            },
	            duration: 20000,
	            loop: true
	        });
	        return s;
	    };
	    Display3D.prototype.playFinal = function (blockGameplay, cameraq) {
	        var _this = this;
	        this.animator.play({ duration: 3000 })
	            .then(function () { return _this.glitchMe(200); })
	            .then(function () { return _this.animator.play({ duration: 1500 }); })
	            .then(function () { return _this.glitchMe(200); })
	            .then(function () { return _this.animator.play({ duration: 1500 }); })
	            .then(function () { return _this.glitchMe(700); })
	            .then(function () { return _this.animator.play({ duration: 1500 }); })
	            .then(blockGameplay)
	            .then(function () { return _this.glitchMe(700); })
	            .then(function () { return _this.scene.remove(_this.mazeHolder); })
	            .then(function () { return _this.animator.play({ duration: 1000 }); })
	            .then(function () {
	            _this.animator.stop(_this.player);
	            var currotz = _this.playerWire.rotation.z;
	            _this.animator.play({
	                func: function (dt) { return _this.playerWire.rotation.z = currotz * (1 - dt); }
	            });
	            var rotateme = function () {
	                var startq = _this.player.rotation.y;
	                var duration = Math.random();
	                duration = Math.pow(duration, 2) * 1500;
	                _this.animator.play({
	                    func: function (dt) { return _this.player.rotation.y = startq + dt / 5; },
	                    duration: duration
	                }).then(function () { return rotateme(); });
	            };
	            rotateme();
	            _this.finalCameraMove(5000, cameraq);
	            return _this.animator.play({
	                func: function (dt) {
	                    _this.playerWire.morphTargetInfluences[0] = dt;
	                    _this.playerWire.position.y = -dt * Display3D.scale * .33;
	                    _this.player.position.y = dt * Display3D.scale * .7;
	                    var d = dt * 3.3 + 1;
	                    _this.player.scale.set(d, d, d);
	                },
	                duration: 5000
	            });
	        })
	            .then(function () {
	            _this.finalHead.mesh.position.y = -Display3D.scale * .33;
	            _this.player.remove(_this.playerWire);
	            _this.player.add(_this.finalHead.mesh);
	            return _this.animator.play({
	                func: function (d) { return _this.finalHead.lowpoly(d * d * 994 + 6); },
	                duration: 20000 });
	        }).then(function (_) {
	            var light = new THREE.PointLight(0xffffff, .25);
	            light.position.set(_this.camera.position.x, _this.camera.position.y, _this.camera.position.z);
	            _this.scene.add(light);
	            _this.finalHead.mesh.material = _this.finalHead.materialSolid;
	            _this.glitchMe(70);
	            _this.animator.play({
	                func: function (_) {
	                    if (Math.random() > .93) {
	                        _this.finalHead.lowpoly(Math.pow(Math.random(), 2) * 994 + 6);
	                        _this.glitchMe(200);
	                    }
	                },
	                duration: 1000, timer: true, loop: true });
	            _this.animator.play({
	                func: function (_) {
	                    var rnd = Math.random();
	                    var curmat = _this.finalHead.mesh.material;
	                    if (rnd < .075)
	                        _this.finalHead.mesh.material = _this.finalHead.materialSolid;
	                    else if (rnd > .075 && rnd < .15)
	                        _this.finalHead.mesh.material = _this.finalHead.materialWire;
	                    else if (rnd > .15 && rnd < .225)
	                        _this.finalHead.mesh.material = _this.spaceMaterial;
	                    if (curmat != _this.finalHead.mesh.material)
	                        _this.glitchMe(70);
	                },
	                duration: 1000, timer: true, loop: true });
	        });
	    };
	    Display3D.prototype.render = function (dt) {
	        this.spaceMaterial.uniforms.iGlobalTime.value += dt / 1000;
	        this.animator.step();
	        if (this.glitch)
	            this.glitchComposer.render();
	        else
	            this.renderer.render(this.scene, this.camera);
	    };
	    Display3D.scale = 50;
	    return Display3D;
	})();
	exports.Display3D = Display3D;
	function sphericalTo3d(a, b, r) {
	    return [
	        r * Math.cos(a) * Math.sin(b),
	        r * Math.sin(a) * Math.sin(b),
	        r * Math.cos(b)
	    ];
	}
	function copy3array(a, offset, b) {
	    a[offset] = b[0];
	    a[offset + 1] = b[1];
	    a[offset + 2] = b[2];
	}
	//# sourceMappingURL=display.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(64)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// File:src/Three.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var THREE = { REVISION: '71' };
	
	// browserify support
	
	if ( true ) {
	
		module.exports = THREE;
	
	}
	
	// polyfills
	
	if ( Math.sign === undefined ) {
	
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
		Math.sign = function ( x ) {
	
			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : +x;
	
		};
	
	}
	
	
	// set the default log handlers
	THREE.log = function() { console.log.apply( console, arguments ); }
	THREE.warn = function() { console.warn.apply( console, arguments ); }
	THREE.error = function() { console.error.apply( console, arguments ); }
	
	
	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
	
	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	
	// GL STATE CONSTANTS
	
	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;
	
	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;
	
	// SHADOWING TYPES
	
	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;
	
	// MATERIAL CONSTANTS
	
	// side
	
	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;
	
	// shading
	
	THREE.NoShading = 0;
	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;
	
	// colors
	
	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;
	
	// blending modes
	
	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;
	
	// custom blending equations
	// (numbers start from 100 not to clash with other
	//  mappings to OpenGL constants defined in Texture.js)
	
	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;
	
	// custom blending destination factors
	
	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;
	
	// custom blending source factors
	
	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;
	
	
	// TEXTURE CONSTANTS
	
	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;
	
	// Mapping modes
	
	THREE.UVMapping = 300;
	
	THREE.CubeReflectionMapping = 301;
	THREE.CubeRefractionMapping = 302;
	
	THREE.EquirectangularReflectionMapping = 303;
	THREE.EquirectangularRefractionMapping = 304;
	
	THREE.SphericalReflectionMapping = 305;
	
	// Wrapping modes
	
	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;
	
	// Filters
	
	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;
	
	// Data types
	
	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	THREE.HalfFloatType = 1025;
	
	// Pixel types
	
	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;
	
	// Pixel formats
	
	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	THREE.RGBEFormat = THREE.RGBAFormat; //1024;
	
	// DDS / ST3C Compressed texture formats
	
	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;
	
	
	// PVRTC compressed texture formats
	
	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
	
	
	// DEPRECATED
	
	THREE.Projector = function () {
	
		THREE.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
		this.projectVector = function ( vector, camera ) {
	
			THREE.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );
	
		};
	
		this.unprojectVector = function ( vector, camera ) {
	
			THREE.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );
	
		};
	
		this.pickingRay = function ( vector, camera ) {
	
			THREE.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
		};
	
	};
	
	THREE.CanvasRenderer = function () {
	
		THREE.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
	
		this.domElement = document.createElement( 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};
	
	};
	
	// File:src/math/Color.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Color = function ( color ) {
	
		if ( arguments.length === 3 ) {
	
			return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );
	
		}
	
		return this.set( color )
	
	};
	
	THREE.Color.prototype = {
	
		constructor: THREE.Color,
	
		r: 1, g: 1, b: 1,
	
		set: function ( value ) {
	
			if ( value instanceof THREE.Color ) {
	
				this.copy( value );
	
			} else if ( typeof value === 'number' ) {
	
				this.setHex( value );
	
			} else if ( typeof value === 'string' ) {
	
				this.setStyle( value );
	
			}
	
			return this;
	
		},
	
		setHex: function ( hex ) {
	
			hex = Math.floor( hex );
	
			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;
	
			return this;
	
		},
	
		setRGB: function ( r, g, b ) {
	
			this.r = r;
			this.g = g;
			this.b = b;
	
			return this;
	
		},
	
		setHSL: function ( h, s, l ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			if ( s === 0 ) {
	
				this.r = this.g = this.b = l;
	
			} else {
	
				var hue2rgb = function ( p, q, t ) {
	
					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;
	
				};
	
				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;
	
				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );
	
			}
	
			return this;
	
		},
	
		setStyle: function ( style ) {
	
			// rgb(255,0,0)
	
			if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {
	
				var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );
	
				this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
				this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
				this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
				return this;
	
			}
	
			// rgb(100%,0%,0%)
	
			if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {
	
				var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );
	
				this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
				this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
				this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
				return this;
	
			}
	
			// #ff0000
	
			if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {
	
				var color = /^\#([0-9a-f]{6})$/i.exec( style );
	
				this.setHex( parseInt( color[ 1 ], 16 ) );
	
				return this;
	
			}
	
			// #f00
	
			if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {
	
				var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );
	
				this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );
	
				return this;
	
			}
	
			// red
	
			if ( /^(\w+)$/i.test( style ) ) {
	
				this.setHex( THREE.ColorKeywords[ style ] );
	
				return this;
	
			}
	
	
		},
	
		copy: function ( color ) {
	
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
	
			return this;
	
		},
	
		copyGammaToLinear: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );
	
			return this;
	
		},
	
		copyLinearToGamma: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );
	
			return this;
	
		},
	
		convertGammaToLinear: function () {
	
			var r = this.r, g = this.g, b = this.b;
	
			this.r = r * r;
			this.g = g * g;
			this.b = b * b;
	
			return this;
	
		},
	
		convertLinearToGamma: function () {
	
			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );
	
			return this;
	
		},
	
		getHex: function () {
	
			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
		},
	
		getHexString: function () {
	
			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
		},
	
		getHSL: function ( optionalTarget ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
			var r = this.r, g = this.g, b = this.b;
	
			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );
	
			var hue, saturation;
			var lightness = ( min + max ) / 2.0;
	
			if ( min === max ) {
	
				hue = 0;
				saturation = 0;
	
			} else {
	
				var delta = max - min;
	
				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
				switch ( max ) {
	
					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;
	
				}
	
				hue /= 6;
	
			}
	
			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;
	
			return hsl;
	
		},
	
		getStyle: function () {
	
			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
		},
	
		offsetHSL: function ( h, s, l ) {
	
			var hsl = this.getHSL();
	
			hsl.h += h; hsl.s += s; hsl.l += l;
	
			this.setHSL( hsl.h, hsl.s, hsl.l );
	
			return this;
	
		},
	
		add: function ( color ) {
	
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
	
			return this;
	
		},
	
		addColors: function ( color1, color2 ) {
	
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.r += s;
			this.g += s;
			this.b += s;
	
			return this;
	
		},
	
		multiply: function ( color ) {
	
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.r *= s;
			this.g *= s;
			this.b *= s;
	
			return this;
	
		},
	
		lerp: function ( color, alpha ) {
	
			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;
	
			return this;
	
		},
	
		equals: function ( c ) {
	
			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
		},
	
		fromArray: function ( array ) {
	
			this.r = array[ 0 ];
			this.g = array[ 1 ];
			this.b = array[ 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;
	
			return array;
		},
	
		clone: function () {
	
			return new THREE.Color().setRGB( this.r, this.g, this.b );
	
		}
	
	};
	
	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
	// File:src/math/Quaternion.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Quaternion = function ( x, y, z, w ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Quaternion.prototype = {
	
		constructor: THREE.Quaternion,
	
		_x: 0,_y: 0, _z: 0, _w: 0,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get w () {
	
			return this._w;
	
		},
	
		set w ( value ) {
	
			this._w = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, w ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		copy: function ( quaternion ) {
	
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromEuler: function ( euler, update ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
			}
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );
	
			if ( euler.order === 'XYZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( euler.order === 'YXZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( euler.order === 'ZXY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( euler.order === 'ZYX' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( euler.order === 'YZX' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( euler.order === 'XZY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
			// assumes axis is normalized
	
			var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromUnitVectors: function () {
	
			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	
			// assumes direction vectors vFrom and vTo are normalized
	
			var v1, r;
	
			var EPS = 0.000001;
	
			return function ( vFrom, vTo ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				r = vFrom.dot( vTo ) + 1;
	
				if ( r < EPS ) {
	
					r = 0;
	
					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
						v1.set( - vFrom.y, vFrom.x, 0 );
	
					} else {
	
						v1.set( 0, - vFrom.z, vFrom.y );
	
					}
	
				} else {
	
					v1.crossVectors( vFrom, vTo );
	
				}
	
				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;
	
				this.normalize();
	
				return this;
	
			}
	
		}(),
	
		inverse: function () {
	
			this.conjugate().normalize();
	
			return this;
	
		},
	
		conjugate: function () {
	
			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
		},
	
		lengthSq: function () {
	
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
	
			} else {
	
				l = 1 / l;
	
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				THREE.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			THREE.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
	
		},
	
		slerp: function ( qb, t ) {
	
			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );
	
			var x = this._x, y = this._y, z = this._z, w = this._w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
			if ( cosHalfTheta < 0 ) {
	
				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;
	
				cosHalfTheta = - cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
	
				return this;
	
			}
	
			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
			if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );
	
				return this;
	
			}
	
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		equals: function ( quaternion ) {
	
			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;
	
			return array;
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {},
	
		clone: function () {
	
			return new THREE.Quaternion( this._x, this._y, this._z, this._w );
	
		}
	
	};
	
	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {
	
		return qm.copy( qa ).slerp( qb, t );
	
	}
	
	// File:src/math/Vector2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.Vector2 = function ( x, y ) {
	
		this.x = x || 0;
		this.y = y || 0;
	
	};
	
	THREE.Vector2.prototype = {
	
		constructor: THREE.Vector2,
	
		set: function ( x, y ) {
	
			this.x = x;
			this.y = y;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				THREE.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				THREE.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
	
			return this;
	
		},
	
		multiply: function ( v ) {
	
			this.x *= v.x;
			this.y *= v.y;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.x *= s;
			this.y *= s;
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			if ( scalar !== 0 ) {
	
				var invScalar = 1 / scalar;
	
				this.x *= invScalar;
				this.y *= invScalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
	
			}
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			return this;
		},
	
		clampScalar: ( function () {
	
			var min, max;
	
			return function ( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector2();
					max = new THREE.Vector2();
	
				}
	
				min.set( minVal, minVal );
				max.set( maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		} )(),
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength ) {
	
				this.multiplyScalar( l / oldLength );
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
	
			return this;
	
		},
	
		clone: function () {
	
			return new THREE.Vector2( this.x, this.y );
	
		}
	
	};
	
	// File:src/math/Vector3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector3 = function ( x, y, z ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	
	};
	
	THREE.Vector3.prototype = {
	
		constructor: THREE.Vector3,
	
		set: function ( x, y, z ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				THREE.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				THREE.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
	
			return this;
	
		},
		
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
	
			return this;
	
		},
	
		multiply: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				THREE.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
	
			}
	
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
	
			return this;
	
		},
	
		multiplyVectors: function ( a, b ) {
	
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
	
			return this;
	
		},
	
		applyEuler: function () {
	
			var quaternion;
	
			return function ( euler ) {
	
				if ( euler instanceof THREE.Euler === false ) {
	
					THREE.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
				}
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				return this;
	
			};
	
		}(),
	
		applyAxisAngle: function () {
	
			var quaternion;
	
			return function ( axis, angle ) {
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				return this;
	
			};
	
		}(),
	
		applyMatrix3: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
	
			return this;
	
		},
	
		applyProjection: function ( m ) {
	
			// input: THREE.Matrix4 projection matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide
	
			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;
	
			return this;
	
		},
	
		applyQuaternion: function ( q ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;
	
			// calculate quat * vector
	
			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;
	
			// calculate result * inverse quat
	
			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
			return this;
	
		},
	
		project: function () {
	
			var matrix;
	
			return function ( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		unproject: function () {
	
			var matrix;
	
			return function ( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		transformDirection: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
			this.normalize();
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			if ( scalar !== 0 ) {
	
				var invScalar = 1 / scalar;
	
				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
	
			}
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z > v.z ) {
	
				this.z = v.z;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z < v.z ) {
	
				this.z = v.z;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			if ( this.z < min.z ) {
	
				this.z = min.z;
	
			} else if ( this.z > max.z ) {
	
				this.z = max.z;
	
			}
	
			return this;
	
		},
	
		clampScalar: ( function () {
	
			var min, max;
	
			return function ( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector3();
					max = new THREE.Vector3();
	
				}
	
				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		} )(),
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength  ) {
	
				this.multiplyScalar( l / oldLength );
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		cross: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				THREE.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
	
			}
	
			var x = this.x, y = this.y, z = this.z;
	
			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;
	
			return this;
	
		},
	
		crossVectors: function ( a, b ) {
	
			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;
	
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
	
			return this;
	
		},
	
		projectOnVector: function () {
	
			var v1, dot;
	
			return function ( vector ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( vector ).normalize();
	
				dot = this.dot( v1 );
	
				return this.copy( v1 ).multiplyScalar( dot );
	
			};
	
		}(),
	
		projectOnPlane: function () {
	
			var v1;
	
			return function ( planeNormal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( this ).projectOnVector( planeNormal );
	
				return this.sub( v1 );
	
			}
	
		}(),
	
		reflect: function () {
	
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
	
			var v1;
	
			return function ( normal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
			}
	
		}(),
	
		angleTo: function ( v ) {
	
			var theta = this.dot( v ) / ( this.length() * v.length() );
	
			// clamp, to handle numerical problems
	
			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;
	
			return dx * dx + dy * dy + dz * dz;
	
		},
	
		setEulerFromRotationMatrix: function ( m, order ) {
	
			THREE.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
	
		},
	
		setEulerFromQuaternion: function ( q, order ) {
	
			THREE.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
	
		},
	
		getPositionFromMatrix: function ( m ) {
	
			THREE.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	
			return this.setFromMatrixPosition( m );
	
		},
	
		getScaleFromMatrix: function ( m ) {
	
			THREE.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	
			return this.setFromMatrixScale( m );
		},
	
		getColumnFromMatrix: function ( index, matrix ) {
	
			THREE.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	
			return this.setFromMatrixColumn( index, matrix );
	
		},
	
		setFromMatrixPosition: function ( m ) {
	
			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];
	
			return this;
	
		},
	
		setFromMatrixScale: function ( m ) {
	
			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();
	
			this.x = sx;
			this.y = sy;
			this.z = sz;
	
			return this;
		},
	
		setFromMatrixColumn: function ( index, matrix ) {
			
			var offset = index * 4;
	
			var me = matrix.elements;
	
			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
	
			return this;
	
		},
	
		clone: function () {
	
			return new THREE.Vector3( this.x, this.y, this.z );
	
		}
	
	};
	
	// File:src/math/Vector4.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector4 = function ( x, y, z, w ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Vector4.prototype = {
	
		constructor: THREE.Vector4,
	
		set: function ( x, y, z, w ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setW: function ( w ) {
	
			this.w = w;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				THREE.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				THREE.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			if ( scalar !== 0 ) {
	
				var invScalar = 1 / scalar;
	
				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
				this.w *= invScalar;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 1;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromQuaternion: function ( q ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
			// q is assumed to be normalized
	
			this.w = 2 * Math.acos( q.w );
	
			var s = Math.sqrt( 1 - q.w * q.w );
	
			if ( s < 0.0001 ) {
	
				 this.x = 1;
				 this.y = 0;
				 this.z = 0;
	
			} else {
	
				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
				te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
	
				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
					// this singularity is identity matrix so angle = 0
	
					this.set( 1, 0, 0, 0 );
	
					return this; // zero angle, arbitrary axis
	
				}
	
				// otherwise this singularity is angle = 180
	
				angle = Math.PI;
	
				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;
	
				if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term
	
					if ( xx < epsilon ) {
	
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
	
					} else {
	
						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;
	
					}
	
				} else if ( yy > zz ) { // m22 is the largest diagonal term
	
					if ( yy < epsilon ) {
	
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
	
					} else {
	
						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;
	
					}
	
				} else { // m33 is the largest diagonal term so base result on this
	
					if ( zz < epsilon ) {
	
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
	
					} else {
	
						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;
	
					}
	
				}
	
				this.set( x, y, z, angle );
	
				return this; // return 180 deg rotation
	
			}
	
			// as we have reached here there are no singularities so we can handle normally
	
			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
			if ( Math.abs( s ) < 0.001 ) s = 1;
	
			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
	
			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z > v.z ) {
	
				this.z = v.z;
	
			}
	
			if ( this.w > v.w ) {
	
				this.w = v.w;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z < v.z ) {
	
				this.z = v.z;
	
			}
	
			if ( this.w < v.w ) {
	
				this.w = v.w;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			if ( this.z < min.z ) {
	
				this.z = min.z;
	
			} else if ( this.z > max.z ) {
	
				this.z = max.z;
	
			}
	
			if ( this.w < min.w ) {
	
				this.w = min.w;
	
			} else if ( this.w > max.w ) {
	
				this.w = max.w;
	
			}
	
			return this;
	
		},
	
		clampScalar: ( function () {
	
			var min, max;
	
			return function ( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector4();
					max = new THREE.Vector4();
	
				}
	
				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		} )(),
	
	  floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );
	
			return this;
	
	  },
	
	  ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );
	
			return this;
	
	  },
	
	  round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );
	
			return this;
	
	  },
	
	  roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
			return this;
	
	  },
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength ) {
	
				this.multiplyScalar( l / oldLength );
	
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];
	
			return this;
	
		},
	
		clone: function () {
	
			return new THREE.Vector4( this.x, this.y, this.z, this.w );
	
		}
	
	};
	
	// File:src/math/Euler.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Euler = function ( x, y, z, order ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;
	
	};
	
	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
	THREE.Euler.DefaultOrder = 'XYZ';
	
	THREE.Euler.prototype = {
	
		constructor: THREE.Euler,
	
		_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get order () {
	
			return this._order;
	
		},
	
		set order ( value ) {
	
			this._order = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, order ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		copy: function ( euler ) {
	
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m, order, update ) {
	
			var clamp = THREE.Math.clamp;
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
	
				} else {
	
					this._x = Math.atan2( m32, m22 );
					this._z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
	
				} else {
	
					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
	
				} else {
	
					this._y = 0;
					this._z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
	
				} else {
	
					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
	
				} else {
	
					this._x = 0;
					this._y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
	
				} else {
	
					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
	
				}
	
			} else {
	
				THREE.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )
	
			}
	
			this._order = order;
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromQuaternion: function () {
	
			var matrix;
	
			return function ( q, order, update ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );
	
				return this;
	
			};
	
		}(),
	
		setFromVector3: function ( v, order ) {
	
			return this.set( v.x, v.y, v.z, order || this._order );
	
		},
	
		reorder: function () {
	
			// WARNING: this discards revolution information -bhouston
	
			var q = new THREE.Quaternion();
	
			return function ( newOrder ) {
	
				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );
	
			};
	
		}(),
	
		equals: function ( euler ) {
	
			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
		},
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;
	
			return array;
		},
	
		toVector3: function ( optionalResult ) {
	
			if ( optionalResult ) {
	
				return optionalResult.set( this._x, this._y, this._z );
	
			} else {
	
				return new THREE.Vector3( this._x, this._y, this._z );
	
			}
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {},
	
		clone: function () {
	
			return new THREE.Euler( this._x, this._y, this._z, this._order );
	
		}
	
	};
	
	// File:src/math/Line3.js
	
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Line3 = function ( start, end ) {
	
		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();
	
	};
	
	THREE.Line3.prototype = {
	
		constructor: THREE.Line3,
	
		set: function ( start, end ) {
	
			this.start.copy( start );
			this.end.copy( end );
	
			return this;
	
		},
	
		copy: function ( line ) {
	
			this.start.copy( line.start );
			this.end.copy( line.end );
	
			return this;
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
		},
	
		delta: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );
	
		},
	
		distanceSq: function () {
	
			return this.start.distanceToSquared( this.end );
	
		},
	
		distance: function () {
	
			return this.start.distanceTo( this.end );
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		closestPointToPointParameter: function () {
	
			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();
	
			return function ( point, clampToLine ) {
	
				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );
	
				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );
	
				var t = startEnd_startP / startEnd2;
	
				if ( clampToLine ) {
	
					t = THREE.Math.clamp( t, 0, 1 );
	
				}
	
				return t;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
			var t = this.closestPointToPointParameter( point, clampToLine );
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );
	
			return this;
	
		},
	
		equals: function ( line ) {
	
			return line.start.equals( this.start ) && line.end.equals( this.end );
	
		},
	
		clone: function () {
	
			return new THREE.Line3().copy( this );
	
		}
	
	};
	
	// File:src/math/Box2.js
	
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Box2 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );
	
	};
	
	THREE.Box2.prototype = {
	
		constructor: THREE.Box2,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] )
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = - Infinity;
	
			return this;
	
		},
	
		empty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector2();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);
	
		},
	
		isIntersectionBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		},
	
		clone: function () {
	
			return new THREE.Box2().copy( this );
	
		}
	
	};
	
	// File:src/math/Box3.js
	
	/**
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Box3 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );
	
	};
	
	THREE.Box3.prototype = {
	
		constructor: THREE.Box3,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] )
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		setFromObject: function () {
	
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and childrens', world transforms
	
			var v1 = new THREE.Vector3();
	
			return function ( object ) {
	
				var scope = this;
	
				object.updateMatrixWorld( true );
	
				this.makeEmpty();
	
				object.traverse( function ( node ) {
	
					var geometry = node.geometry;
	
					if ( geometry !== undefined ) {
	
						if ( geometry instanceof THREE.Geometry ) {
	
							var vertices = geometry.vertices;
	
							for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
								v1.copy( vertices[ i ] );
	
								v1.applyMatrix4( node.matrixWorld );
	
								scope.expandByPoint( v1 );
	
							}
	
						} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {
	
							var positions = geometry.attributes[ 'position' ].array;
	
							for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
								v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
	
								v1.applyMatrix4( node.matrixWorld );
	
								scope.expandByPoint( v1 );
	
							}
	
						}
	
					}
	
				} );
	
				return this;
	
			};
	
		}(),
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;
	
			return this;
	
		},
	
		empty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);
	
		},
	
		isIntersectionBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		getBoundingSphere: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Sphere();
	
				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;
	
				return result;
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		applyMatrix4: function () {
	
			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];
	
			return function ( matrix ) {
	
				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111
	
				this.makeEmpty();
				this.setFromPoints( points );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		},
	
		clone: function () {
	
			return new THREE.Box3().copy( this );
	
		}
	
	};
	
	// File:src/math/Matrix3.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Matrix3 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0,
			0, 1, 0,
			0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			THREE.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix3.prototype = {
	
		constructor: THREE.Matrix3,
	
		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			);
	
			return this;
	
		},
	
		copy: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]
	
			);
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			THREE.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );
	
		},
	
		multiplyVector3Array: function ( a ) {
	
			THREE.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );
	
		},
	
		applyToVector3Array: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( array, offset, length ) {
	
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.x = array[ j ];
					v1.y = array[ j + 1 ];
					v1.z = array[ j + 2 ];
	
					v1.applyMatrix3( this );
	
					array[ j ]     = v1.x;
					array[ j + 1 ] = v1.y;
					array[ j + 2 ] = v1.z;
	
				}
	
				return array;
	
			};
	
		}(),
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
			return this;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
		},
	
		getInverse: function ( matrix, throwOnInvertible ) {
	
			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )
	
			var me = matrix.elements;
			var te = this.elements;
	
			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];
	
			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];
	
			// no inverse
	
			if ( det === 0 ) {
	
				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg );
	
				} else {
	
					THREE.warn( msg );
	
				}
	
				this.identity();
	
				return this;
	
			}
	
			this.multiplyScalar( 1.0 / det );
	
			return this;
	
		},
	
		transpose: function () {
	
			var tmp, m = this.elements;
	
			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			var te = this.elements;
	
			array[ offset     ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
	
			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
	
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];
	
			return array;
	
		},
	
		getNormalMatrix: function ( m ) {
	
			// input: THREE.Matrix4
	
			this.getInverse( m ).transpose();
	
			return this;
	
		},
	
		transposeIntoArray: function ( r ) {
	
			var m = this.elements;
	
			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
	
			return this;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];
	
		},
	
		clone: function () {
	
			return new THREE.Matrix3().fromArray( this.elements );
	
		}
	
	};
	
	// File:src/math/Matrix4.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Matrix4 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			THREE.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix4.prototype = {
	
		constructor: THREE.Matrix4,
	
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		copy: function ( m ) {
	
			this.elements.set( m.elements );
	
			return this;
	
		},
	
		extractPosition: function ( m ) {
	
			THREE.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );
	
		},
	
		copyPosition: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];
	
			return this;
	
		},
	
		extractBasis: function ( xAxis, yAxis, zAxis ) {
	 
			var te = this.elements;
	 
			xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
			yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
			zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );
	 
			return this;
	 		
		},
	 
		makeBasis: function ( xAxis, yAxis, zAxis ) {
	
			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);
	
			return this;
	
		},
	
		extractRotation: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( m ) {
	
				var te = this.elements;
				var me = m.elements;
	
				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();
	
				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
	
				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
	
				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
	
				return this;
	
			};
	
		}(),
	
		makeRotationFromEuler: function ( euler ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				THREE.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			var te = this.elements;
	
			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
	
			if ( euler.order === 'XYZ' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;
	
				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;
	
				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YXZ' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;
	
				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;
	
				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZXY' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;
	
				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;
	
				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZYX' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;
	
				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;
	
				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YZX' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;
	
				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;
	
				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;
	
			} else if ( euler.order === 'XZY' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;
	
				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;
	
				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;
	
			}
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			THREE.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
	
			return this.makeRotationFromQuaternion( q );
	
		},
	
		makeRotationFromQuaternion: function ( q ) {
	
			var te = this.elements;
	
			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
	
			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;
	
			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;
	
			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		lookAt: function () {
	
			var x = new THREE.Vector3();
			var y = new THREE.Vector3();
			var z = new THREE.Vector3();
	
			return function ( eye, target, up ) {
	
				var te = this.elements;
	
				z.subVectors( eye, target ).normalize();
	
				if ( z.length() === 0 ) {
	
					z.z = 1;
	
				}
	
				x.crossVectors( up, z ).normalize();
	
				if ( x.length() === 0 ) {
	
					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();
	
				}
	
				y.crossVectors( z, x );
	
	
				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
				return this;
	
			};
	
		}(),
	
		multiply: function ( m, n ) {
	
			if ( n !== undefined ) {
	
				THREE.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
	
			}
	
			return this.multiplyMatrices( this, m );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return this;
	
		},
	
		multiplyToArray: function ( a, b, r ) {
	
			var te = this.elements;
	
			this.multiplyMatrices( a, b );
	
			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			THREE.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );
	
		},
	
		multiplyVector4: function ( vector ) {
	
			THREE.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
	
		multiplyVector3Array: function ( a ) {
	
			THREE.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );
	
		},
	
		applyToVector3Array: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( array, offset, length ) {
	
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.x = array[ j ];
					v1.y = array[ j + 1 ];
					v1.z = array[ j + 2 ];
	
					v1.applyMatrix4( this );
	
					array[ j ]     = v1.x;
					array[ j + 1 ] = v1.y;
					array[ j + 2 ] = v1.z;
	
				}
	
				return array;
	
			};
	
		}(),
	
		rotateAxis: function ( v ) {
	
			THREE.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	
			v.transformDirection( this );
	
		},
	
		crossVector: function ( vector ) {
	
			THREE.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)
	
			);
	
		},
	
		transpose: function () {
	
			var te = this.elements;
			var tmp;
	
			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			var te = this.elements;
	
			array[ offset     ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];
	
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
	
			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];
	
			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];
	
			return array;
	
		},
	
		getPosition: function () {
	
			var v1 = new THREE.Vector3();
	
			return function () {
	
				THREE.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	
				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );
	
			};
	
		}(),
	
		setPosition: function ( v ) {
	
			var te = this.elements;
	
			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;
	
			return this;
	
		},
	
		getInverse: function ( m, throwOnInvertible ) {
	
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;
	
			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];
	
			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
	
			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];
	
			if ( det == 0 ) {
	
				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg );
	
				} else {
	
					THREE.warn( msg );
	
				}
	
				this.identity();
	
				return this;
			}
	
			this.multiplyScalar( 1 / det );
	
			return this;
	
		},
	
		translate: function ( v ) {
	
			THREE.error( 'THREE.Matrix4: .translate() has been removed.' );
	
		},
	
		rotateX: function ( angle ) {
	
			THREE.error( 'THREE.Matrix4: .rotateX() has been removed.' );
	
		},
	
		rotateY: function ( angle ) {
	
			THREE.error( 'THREE.Matrix4: .rotateY() has been removed.' );
	
		},
	
		rotateZ: function ( angle ) {
	
			THREE.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
	
		},
	
		rotateByAxis: function ( axis, angle ) {
	
			THREE.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
	
		},
	
		scale: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
			return this;
	
		},
	
		getMaxScaleOnAxis: function () {
	
			var te = this.elements;
	
			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
			return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );
	
		},
	
		makeTranslation: function ( x, y, z ) {
	
			this.set(
	
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationX: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationY: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationZ: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationAxis: function ( axis, angle ) {
	
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
	
			this.set(
	
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
	
			);
	
			 return this;
	
		},
	
		makeScale: function ( x, y, z ) {
	
			this.set(
	
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		compose: function ( position, quaternion, scale ) {
	
			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );
	
			return this;
	
		},
	
		decompose: function () {
	
			var vector = new THREE.Vector3();
			var matrix = new THREE.Matrix4();
	
			return function ( position, quaternion, scale ) {
	
				var te = this.elements;
	
				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {
					sx = - sx;
				}
	
				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];
	
				// scale the rotation part
	
				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()
	
				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;
	
				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;
	
				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;
	
				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;
	
				quaternion.setFromRotationMatrix( matrix );
	
				scale.x = sx;
				scale.y = sy;
				scale.z = sz;
	
				return this;
	
			};
	
		}(),
	
		makeFrustum: function ( left, right, bottom, top, near, far ) {
	
			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
	
			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
	
			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
			return this;
	
		},
	
		makePerspective: function ( fov, aspect, near, far ) {
	
			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;
	
			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );
	
		},
	
		makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;
	
			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;
	
			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
			return this;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];
	
		},
	
		clone: function () {
	
			return new THREE.Matrix4().fromArray( this.elements );
	
		}
	
	};
	
	// File:src/math/Ray.js
	
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Ray = function ( origin, direction ) {
	
		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();
	
	};
	
	THREE.Ray.prototype = {
	
		constructor: THREE.Ray,
	
		set: function ( origin, direction ) {
	
			this.origin.copy( origin );
			this.direction.copy( direction );
	
			return this;
	
		},
	
		copy: function ( ray ) {
	
			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );
	
			return this;
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
		},
	
		recast: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( t ) {
	
				this.origin.copy( this.at( t, v1 ) );
	
				return this;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );
	
			if ( directionDistance < 0 ) {
	
				return result.copy( this.origin );
	
			}
	
			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
				// point behind the ray
	
				if ( directionDistance < 0 ) {
	
					return this.origin.distanceTo( point );
	
				}
	
				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
				return v1.distanceTo( point );
	
			};
	
		}(),
	
		distanceSqToSegment: function () {
	
			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();
	
			return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
				// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment
	
				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );
	
				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;
	
				if ( det > 0 ) {
	
					// The ray and segment are not parallel.
	
					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;
	
					if ( s0 >= 0 ) {
	
						if ( s1 >= - extDet ) {
	
							if ( s1 <= extDet ) {
	
								// region 0
								// Minimum at interior points of ray and segment.
	
								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 1
	
								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							// region 5
	
							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					} else {
	
						if ( s1 <= - extDet ) {
	
							// region 4
	
							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						} else if ( s1 <= extDet ) {
	
							// region 3
	
							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
						} else {
	
							// region 2
	
							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					}
	
				} else {
	
					// Ray and segment are parallel.
	
					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
				}
	
				if ( optionalPointOnRay ) {
	
					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
				}
	
				if ( optionalPointOnSegment ) {
	
					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
				}
	
				return sqrDist;
	
			};
	
		}(),
	
	
		isIntersectionSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
		},
	
		intersectSphere: function () {
	
			// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/
	
			var v1 = new THREE.Vector3();
	
			return function ( sphere, optionalTarget ) {
	
				v1.subVectors( sphere.center, this.origin );
	
				var tca = v1.dot( this.direction );
	
				var d2 = v1.dot( v1 ) - tca * tca;
	
				var radius2 = sphere.radius * sphere.radius;
	
				if ( d2 > radius2 ) return null;
	
				var thc = Math.sqrt( radius2 - d2 );
	
				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;
	
				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;
	
				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;
	
				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );
	
				// else t0 is in front of the ray, so return the first collision point scaled by t0 
				return this.at( t0, optionalTarget );
	
			}
	
		}(),
	
		isIntersectionPlane: function ( plane ) {
	
			// check if the ray lies on the plane first
	
			var distToPoint = plane.distanceToPoint( this.origin );
	
			if ( distToPoint === 0 ) {
	
				return true;
	
			}
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator * distToPoint < 0 ) {
	
				return true;
	
			}
	
			// ray origin is behind the plane (and is pointing behind it)
	
			return false;
	
		},
	
		distanceToPlane: function ( plane ) {
	
			var denominator = plane.normal.dot( this.direction );
			if ( denominator == 0 ) {
	
				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) == 0 ) {
	
					return 0;
	
				}
	
				// Null is preferable to undefined since undefined means.... it is undefined
	
				return null;
	
			}
	
			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
			// Return if the ray never intersects the plane
	
			return t >= 0 ? t :  null;
	
		},
	
		intersectPlane: function ( plane, optionalTarget ) {
	
			var t = this.distanceToPlane( plane );
	
			if ( t === null ) {
	
				return null;
			}
	
			return this.at( t, optionalTarget );
	
		},
	
		isIntersectionBox: function () {
	
			var v = new THREE.Vector3();
	
			return function ( box ) {
	
				return this.intersectBox( box, v ) !== null;
	
			};
	
		}(),
	
		intersectBox: function ( box, optionalTarget ) {
	
			// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/
	
			var tmin,tmax,tymin,tymax,tzmin,tzmax;
	
			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;
	
			var origin = this.origin;
	
			if ( invdirx >= 0 ) {
	
				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;
	
			} else {
	
				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
			}
	
			if ( invdiry >= 0 ) {
	
				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;
	
			} else {
	
				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
			}
	
			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN
	
			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
			if ( invdirz >= 0 ) {
	
				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;
	
			} else {
	
				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
			}
	
			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
			//return point closest to the ray (positive side)
	
			if ( tmax < 0 ) return null;
	
			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
		},
	
		intersectTriangle: function () {
	
			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();
	
			return function ( a, b, c, backfaceCulling, optionalTarget ) {
	
				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp
	
				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );
	
				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;
	
				if ( DdN > 0 ) {
	
					if ( backfaceCulling ) return null;
					sign = 1;
	
				} else if ( DdN < 0 ) {
	
					sign = - 1;
					DdN = - DdN;
	
				} else {
	
					return null;
	
				}
	
				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {
	
					return null;
	
				}
	
				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {
	
					return null;
	
				}
	
				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {
	
					return null;
	
				}
	
				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );
	
				// t < 0, no intersection
				if ( QdN < 0 ) {
	
					return null;
	
				}
	
				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );
	
			};
	
		}(),
	
		applyMatrix4: function ( matrix4 ) {
	
			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();
	
			return this;
		},
	
		equals: function ( ray ) {
	
			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
		},
	
		clone: function () {
	
			return new THREE.Ray().copy( this );
	
		}
	
	};
	
	// File:src/math/Sphere.js
	
	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Sphere = function ( center, radius ) {
	
		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;
	
	};
	
	THREE.Sphere.prototype = {
	
		constructor: THREE.Sphere,
	
		set: function ( center, radius ) {
	
			this.center.copy( center );
			this.radius = radius;
	
			return this;
		},
	
		setFromPoints: function () {
	
			var box = new THREE.Box3();
	
			return function ( points, optionalCenter ) {
	
				var center = this.center;
	
				if ( optionalCenter !== undefined ) {
	
					center.copy( optionalCenter );
	
				} else {
	
					box.setFromPoints( points ).center( center );
	
				}
	
				var maxRadiusSq = 0;
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
				}
	
				this.radius = Math.sqrt( maxRadiusSq );
	
				return this;
	
			};
	
		}(),
	
		copy: function ( sphere ) {
	
			this.center.copy( sphere.center );
			this.radius = sphere.radius;
	
			return this;
	
		},
	
		empty: function () {
	
			return ( this.radius <= 0 );
	
		},
	
		containsPoint: function ( point ) {
	
			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return ( point.distanceTo( this.center ) - this.radius );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			var radiusSum = this.radius + sphere.radius;
	
			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var deltaLengthSq = this.center.distanceToSquared( point );
	
			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );
	
			if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );
	
			}
	
			return result;
	
		},
	
		getBoundingBox: function ( optionalTarget ) {
	
			var box = optionalTarget || new THREE.Box3();
	
			box.set( this.center, this.center );
			box.expandByScalar( this.radius );
	
			return box;
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.center.add( offset );
	
			return this;
	
		},
	
		equals: function ( sphere ) {
	
			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
		},
	
		clone: function () {
	
			return new THREE.Sphere().copy( this );
	
		}
	
	};
	
	// File:src/math/Frustum.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {
	
		this.planes = [
	
			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()
	
		];
	
	};
	
	THREE.Frustum.prototype = {
	
		constructor: THREE.Frustum,
	
		set: function ( p0, p1, p2, p3, p4, p5 ) {
	
			var planes = this.planes;
	
			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );
	
			return this;
	
		},
	
		copy: function ( frustum ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				planes[ i ].copy( frustum.planes[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromMatrix: function ( m ) {
	
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
			return this;
	
		},
	
		intersectsObject: function () {
	
			var sphere = new THREE.Sphere();
	
			return function ( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );
	
				return this.intersectsSphere( sphere );
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				var distance = planes[ i ].distanceToPoint( center );
	
				if ( distance < negRadius ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		intersectsBox: function () {
	
			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();
	
			return function ( box ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6 ; i ++ ) {
	
					var plane = planes[ i ];
	
					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );
	
					// if both outside plane, no intersection
	
					if ( d1 < 0 && d2 < 0 ) {
	
						return false;
	
					}
				}
	
				return true;
			};
	
		}(),
	
	
		containsPoint: function ( point ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		clone: function () {
	
			return new THREE.Frustum().copy( this );
	
		}
	
	};
	
	// File:src/math/Plane.js
	
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Plane = function ( normal, constant ) {
	
		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;
	
	};
	
	THREE.Plane.prototype = {
	
		constructor: THREE.Plane,
	
		set: function ( normal, constant ) {
	
			this.normal.copy( normal );
			this.constant = constant;
	
			return this;
	
		},
	
		setComponents: function ( x, y, z, w ) {
	
			this.normal.set( x, y, z );
			this.constant = w;
	
			return this;
	
		},
	
		setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
			return this;
	
		},
	
		setFromCoplanarPoints: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
	
			return function ( a, b, c ) {
	
				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
				this.setFromNormalAndCoplanarPoint( normal, a );
	
				return this;
	
			};
	
		}(),
	
	
		copy: function ( plane ) {
	
			this.normal.copy( plane.normal );
			this.constant = plane.constant;
	
			return this;
	
		},
	
		normalize: function () {
	
			// Note: will lead to a divide by zero if the plane is invalid.
	
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;
	
			return this;
	
		},
	
		negate: function () {
	
			this.constant *= - 1;
			this.normal.negate();
	
			return this;
	
		},
	
		distanceToPoint: function ( point ) {
	
			return this.normal.dot( point ) + this.constant;
	
		},
	
		distanceToSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) - sphere.radius;
	
		},
	
		projectPoint: function ( point, optionalTarget ) {
	
			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
		},
	
		orthoPoint: function ( point, optionalTarget ) {
	
			var perpendicularMagnitude = this.distanceToPoint( point );
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
		},
	
		isIntersectionLine: function ( line ) {
	
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );
	
			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
		},
	
		intersectLine: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( line, optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				var direction = line.delta( v1 );
	
				var denominator = this.normal.dot( direction );
	
				if ( denominator == 0 ) {
	
					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) == 0 ) {
	
						return result.copy( line.start );
	
					}
	
					// Unsure if this is the correct method to handle this case.
					return undefined;
	
				}
	
				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
				if ( t < 0 || t > 1 ) {
	
					return undefined;
	
				}
	
				return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
			};
	
		}(),
	
	
		coplanarPoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );
	
		},
	
		applyMatrix4: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();
	
			return function ( matrix, optionalNormalMatrix ) {
	
				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );
	
				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );
	
				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.constant = this.constant - offset.dot( this.normal );
	
			return this;
	
		},
	
		equals: function ( plane ) {
	
			return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );
	
		},
	
		clone: function () {
	
			return new THREE.Plane().copy( this );
	
		}
	
	};
	
	// File:src/math/Math.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Math = {
	
		generateUUID: function () {
	
			// http://www.broofa.com/Tools/Math.uuid.htm
	
			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;
	
			return function () {
	
				for ( var i = 0; i < 36; i ++ ) {
	
					if ( i == 8 || i == 13 || i == 18 || i == 23 ) {
	
						uuid[ i ] = '-';
	
					} else if ( i == 14 ) {
	
						uuid[ i ] = '4';
	
					} else {
	
						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
					}
				}
	
				return uuid.join( '' );
	
			};
	
		}(),
	
		// Clamp value to range <a, b>
	
		clamp: function ( x, a, b ) {
	
			return ( x < a ) ? a : ( ( x > b ) ? b : x );
	
		},
	
		// Clamp value to range <a, inf)
	
		clampBottom: function ( x, a ) {
	
			return x < a ? a : x;
	
		},
	
		// Linear mapping from range <a1, a2> to range <b1, b2>
	
		mapLinear: function ( x, a1, a2, b1, b2 ) {
	
			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
		},
	
		// http://en.wikipedia.org/wiki/Smoothstep
	
		smoothstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * ( 3 - 2 * x );
	
		},
	
		smootherstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
		},
	
		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)
	
		random16: function () {
	
			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;
	
		},
	
		// Random integer from <low, high> interval
	
		randInt: function ( low, high ) {
	
			return Math.floor( this.randFloat( low, high ) );
	
		},
	
		// Random float from <low, high> interval
	
		randFloat: function ( low, high ) {
	
			return low + Math.random() * ( high - low );
	
		},
	
		// Random float from <-range/2, range/2> interval
	
		randFloatSpread: function ( range ) {
	
			return range * ( 0.5 - Math.random() );
	
		},
	
		degToRad: function () {
	
			var degreeToRadiansFactor = Math.PI / 180;
	
			return function ( degrees ) {
	
				return degrees * degreeToRadiansFactor;
	
			};
	
		}(),
	
		radToDeg: function () {
	
			var radianToDegreesFactor = 180 / Math.PI;
	
			return function ( radians ) {
	
				return radians * radianToDegreesFactor;
	
			};
	
		}(),
	
		isPowerOfTwo: function ( value ) {
	
			return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
		},
	
		nextPowerOfTwo: function ( value ) {
	
			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;
	
			return value;
	
		}
	
	};
	
	// File:src/math/Spline.js
	
	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Spline = function ( points ) {
	
		this.points = points;
	
		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		this.initFromArray = function ( a ) {
	
			this.points = [];
	
			for ( var i = 0; i < a.length; i ++ ) {
	
				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };
	
			}
	
		};
	
		this.getPoint = function ( k ) {
	
			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;
	
			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
	
			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];
	
			w2 = weight * weight;
			w3 = weight * w2;
	
			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );
	
			return v3;
	
		};
	
		this.getControlPointsArray = function () {
	
			var i, p, l = this.points.length,
				coords = [];
	
			for ( i = 0; i < l; i ++ ) {
	
				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];
	
			}
	
			return coords;
	
		};
	
		// approximate length by summing linear segments
	
		this.getLength = function ( nSubDivisions ) {
	
			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;
	
			// first point has 0 length
	
			chunkLengths[ 0 ] = 0;
	
			if ( ! nSubDivisions ) nSubDivisions = 100;
	
			nSamples = this.points.length * nSubDivisions;
	
			oldPosition.copy( this.points[ 0 ] );
	
			for ( i = 1; i < nSamples; i ++ ) {
	
				index = i / nSamples;
	
				position = this.getPoint( index );
				tmpVec.copy( position );
	
				totalLength += tmpVec.distanceTo( oldPosition );
	
				oldPosition.copy( position );
	
				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );
	
				if ( intPoint != oldIntPoint ) {
	
					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;
	
				}
	
			}
	
			// last point ends with total length
	
			chunkLengths[ chunkLengths.length ] = totalLength;
	
			return { chunks: chunkLengths, total: totalLength };
	
		};
	
		this.reparametrizeByArcLength = function ( samplingCoef ) {
	
			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();
	
			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );
	
			for ( i = 1; i < this.points.length; i ++ ) {
	
				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );
	
				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];
	
				sampling = Math.ceil( samplingCoef * realDistance / sl.total );
	
				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );
	
				for ( j = 1; j < sampling - 1; j ++ ) {
	
					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );
	
					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );
	
				}
	
				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );
	
			}
	
			this.points = newpoints;
	
		};
	
		// Catmull-Rom
	
		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;
	
			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		};
	
	};
	
	// File:src/math/Triangle.js
	
	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Triangle = function ( a, b, c ) {
	
		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();
	
	};
	
	THREE.Triangle.normal = function () {
	
		var v0 = new THREE.Vector3();
	
		return function ( a, b, c, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );
	
			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {
	
				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
			}
	
			return result.set( 0, 0, 0 );
	
		};
	
	}();
	
	// static/instance method to calculate barycoordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {
	
		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function ( point, a, b, c, optionalTarget ) {
	
			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );
	
			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );
	
			var denom = ( dot00 * dot11 - dot01 * dot01 );
	
			var result = optionalTarget || new THREE.Vector3();
	
			// colinear or singular triangle
			if ( denom == 0 ) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );
			}
	
			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
			// barycoordinates must always sum to 1
			return result.set( 1 - u - v, v, u );
	
		};
	
	}();
	
	THREE.Triangle.containsPoint = function () {
	
		var v1 = new THREE.Vector3();
	
		return function ( point, a, b, c ) {
	
			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
		};
	
	}();
	
	THREE.Triangle.prototype = {
	
		constructor: THREE.Triangle,
	
		set: function ( a, b, c ) {
	
			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );
	
			return this;
	
		},
	
		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );
	
			return this;
	
		},
	
		copy: function ( triangle ) {
	
			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );
	
			return this;
	
		},
	
		area: function () {
	
			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();
	
			return function () {
	
				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );
	
				return v0.cross( v1 ).length() * 0.5;
	
			};
	
		}(),
	
		midpoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
		},
	
		normal: function ( optionalTarget ) {
	
			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
		},
	
		plane: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Plane();
	
			return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
		},
	
		barycoordFromPoint: function ( point, optionalTarget ) {
	
			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
		},
	
		containsPoint: function ( point ) {
	
			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );
	
		},
	
		equals: function ( triangle ) {
	
			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
		},
	
		clone: function () {
	
			return new THREE.Triangle().copy( this );
	
		}
	
	};
	
	// File:src/core/Clock.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Clock = function ( autoStart ) {
	
		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
	
		this.running = false;
	
	};
	
	THREE.Clock.prototype = {
	
		constructor: THREE.Clock,
	
		start: function () {
	
			this.startTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();
	
			this.oldTime = this.startTime;
			this.running = true;
		},
	
		stop: function () {
	
			this.getElapsedTime();
			this.running = false;
	
		},
	
		getElapsedTime: function () {
	
			this.getDelta();
			return this.elapsedTime;
	
		},
	
		getDelta: function () {
	
			var diff = 0;
	
			if ( this.autoStart && ! this.running ) {
	
				this.start();
	
			}
	
			if ( this.running ) {
	
				var newTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();
	
				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;
	
				this.elapsedTime += diff;
	
			}
	
			return diff;
	
		}
	
	};
	
	// File:src/core/EventDispatcher.js
	
	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	
	THREE.EventDispatcher = function () {}
	
	THREE.EventDispatcher.prototype = {
	
		constructor: THREE.EventDispatcher,
	
		apply: function ( object ) {
	
			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
	
		},
	
		addEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) this._listeners = {};
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] === undefined ) {
	
				listeners[ type ] = [];
	
			}
	
			if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
				listeners[ type ].push( listener );
	
			}
	
		},
	
		hasEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return false;
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		removeEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ type ];
	
			if ( listenerArray !== undefined ) {
	
				var index = listenerArray.indexOf( listener );
	
				if ( index !== - 1 ) {
	
					listenerArray.splice( index, 1 );
	
				}
	
			}
	
		},
	
		dispatchEvent: function ( event ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];
	
			if ( listenerArray !== undefined ) {
	
				event.target = this;
	
				var array = [];
				var length = listenerArray.length;
	
				for ( var i = 0; i < length; i ++ ) {
	
					array[ i ] = listenerArray[ i ];
	
				}
	
				for ( var i = 0; i < length; i ++ ) {
	
					array[ i ].call( this, event );
	
				}
	
			}
	
		}
	
	};
	
	// File:src/core/Raycaster.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://exocortex.com/
	 * @author stephomi / http://stephaneginier.com/
	 */
	
	( function ( THREE ) {
	
		THREE.Raycaster = function ( origin, direction, near, far ) {
	
			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
			this.params = {
				Sprite: {},
				Mesh: {},
				PointCloud: { threshold: 1 },
				LOD: {},
				Line: {}
			};
	
		};
	
		var descSort = function ( a, b ) {
	
			return a.distance - b.distance;
	
		};
	
		var intersectObject = function ( object, raycaster, intersects, recursive ) {
	
			object.raycast( raycaster, intersects );
	
			if ( recursive === true ) {
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					intersectObject( children[ i ], raycaster, intersects, true );
	
				}
	
			}
	
		};
	
		//
	
		THREE.Raycaster.prototype = {
	
			constructor: THREE.Raycaster,
	
			precision: 0.0001,
			linePrecision: 1,
	
			set: function ( origin, direction ) {
	
				// direction is assumed to be normalized (for accurate distance calculations)
	
				this.ray.set( origin, direction );
	
			},
	
			setFromCamera: function ( coords, camera ) {
	
				// camera is assumed _not_ to be a child of a transformed object
	
				if ( camera instanceof THREE.PerspectiveCamera ) {
	
					this.ray.origin.copy( camera.position );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();
	
				} else if ( camera instanceof THREE.OrthographicCamera ) {
	
					this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
				} else {
	
					THREE.error( 'THREE.Raycaster: Unsupported camera type.' );
	
				}
	
			},
	
			intersectObject: function ( object, recursive ) {
	
				var intersects = [];
	
				intersectObject( object, this, intersects, recursive );
	
				intersects.sort( descSort );
	
				return intersects;
	
			},
	
			intersectObjects: function ( objects, recursive ) {
	
				var intersects = [];
	
				if ( objects instanceof Array === false ) {
	
					THREE.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;
	
				}
	
				for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
					intersectObject( objects[ i ], this, intersects, recursive );
	
				}
	
				intersects.sort( descSort );
	
				return intersects;
	
			}
	
		};
	
	}( THREE ) );
	
	// File:src/core/Object3D.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Object3D = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Object3D';
	
		this.parent = undefined;
		this.children = [];
	
		this.up = THREE.Object3D.DefaultUp.clone();
	
		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );
	
		var onRotationChange = function () {
			quaternion.setFromEuler( rotation, false );
		};
	
		var onQuaternionChange = function () {
			rotation.setFromQuaternion( quaternion, undefined, false );
		};
	
		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );
	
		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			}
		} );
	
		this.rotationAutoUpdate = true;
	
		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();
	
		this.matrixAutoUpdate = true;
		this.matrixWorldNeedsUpdate = false;
	
		this.visible = true;
	
		this.castShadow = false;
		this.receiveShadow = false;
	
		this.frustumCulled = true;
		this.renderOrder = 0;
	
		this.userData = {};
	
	};
	
	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
	
	THREE.Object3D.prototype = {
	
		constructor: THREE.Object3D,
	
		get eulerOrder () {
	
			THREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );
	
			return this.rotation.order;
	
		},
	
		set eulerOrder ( value ) {
	
			THREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );
	
			this.rotation.order = value;
	
		},
	
		get useQuaternion () {
	
			THREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
		},
	
		set useQuaternion ( value ) {
	
			THREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
		},
	
		applyMatrix: function ( matrix ) {
	
			this.matrix.multiplyMatrices( matrix, this.matrix );
	
			this.matrix.decompose( this.position, this.quaternion, this.scale );
	
		},
	
		setRotationFromAxisAngle: function ( axis, angle ) {
	
			// assumes axis is normalized
	
			this.quaternion.setFromAxisAngle( axis, angle );
	
		},
	
		setRotationFromEuler: function ( euler ) {
	
			this.quaternion.setFromEuler( euler, true );
	
		},
	
		setRotationFromMatrix: function ( m ) {
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			this.quaternion.setFromRotationMatrix( m );
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			// assumes q is normalized
	
			this.quaternion.copy( q );
	
		},
	
		rotateOnAxis: function () {
	
			// rotate object on axis in object space
			// axis is assumed to be normalized
	
			var q1 = new THREE.Quaternion();
	
			return function ( axis, angle ) {
	
				q1.setFromAxisAngle( axis, angle );
	
				this.quaternion.multiply( q1 );
	
				return this;
	
			}
	
		}(),
	
		rotateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		translateOnAxis: function () {
	
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
	
			var v1 = new THREE.Vector3();
	
			return function ( axis, distance ) {
	
				v1.copy( axis ).applyQuaternion( this.quaternion );
	
				this.position.add( v1.multiplyScalar( distance ) );
	
				return this;
	
			}
	
		}(),
	
		translate: function ( distance, axis ) {
	
			THREE.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );
	
		},
	
		translateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		localToWorld: function ( vector ) {
	
			return vector.applyMatrix4( this.matrixWorld );
	
		},
	
		worldToLocal: function () {
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
			};
	
		}(),
	
		lookAt: function () {
	
			// This routine does not support objects with rotated and/or translated parent(s)
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				m1.lookAt( vector, this.position, this.up );
	
				this.quaternion.setFromRotationMatrix( m1 );
	
			};
	
		}(),
	
		add: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.add( arguments[ i ] );
	
				}
	
				return this;
	
			};
	
			if ( object === this ) {
	
				THREE.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;
	
			}
	
			if ( object instanceof THREE.Object3D ) {
	
				if ( object.parent !== undefined ) {
	
					object.parent.remove( object );
	
				}
	
				object.parent = this;
				object.dispatchEvent( { type: 'added' } );
	
				this.children.push( object );
	
			} else {
	
				THREE.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
			}
	
			return this;
	
		},
	
		remove: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.remove( arguments[ i ] );
	
				}
	
			};
	
			var index = this.children.indexOf( object );
	
			if ( index !== - 1 ) {
	
				object.parent = undefined;
	
				object.dispatchEvent( { type: 'removed' } );
	
				this.children.splice( index, 1 );
	
			}
	
		},
	
		getChildByName: function ( name ) {
	
			THREE.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );
	
		},
	
		getObjectById: function ( id ) {
	
			return this.getObjectByProperty( 'id', id );
	
		},
	
		getObjectByName: function ( name ) {
	
			return this.getObjectByProperty( 'name', name );
	
		},
	
		getObjectByProperty: function ( name, value ) {
	
			if ( this[ name ] === value ) return this;
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );
	
				if ( object !== undefined ) {
	
					return object;
	
				}
	
			}
	
			return undefined;
	
		},
	
		getWorldPosition: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.updateMatrixWorld( true );
	
			return result.setFromMatrixPosition( this.matrixWorld );
	
		},
	
		getWorldQuaternion: function () {
	
			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Quaternion();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, result, scale );
	
				return result;
	
			}
	
		}(),
	
		getWorldRotation: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Euler();
	
				this.getWorldQuaternion( quaternion );
	
				return result.setFromQuaternion( quaternion, this.rotation.order, false );
	
			}
	
		}(),
	
		getWorldScale: function () {
	
			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, quaternion, result );
	
				return result;
	
			}
	
		}(),
	
		getWorldDirection: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.getWorldQuaternion( quaternion );
	
				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
			}
	
		}(),
	
		raycast: function () {},
	
		traverse: function ( callback ) {
	
			callback( this );
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].traverse( callback );
	
			}
	
		},
	
		traverseVisible: function ( callback ) {
	
			if ( this.visible === false ) return;
	
			callback( this );
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].traverseVisible( callback );
	
			}
	
		},
	
		traverseAncestors: function ( callback ) {
	
			if ( this.parent ) {
	
				callback( this.parent );
	
				this.parent.traverseAncestors( callback );
	
			}
	
		},
	
		updateMatrix: function () {
	
			this.matrix.compose( this.position, this.quaternion, this.scale );
	
			this.matrixWorldNeedsUpdate = true;
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
			if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
				if ( this.parent === undefined ) {
	
					this.matrixWorld.copy( this.matrix );
	
				} else {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				}
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].updateMatrixWorld( force );
	
			}
	
		},
	
		toJSON: function () {
	
			var output = {
				metadata: {
					version: 4.3,
					type: 'Object',
					generator: 'ObjectExporter'
				}
			};
	
			//
	
			var geometries = {};
	
			var parseGeometry = function ( geometry ) {
	
				if ( output.geometries === undefined ) {
	
					output.geometries = [];
	
				}
	
				if ( geometries[ geometry.uuid ] === undefined ) {
	
					var json = geometry.toJSON();
	
					delete json.metadata;
	
					geometries[ geometry.uuid ] = json;
	
					output.geometries.push( json );
	
				}
	
				return geometry.uuid;
	
			};
	
			//
	
			var materials = {};
	
			var parseMaterial = function ( material ) {
	
				if ( output.materials === undefined ) {
	
					output.materials = [];
	
				}
	
				if ( materials[ material.uuid ] === undefined ) {
	
					var json = material.toJSON();
	
					delete json.metadata;
	
					materials[ material.uuid ] = json;
	
					output.materials.push( json );
	
				}
	
				return material.uuid;
	
			};
	
			//
	
			var parseObject = function ( object ) {
	
				var data = {};
	
				data.uuid = object.uuid;
				data.type = object.type;
	
				if ( object.name !== '' ) data.name = object.name;
				if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;
				if ( object.visible !== true ) data.visible = object.visible;
	
				if ( object instanceof THREE.PerspectiveCamera ) {
	
					data.fov = object.fov;
					data.aspect = object.aspect;
					data.near = object.near;
					data.far = object.far;
	
				} else if ( object instanceof THREE.OrthographicCamera ) {
	
					data.left = object.left;
					data.right = object.right;
					data.top = object.top;
					data.bottom = object.bottom;
					data.near = object.near;
					data.far = object.far;
	
				} else if ( object instanceof THREE.AmbientLight ) {
	
					data.color = object.color.getHex();
	
				} else if ( object instanceof THREE.DirectionalLight ) {
	
					data.color = object.color.getHex();
					data.intensity = object.intensity;
	
				} else if ( object instanceof THREE.PointLight ) {
	
					data.color = object.color.getHex();
					data.intensity = object.intensity;
					data.distance = object.distance;
					data.decay = object.decay;
	
				} else if ( object instanceof THREE.SpotLight ) {
	
					data.color = object.color.getHex();
					data.intensity = object.intensity;
					data.distance = object.distance;
					data.angle = object.angle;
					data.exponent = object.exponent;
					data.decay = object.decay;
	
				} else if ( object instanceof THREE.HemisphereLight ) {
	
					data.color = object.color.getHex();
					data.groundColor = object.groundColor.getHex();
	
				} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {
	
					data.geometry = parseGeometry( object.geometry );
					data.material = parseMaterial( object.material );
	
					if ( object instanceof THREE.Line ) data.mode = object.mode;
	
				} else if ( object instanceof THREE.Sprite ) {
	
					data.material = parseMaterial( object.material );
	
				}
	
				data.matrix = object.matrix.toArray();
	
				if ( object.children.length > 0 ) {
	
					data.children = [];
	
					for ( var i = 0; i < object.children.length; i ++ ) {
	
						data.children.push( parseObject( object.children[ i ] ) );
	
					}
	
				}
	
				return data;
	
			}
	
			output.object = parseObject( this );
	
			return output;
	
		},
	
		clone: function ( object, recursive ) {
	
			if ( object === undefined ) object = new THREE.Object3D();
			if ( recursive === undefined ) recursive = true;
	
			object.name = this.name;
	
			object.up.copy( this.up );
	
			object.position.copy( this.position );
			object.quaternion.copy( this.quaternion );
			object.scale.copy( this.scale );
	
			object.rotationAutoUpdate = this.rotationAutoUpdate;
	
			object.matrix.copy( this.matrix );
			object.matrixWorld.copy( this.matrixWorld );
	
			object.matrixAutoUpdate = this.matrixAutoUpdate;
			object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
	
			object.visible = this.visible;
	
			object.castShadow = this.castShadow;
			object.receiveShadow = this.receiveShadow;
	
			object.frustumCulled = this.frustumCulled;
	
			object.userData = JSON.parse( JSON.stringify( this.userData ) );
	
			if ( recursive === true ) {
	
				for ( var i = 0; i < this.children.length; i ++ ) {
	
					var child = this.children[ i ];
					object.add( child.clone() );
	
				}
	
			}
	
			return object;
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );
	
	THREE.Object3DIdCount = 0;
	
	// File:src/core/Face3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {
	
		this.a = a;
		this.b = b;
		this.c = c;
	
		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = normal instanceof Array ? normal : [];
	
		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = color instanceof Array ? color : [];
	
		this.vertexTangents = [];
	
		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
	};
	
	THREE.Face3.prototype = {
	
		constructor: THREE.Face3,
	
		clone: function () {
	
			var face = new THREE.Face3( this.a, this.b, this.c );
	
			face.normal.copy( this.normal );
			face.color.copy( this.color );
	
			face.materialIndex = this.materialIndex;
	
			for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {
	
				face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
	
			}
	
			for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {
	
				face.vertexColors[ i ] = this.vertexColors[ i ].clone();
	
			}
	
			for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {
	
				face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();
	
			}
	
			return face;
	
		}
	
	};
	
	// File:src/core/Face4.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {
	
		THREE.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )
		return new THREE.Face3( a, b, c, normal, color, materialIndex );
	
	};
	
	// File:src/core/BufferAttribute.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferAttribute = function ( array, itemSize ) {
	
		this.array = array;
		this.itemSize = itemSize;
	
		this.needsUpdate = false;
	
	};
	
	THREE.BufferAttribute.prototype = {
	
		constructor: THREE.BufferAttribute,
	
		get length () {
	
			return this.array.length;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;
	
			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		setX: function ( index, x ) {
	
			this.array[ index * this.itemSize ] = x;
	
			return this;
	
		},
	
		setY: function ( index, y ) {
	
			this.array[ index * this.itemSize + 1 ] = y;
	
			return this;
	
		},
	
		setZ: function ( index, z ) {
	
			this.array[ index * this.itemSize + 2 ] = z;
	
			return this;
	
		},
	
		setXY: function ( index, x, y ) {
	
			index *= this.itemSize;
	
			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index *= this.itemSize;
	
			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index *= this.itemSize;
	
			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;
	
			return this;
	
		},
	
		clone: function () {
	
			return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );
	
		}
	
	};
	
	//
	
	THREE.Int8Attribute = function ( data, itemSize ) {
	
		THREE.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );
	
	};
	
	THREE.Uint8Attribute = function ( data, itemSize ) {
	
		THREE.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );
	
	};
	
	THREE.Uint8ClampedAttribute = function ( data, itemSize ) {
	
		THREE.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );
	
	
	};
	
	THREE.Int16Attribute = function ( data, itemSize ) {
	
		THREE.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );
	
	};
	
	THREE.Uint16Attribute = function ( data, itemSize ) {
	
		THREE.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );
	
	};
	
	THREE.Int32Attribute = function ( data, itemSize ) {
	
		THREE.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );
	
	};
	
	THREE.Uint32Attribute = function ( data, itemSize ) {
	
		THREE.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );
	
	};
	
	THREE.Float32Attribute = function ( data, itemSize ) {
	
		THREE.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );
	
	};
	
	THREE.Float64Attribute = function ( data, itemSize ) {
	
		THREE.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );
	
	};
	
	// File:src/core/DynamicBufferAttribute.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.DynamicBufferAttribute = function ( array, itemSize ) {
	
		THREE.BufferAttribute.call( this, array, itemSize );
	
		this.updateRange = { offset: 0, count: -1 };
	
	};
	
	THREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;
	
	THREE.DynamicBufferAttribute.prototype.clone = function () {
	
		return new THREE.DynamicBufferAttribute( new this.array.constructor( this.array ), this.itemSize );
	
	};
	
	// File:src/core/BufferGeometry.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'BufferGeometry';
	
		this.attributes = {};
		this.attributesKeys = [];
	
		this.drawcalls = [];
		this.offsets = this.drawcalls; // backwards compatibility
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
	};
	
	THREE.BufferGeometry.prototype = {
	
		constructor: THREE.BufferGeometry,
	
		addAttribute: function ( name, attribute ) {
	
			if ( attribute instanceof THREE.BufferAttribute === false ) {
	
				THREE.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
				this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };
	
				return;
	
			}
	
			this.attributes[ name ] = attribute;
			this.attributesKeys = Object.keys( this.attributes );
	
		},
	
		getAttribute: function ( name ) {
	
			return this.attributes[ name ];
	
		},
	
		addDrawCall: function ( start, count, indexOffset ) {
	
			this.drawcalls.push( {
	
				start: start,
				count: count,
				index: indexOffset !== undefined ? indexOffset : 0
	
			} );
	
		},
	
		applyMatrix: function ( matrix ) {
	
			var position = this.attributes.position;
	
			if ( position !== undefined ) {
	
				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;
	
			}
	
			var normal = this.attributes.normal;
	
			if ( normal !== undefined ) {
	
				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
		},
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );
	
			return offset;
	
		},
	
		fromGeometry: function ( geometry, settings ) {
	
			settings = settings || { 'vertexColors': THREE.NoColors };
	
			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var faceVertexUvs = geometry.faceVertexUvs;
			var vertexColors = settings.vertexColors;
			var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;
	
			var positions = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	
			var normals = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	
			if ( vertexColors !== THREE.NoColors ) {
	
				var colors = new Float32Array( faces.length * 3 * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
	
			}
	
			if ( hasFaceVertexUv === true ) {
	
				var uvs = new Float32Array( faces.length * 3 * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
			}
	
			for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {
	
				var face = faces[ i ];
	
				var a = vertices[ face.a ];
				var b = vertices[ face.b ];
				var c = vertices[ face.c ];
	
				positions[ i3     ] = a.x;
				positions[ i3 + 1 ] = a.y;
				positions[ i3 + 2 ] = a.z;
	
				positions[ i3 + 3 ] = b.x;
				positions[ i3 + 4 ] = b.y;
				positions[ i3 + 5 ] = b.z;
	
				positions[ i3 + 6 ] = c.x;
				positions[ i3 + 7 ] = c.y;
				positions[ i3 + 8 ] = c.z;
	
				if ( hasFaceVertexNormals === true ) {
	
					var na = face.vertexNormals[ 0 ];
					var nb = face.vertexNormals[ 1 ];
					var nc = face.vertexNormals[ 2 ];
	
					normals[ i3     ] = na.x;
					normals[ i3 + 1 ] = na.y;
					normals[ i3 + 2 ] = na.z;
	
					normals[ i3 + 3 ] = nb.x;
					normals[ i3 + 4 ] = nb.y;
					normals[ i3 + 5 ] = nb.z;
	
					normals[ i3 + 6 ] = nc.x;
					normals[ i3 + 7 ] = nc.y;
					normals[ i3 + 8 ] = nc.z;
	
				} else {
	
					var n = face.normal;
	
					normals[ i3     ] = n.x;
					normals[ i3 + 1 ] = n.y;
					normals[ i3 + 2 ] = n.z;
	
					normals[ i3 + 3 ] = n.x;
					normals[ i3 + 4 ] = n.y;
					normals[ i3 + 5 ] = n.z;
	
					normals[ i3 + 6 ] = n.x;
					normals[ i3 + 7 ] = n.y;
					normals[ i3 + 8 ] = n.z;
	
				}
	
				if ( vertexColors === THREE.FaceColors ) {
	
					var fc = face.color;
	
					colors[ i3     ] = fc.r;
					colors[ i3 + 1 ] = fc.g;
					colors[ i3 + 2 ] = fc.b;
	
					colors[ i3 + 3 ] = fc.r;
					colors[ i3 + 4 ] = fc.g;
					colors[ i3 + 5 ] = fc.b;
	
					colors[ i3 + 6 ] = fc.r;
					colors[ i3 + 7 ] = fc.g;
					colors[ i3 + 8 ] = fc.b;
	
				} else if ( vertexColors === THREE.VertexColors ) {
	
					var vca = face.vertexColors[ 0 ];
					var vcb = face.vertexColors[ 1 ];
					var vcc = face.vertexColors[ 2 ];
	
					colors[ i3     ] = vca.r;
					colors[ i3 + 1 ] = vca.g;
					colors[ i3 + 2 ] = vca.b;
	
					colors[ i3 + 3 ] = vcb.r;
					colors[ i3 + 4 ] = vcb.g;
					colors[ i3 + 5 ] = vcb.b;
	
					colors[ i3 + 6 ] = vcc.r;
					colors[ i3 + 7 ] = vcc.g;
					colors[ i3 + 8 ] = vcc.b;
	
				}
	
				if ( hasFaceVertexUv === true ) {
	
					var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
					var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
					var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];
	
					uvs[ i2     ] = uva.x;
					uvs[ i2 + 1 ] = uva.y;
	
					uvs[ i2 + 2 ] = uvb.x;
					uvs[ i2 + 3 ] = uvb.y;
	
					uvs[ i2 + 4 ] = uvc.x;
					uvs[ i2 + 5 ] = uvc.y;
	
				}
	
			}
	
			this.computeBoundingSphere()
	
			return this;
	
		},
	
		computeBoundingBox: function () {
	
			var vector = new THREE.Vector3();
	
			return function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new THREE.Box3();
	
				}
	
				var positions = this.attributes.position.array;
	
				if ( positions ) {
	
					var bb = this.boundingBox;
					bb.makeEmpty();
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						bb.expandByPoint( vector );
	
					}
	
				}
	
				if ( positions === undefined || positions.length === 0 ) {
	
					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );
	
				}
	
				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
					THREE.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.' );
	
				}
	
			}
	
		}(),
	
		computeBoundingSphere: function () {
	
			var box = new THREE.Box3();
			var vector = new THREE.Vector3();
	
			return function () {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new THREE.Sphere();
	
				}
	
				var positions = this.attributes.position.array;
	
				if ( positions ) {
	
					box.makeEmpty();
	
					var center = this.boundingSphere.center;
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						box.expandByPoint( vector );
	
					}
	
					box.center( center );
	
					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
					}
	
					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
					if ( isNaN( this.boundingSphere.radius ) ) {
	
						THREE.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );
	
					}
	
				}
	
			}
	
		}(),
	
		computeFaceNormals: function () {
	
			// backwards compatibility
	
		},
	
		computeVertexNormals: function () {
	
			var attributes = this.attributes;
	
			if ( attributes.position ) {
	
				var positions = attributes.position.array;
	
				if ( attributes.normal === undefined ) {
	
					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
				} else {
	
					// reset existing normals to zero
	
					var normals = attributes.normal.array;
	
					for ( var i = 0, il = normals.length; i < il; i ++ ) {
	
						normals[ i ] = 0;
	
					}
	
				}
	
				var normals = attributes.normal.array;
	
				var vA, vB, vC,
	
				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),
	
				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();
	
				// indexed elements
	
				if ( attributes.index ) {
	
					var indices = attributes.index.array;
	
					var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );
	
					for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {
	
						var start = offsets[ j ].start;
						var count = offsets[ j ].count;
						var index = offsets[ j ].index;
	
						for ( var i = start, il = start + count; i < il; i += 3 ) {
	
							vA = ( index + indices[ i     ] ) * 3;
							vB = ( index + indices[ i + 1 ] ) * 3;
							vC = ( index + indices[ i + 2 ] ) * 3;
	
							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ vA     ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;
	
							normals[ vB     ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;
	
							normals[ vC     ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;
	
						}
	
					}
	
				} else {
	
					// non-indexed elements (unconnected triangle soup)
	
					for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );
	
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
	
						normals[ i     ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;
	
						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;
	
						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;
	
					}
	
				}
	
				this.normalizeNormals();
	
				attributes.normal.needsUpdate = true;
	
			}
	
		},
	
		computeTangents: function () {
	
			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)
	
			if ( this.attributes.index === undefined ||
				 this.attributes.position === undefined ||
				 this.attributes.normal === undefined ||
				 this.attributes.uv === undefined ) {
	
				THREE.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
				return;
	
			}
	
			var indices = this.attributes.index.array;
			var positions = this.attributes.position.array;
			var normals = this.attributes.normal.array;
			var uvs = this.attributes.uv.array;
	
			var nVertices = positions.length / 3;
	
			if ( this.attributes.tangent === undefined ) {
	
				this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );
	
			}
	
			var tangents = this.attributes.tangent.array;
	
			var tan1 = [], tan2 = [];
	
			for ( var k = 0; k < nVertices; k ++ ) {
	
				tan1[ k ] = new THREE.Vector3();
				tan2[ k ] = new THREE.Vector3();
	
			}
	
			var vA = new THREE.Vector3(),
				vB = new THREE.Vector3(),
				vC = new THREE.Vector3(),
	
				uvA = new THREE.Vector2(),
				uvB = new THREE.Vector2(),
				uvC = new THREE.Vector2(),
	
				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r;
	
			var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();
	
			function handleTriangle( a, b, c ) {
	
				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );
	
				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );
	
				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;
	
				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;
	
				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;
	
				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;
	
				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;
	
				r = 1.0 / ( s1 * t2 - s2 * t1 );
	
				sdir.set(
					( t2 * x1 - t1 * x2 ) * r,
					( t2 * y1 - t1 * y2 ) * r,
					( t2 * z1 - t1 * z2 ) * r
				);
	
				tdir.set(
					( s1 * x2 - s2 * x1 ) * r,
					( s1 * y2 - s2 * y1 ) * r,
					( s1 * z2 - s2 * z1 ) * r
				);
	
				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );
	
				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );
	
			}
	
			var i, il;
			var j, jl;
			var iA, iB, iC;
	
			if ( this.drawcalls.length === 0 ) {
	
				this.addDrawCall( 0, indices.length, 0 );
	
			}
	
			var drawcalls = this.drawcalls;
	
			for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {
	
				var start = drawcalls[ j ].start;
				var count = drawcalls[ j ].count;
				var index = drawcalls[ j ].index;
	
				for ( i = start, il = start + count; i < il; i += 3 ) {
	
					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];
	
					handleTriangle( iA, iB, iC );
	
				}
	
			}
	
			var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
			var n = new THREE.Vector3(), n2 = new THREE.Vector3();
			var w, t, test;
	
			function handleVertex( v ) {
	
				n.fromArray( normals, v * 3 );
				n2.copy( n );
	
				t = tan1[ v ];
	
				// Gram-Schmidt orthogonalize
	
				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();
	
				// Calculate handedness
	
				tmp2.crossVectors( n2, t );
				test = tmp2.dot( tan2[ v ] );
				w = ( test < 0.0 ) ? - 1.0 : 1.0;
	
				tangents[ v * 4     ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;
	
			}
	
			for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {
	
				var start = drawcalls[ j ].start;
				var count = drawcalls[ j ].count;
				var index = drawcalls[ j ].index;
	
				for ( i = start, il = start + count; i < il; i += 3 ) {
	
					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];
	
					handleVertex( iA );
					handleVertex( iB );
					handleVertex( iC );
	
				}
	
			}
	
		},
	
		/*
		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
		size - Defaults to 65535, but allows for larger or smaller chunks.
		*/
		computeOffsets: function ( size ) {
	
			if ( size === undefined ) size = 65535; // WebGL limits type of index buffer values to 16-bit.
	
			var indices = this.attributes.index.array;
			var vertices = this.attributes.position.array;
	
			var facesCount = ( indices.length / 3 );
	
			/*
			console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
			console.log("Faces to process: "+(indices.length/3));
			console.log("Reordering "+verticesCount+" vertices.");
			*/
	
			var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
			var indexPtr = 0;
			var vertexPtr = 0;
	
			var offsets = [ { start:0, count:0, index:0 } ];
			var offset = offsets[ 0 ];
	
			var duplicatedVertices = 0;
			var newVerticeMaps = 0;
			var faceVertices = new Int32Array( 6 );
			var vertexMap = new Int32Array( vertices.length );
			var revVertexMap = new Int32Array( vertices.length );
			for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }
	
			/*
				Traverse every face and reorder vertices in the proper offsets of 65k.
				We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
			*/
			for ( var findex = 0; findex < facesCount; findex ++ ) {
				newVerticeMaps = 0;
	
				for ( var vo = 0; vo < 3; vo ++ ) {
					var vid = indices[ findex * 3 + vo ];
					if ( vertexMap[ vid ] == - 1 ) {
						//Unmapped vertice
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = - 1;
						newVerticeMaps ++;
					} else if ( vertexMap[ vid ] < offset.index ) {
						//Reused vertices from previous block (duplicate)
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = - 1;
						duplicatedVertices ++;
					} else {
						//Reused vertice in the current block
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
					}
				}
	
				var faceMax = vertexPtr + newVerticeMaps;
				if ( faceMax > ( offset.index + size ) ) {
					var new_offset = { start:indexPtr, count:0, index:vertexPtr };
					offsets.push( new_offset );
					offset = new_offset;
	
					//Re-evaluate reused vertices in light of new offset.
					for ( var v = 0; v < 6; v += 2 ) {
						var new_vid = faceVertices[ v + 1 ];
						if ( new_vid > - 1 && new_vid < offset.index )
							faceVertices[ v + 1 ] = - 1;
					}
				}
	
				//Reindex the face.
				for ( var v = 0; v < 6; v += 2 ) {
					var vid = faceVertices[ v ];
					var new_vid = faceVertices[ v + 1 ];
	
					if ( new_vid === - 1 )
						new_vid = vertexPtr ++;
	
					vertexMap[ vid ] = new_vid;
					revVertexMap[ new_vid ] = vid;
					sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
					offset.count ++;
				}
			}
	
			/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
			this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
			this.offsets = offsets; // TODO: Deprecate
			this.drawcalls = offsets;
	
			/*
			var orderTime = Date.now();
			console.log("Reorder time: "+(orderTime-s)+"ms");
			console.log("Duplicated "+duplicatedVertices+" vertices.");
			console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
			console.log("Draw offsets: "+offsets.length);
			*/
	
			return offsets;
	
		},
	
		merge: function ( geometry, offset ) {
	
			if ( geometry instanceof THREE.BufferGeometry === false ) {
	
				THREE.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;
	
			}
	
			if ( offset === undefined ) offset = 0;
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				if ( geometry.attributes[ key ] === undefined ) continue;
	
				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;
	
				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;
	
				var attributeSize = attribute2.itemSize;
	
				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
					attributeArray1[ j ] = attributeArray2[ i ];
	
				}
	
			}
	
			return this;
	
		},
	
		normalizeNormals: function () {
	
			var normals = this.attributes.normal.array;
	
			var x, y, z, n;
	
			for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];
	
				n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
				normals[ i     ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;
	
			}
	
		},
	
		/*
			reoderBuffers:
			Reorder attributes based on a new indexBuffer and indexMap.
			indexBuffer - Uint16Array of the new ordered indices.
			indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
			vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
		*/
		reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {
	
			/* Create a copy of all attributes for reordering. */
			var sortedAttributes = {};
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				var sourceArray = this.attributes[ attr ].array;
				sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
			}
	
			/* Move attribute positions based on the new index map */
			for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
				var vid = indexMap[ new_vid ];
				for ( var attr in this.attributes ) {
					if ( attr == 'index' )
						continue;
					var attrArray = this.attributes[ attr ].array;
					var attrSize = this.attributes[ attr ].itemSize;
					var sortedAttr = sortedAttributes[ attr ];
					for ( var k = 0; k < attrSize; k ++ )
						sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
				}
			}
	
			/* Carry the new sorted buffers locally */
			this.attributes[ 'index' ].array = indexBuffer;
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				this.attributes[ attr ].array = sortedAttributes[ attr ];
				this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
			}
		},
	
		toJSON: function () {
	
			var output = {
				metadata: {
					version: 4.0,
					type: 'BufferGeometry',
					generator: 'BufferGeometryExporter'
				},
				uuid: this.uuid,
				type: this.type,
				data: {
					attributes: {}
				}
			};
	
			var attributes = this.attributes;
			var offsets = this.offsets;
			var boundingSphere = this.boundingSphere;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
	
				var array = Array.prototype.slice.call( attribute.array );
	
				output.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				}
	
			}
	
			if ( offsets.length > 0 ) {
	
				output.data.offsets = JSON.parse( JSON.stringify( offsets ) );
	
			}
	
			if ( boundingSphere !== null ) {
	
				output.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				}
	
			}
	
			return output;
	
		},
	
		clone: function () {
	
			var geometry = new THREE.BufferGeometry();
	
			for ( var attr in this.attributes ) {
	
				var sourceAttr = this.attributes[ attr ];
				geometry.addAttribute( attr, sourceAttr.clone() );
	
			}
	
			for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {
	
				var offset = this.offsets[ i ];
	
				geometry.offsets.push( {
	
					start: offset.start,
					index: offset.index,
					count: offset.count
	
				} );
	
			}
	
			return geometry;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );
	
	// File:src/core/Geometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Geometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Geometry';
	
		this.vertices = [];
		this.colors = [];  // one-to-one vertex colors, used in Points and Line
	
		this.faces = [];
	
		this.faceVertexUvs = [ [] ];
	
		this.morphTargets = [];
		this.morphColors = [];
		this.morphNormals = [];
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.hasTangents = false;
	
		this.dynamic = true; // the intermediate typed arrays will be deleted when set to false
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.tangentsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
	
		this.groupsNeedUpdate = false;
	
	};
	
	THREE.Geometry.prototype = {
	
		constructor: THREE.Geometry,
	
		applyMatrix: function ( matrix ) {
	
			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );
	
			}
	
			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
				}
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;
	
		},
	
		fromBufferGeometry: function ( geometry ) {
	
			var scope = this;
	
			var attributes = geometry.attributes;
	
			var vertices = attributes.position.array;
			var indices = attributes.index !== undefined ? attributes.index.array : undefined;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
	
			var tempNormals = [];
			var tempUVs = [];
	
			for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {
	
				scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );
	
				if ( normals !== undefined ) {
	
					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
	
				}
	
				if ( colors !== undefined ) {
	
					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
	
				}
	
				if ( uvs !== undefined ) {
	
					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );
	
				}
	
			}
	
			var addFace = function ( a, b, c ) {
	
				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
	
				scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );
	
				if ( uvs !== undefined ) {
	
					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
	
				}
	
			};
	
			if ( indices !== undefined ) {
	
				var drawcalls = geometry.drawcalls;
	
				if ( drawcalls.length > 0 ) {
	
					for ( var i = 0; i < drawcalls.length; i ++ ) {
	
						var drawcall = drawcalls[ i ];
	
						var start = drawcall.start;
						var count = drawcall.count;
						var index = drawcall.index;
	
						for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
							addFace( index + indices[ j ], index + indices[ j + 1 ], index + indices[ j + 2 ] );
	
						}
	
					}
	
				} else {
	
					for ( var i = 0; i < indices.length; i += 3 ) {
	
						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
					}
	
				}
	
			} else {
	
				for ( var i = 0; i < vertices.length / 3; i += 3 ) {
	
					addFace( i, i + 1, i + 2 );
	
				}
	
			}
	
			this.computeFaceNormals();
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			return this;
	
		},
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );
	
			return offset;
	
		},
	
		computeFaceNormals: function () {
	
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				var face = this.faces[ f ];
	
				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];
	
				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
	
				cb.normalize();
	
				face.normal.copy( cb );
	
			}
	
		},
	
		computeVertexNormals: function ( areaWeighted ) {
	
			var v, vl, f, fl, face, vertices;
	
			vertices = new Array( this.vertices.length );
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ] = new THREE.Vector3();
	
			}
	
			if ( areaWeighted ) {
	
				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm
	
				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );
	
				}
	
			} else {
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );
	
				}
	
			}
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ].normalize();
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
				face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
				face.vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
			}
	
		},
	
		computeMorphNormals: function () {
	
			var i, il, f, fl, face;
	
			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				if ( ! face.__originalFaceNormal ) {
	
					face.__originalFaceNormal = face.normal.clone();
	
				} else {
	
					face.__originalFaceNormal.copy( face.normal );
	
				}
	
				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
					if ( ! face.__originalVertexNormals[ i ] ) {
	
						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
					} else {
	
						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
					}
	
				}
	
			}
	
			// use temp geometry to compute face and vertex normals for each morph
	
			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;
	
			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
				// create on first access
	
				if ( ! this.morphNormals[ i ] ) {
	
					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];
	
					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };
	
						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );
	
					}
	
				}
	
				var morphNormals = this.morphNormals[ i ];
	
				// set vertices to morph target
	
				tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
				// compute morph normals
	
				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();
	
				// store morph normals
	
				var faceNormal, vertexNormals;
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];
	
					faceNormal.copy( face.normal );
	
					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
				}
	
			}
	
			// restore original normals
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
	
			}
	
		},
	
		computeTangents: function () {
	
			// based on http://www.terathon.com/code/tangent.html
			// tangents go to vertices
	
			var f, fl, v, vl, i, vertexIndex,
				face, uv, vA, vB, vC, uvA, uvB, uvC,
				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r, t, test,
				tan1 = [], tan2 = [],
				sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
				tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
				n = new THREE.Vector3(), w;
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				tan1[ v ] = new THREE.Vector3();
				tan2[ v ] = new THREE.Vector3();
	
			}
	
			function handleTriangle( context, a, b, c, ua, ub, uc ) {
	
				vA = context.vertices[ a ];
				vB = context.vertices[ b ];
				vC = context.vertices[ c ];
	
				uvA = uv[ ua ];
				uvB = uv[ ub ];
				uvC = uv[ uc ];
	
				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;
				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;
				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;
	
				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;
				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;
	
				r = 1.0 / ( s1 * t2 - s2 * t1 );
				sdir.set( ( t2 * x1 - t1 * x2 ) * r,
						  ( t2 * y1 - t1 * y2 ) * r,
						  ( t2 * z1 - t1 * z2 ) * r );
				tdir.set( ( s1 * x2 - s2 * x1 ) * r,
						  ( s1 * y2 - s2 * y1 ) * r,
						  ( s1 * z2 - s2 * z1 ) * r );
	
				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );
	
				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
				uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents
	
				handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );
	
			}
	
			var faceIndex = [ 'a', 'b', 'c', 'd' ];
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {
	
					n.copy( face.vertexNormals[ i ] );
	
					vertexIndex = face[ faceIndex[ i ] ];
	
					t = tan1[ vertexIndex ];
	
					// Gram-Schmidt orthogonalize
	
					tmp.copy( t );
					tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();
	
					// Calculate handedness
	
					tmp2.crossVectors( face.vertexNormals[ i ], t );
					test = tmp2.dot( tan2[ vertexIndex ] );
					w = ( test < 0.0 ) ? - 1.0 : 1.0;
	
					face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );
	
				}
	
			}
	
			this.hasTangents = true;
	
		},
	
		computeLineDistances: function () {
	
			var d = 0;
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				if ( i > 0 ) {
	
					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
				}
	
				this.lineDistances[ i ] = d;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			this.boundingBox.setFromPoints( this.vertices );
	
		},
	
		computeBoundingSphere: function () {
	
			if ( this.boundingSphere === null ) {
	
				this.boundingSphere = new THREE.Sphere();
	
			}
	
			this.boundingSphere.setFromPoints( this.vertices );
	
		},
	
		merge: function ( geometry, matrix, materialIndexOffset ) {
	
			if ( geometry instanceof THREE.Geometry === false ) {
	
				THREE.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;
	
			}
	
			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];
	
			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
			if ( matrix !== undefined ) {
	
				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			}
	
			// vertices
	
			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
				var vertex = vertices2[ i ];
	
				var vertexCopy = vertex.clone();
	
				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
				vertices1.push( vertexCopy );
	
			}
	
			// faces
	
			for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;
	
				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );
	
				if ( normalMatrix !== undefined ) {
	
					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
				}
	
				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
					normal = faceVertexNormals[ j ].clone();
	
					if ( normalMatrix !== undefined ) {
	
						normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					faceCopy.vertexNormals.push( normal );
	
				}
	
				faceCopy.color.copy( face.color );
	
				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );
	
				}
	
				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
				faces1.push( faceCopy );
	
			}
	
			// uvs
	
			for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
				var uv = uvs2[ i ], uvCopy = [];
	
				if ( uv === undefined ) {
	
					continue;
	
				}
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( uv[ j ].clone() );
	
				}
	
				uvs1.push( uvCopy );
	
			}
	
		},
	
		mergeMesh: function ( mesh ) {
	
			if ( mesh instanceof THREE.Mesh === false ) {
	
				THREE.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;
	
			}
	
			mesh.matrixAutoUpdate && mesh.updateMatrix();
	
			this.merge( mesh.geometry, mesh.matrix );
	
		},
	
		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */
	
		mergeVertices: function () {
	
			var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
			var unique = [], changes = [];
	
			var v, key;
			var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;
	
			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
				if ( verticesMap[ key ] === undefined ) {
	
					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;
	
				} else {
	
					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];
	
				}
	
			};
	
	
			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];
	
			for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
				face = this.faces[ i ];
	
				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
	
				indices = [ face.a, face.b, face.c ];
	
				var dupIndex = - 1;
	
				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
					if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {
	
						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;
	
					}
				}
	
			}
	
			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
				var idx = faceIndicesToRemove[ i ];
	
				this.faces.splice( idx, 1 );
	
				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
					this.faceVertexUvs[ j ].splice( idx, 1 );
	
				}
	
			}
	
			// Use unique set of vertices
	
			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
	
		},
	
		toJSON: function () {
	
			var output = {
				metadata: {
					version: 4.0,
					type: 'BufferGeometry',
					generator: 'BufferGeometryExporter'
				},
				uuid: this.uuid,
				type: this.type
			};
	
			if ( this.name !== "" ) output.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];
	
				}
	
				return output;
	
			}
	
			var vertices = [];
	
			for ( var i = 0; i < this.vertices.length; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};
	
			for ( var i = 0; i < this.faces.length; i ++ ) {
	
				var face = this.faces[ i ];
	
				var hasMaterial = false; // face.materialIndex !== undefined;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;
	
				var faceType = 0;
	
				faceType = setBit( faceType, 0, 0 );
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );
	
				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
	
	
				/*
				if ( hasMaterial ) {
	
					faces.push( face.materialIndex );
	
				}
				*/
	
				if ( hasFaceVertexUv ) {
	
					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);
	
				}
	
				if ( hasFaceNormal ) {
	
					faces.push( getNormalIndex( face.normal ) );
	
				}
	
				if ( hasFaceVertexNormal ) {
	
					var vertexNormals = face.vertexNormals;
	
					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);
	
				}
	
				if ( hasFaceColor ) {
	
					faces.push( getColorIndex( face.color ) );
	
				}
	
				if ( hasFaceVertexColor ) {
	
					var vertexColors = face.vertexColors;
	
					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);
	
				}
	
			}
	
			function setBit( value, position, enabled ) {
	
				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );
	
			}
	
			function getNormalIndex( normal ) {
	
				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
				if ( normalsHash[ hash ] !== undefined ) {
	
					return normalsHash[ hash ];
	
				}
	
				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );
	
				return normalsHash[ hash ];
	
			}
	
			function getColorIndex( color ) {
	
				var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
				if ( colorsHash[ hash ] !== undefined ) {
	
					return colorsHash[ hash ];
	
				}
	
				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );
	
				return colorsHash[ hash ];
	
			}
	
			function getUvIndex( uv ) {
	
				var hash = uv.x.toString() + uv.y.toString();
	
				if ( uvsHash[ hash ] !== undefined ) {
	
					return uvsHash[ hash ];
	
				}
	
				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );
	
				return uvsHash[ hash ];
	
			}
	
			output.data = {};
	
			output.data.vertices = vertices;
			output.data.normals = normals;
			if ( colors.length > 0 ) output.data.colors = colors;
			if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility
			output.data.faces = faces;
	
			//
	
			return output;
	
		},
	
		clone: function () {
	
			var geometry = new THREE.Geometry();
	
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				geometry.vertices.push( vertices[ i ].clone() );
	
			}
	
			var faces = this.faces;
	
			for ( var i = 0, il = faces.length; i < il; i ++ ) {
	
				geometry.faces.push( faces[ i ].clone() );
	
			}
	
			for ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {
	
				var faceVertexUvs = this.faceVertexUvs[ i ];
	
				if ( geometry.faceVertexUvs[ i ] === undefined ) {
	
					geometry.faceVertexUvs[ i ] = [];
	
				}
	
				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
					var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {
	
						var uv = uvs[ k ];
	
						uvsCopy.push( uv.clone() );
	
					}
	
					geometry.faceVertexUvs[ i ].push( uvsCopy );
	
				}
	
			}
	
			return geometry;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );
	
	THREE.GeometryIdCount = 0;
	
	// File:src/cameras/Camera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.Camera = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Camera';
	
		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();
	
	};
	
	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;
	
	THREE.Camera.prototype.getWorldDirection = function () {
	
		var quaternion = new THREE.Quaternion();
	
		return function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.getWorldQuaternion( quaternion );
	
			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
		}
	
	}();
	
	THREE.Camera.prototype.lookAt = function () {
	
		// This routine does not support cameras with rotated and/or translated parent(s)
	
		var m1 = new THREE.Matrix4();
	
		return function ( vector ) {
	
			m1.lookAt( this.position, vector, this.up );
	
			this.quaternion.setFromRotationMatrix( m1 );
	
		};
	
	}();
	
	THREE.Camera.prototype.clone = function ( camera ) {
	
		if ( camera === undefined ) camera = new THREE.Camera();
	
		THREE.Object3D.prototype.clone.call( this, camera );
	
		camera.matrixWorldInverse.copy( this.matrixWorldInverse );
		camera.projectionMatrix.copy( this.projectionMatrix );
	
		return camera;
	};
	
	// File:src/cameras/CubeCamera.js
	
	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CubeCamera = function ( near, far, cubeResolution ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'CubeCamera';
	
		var fov = 90, aspect = 1;
	
		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );
	
		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );
	
		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );
	
		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );
	
		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );
	
		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );
	
		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );
	
		this.updateCubeMap = function ( renderer, scene ) {
	
			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.generateMipmaps;
	
			renderTarget.generateMipmaps = false;
	
			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );
	
			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );
	
			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );
	
			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );
	
			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );
	
			renderTarget.generateMipmaps = generateMipmaps;
	
			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );
	
		};
	
	};
	
	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
	
	// File:src/cameras/OrthographicCamera.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'OrthographicCamera';
	
		this.zoom = 1;
	
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
	
		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
	
	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
	
		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;
	
		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );
	
	};
	
	THREE.OrthographicCamera.prototype.clone = function () {
	
		var camera = new THREE.OrthographicCamera();
	
		THREE.Camera.prototype.clone.call( this, camera );
	
		camera.zoom = this.zoom;
	
		camera.left = this.left;
		camera.right = this.right;
		camera.top = this.top;
		camera.bottom = this.bottom;
	
		camera.near = this.near;
		camera.far = this.far;
	
		camera.projectionMatrix.copy( this.projectionMatrix );
	
		return camera;
	};
	
	// File:src/cameras/PerspectiveCamera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'PerspectiveCamera';
	
		this.zoom = 1;
	
		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
	
	
	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (fullframe) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */
	
	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {
	
		if ( frameHeight === undefined ) frameHeight = 24;
	
		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();
	
	}
	
	
	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	
	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {
	
		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	
		this.updateProjectionMatrix();
	
	};
	
	
	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
	
		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );
	
		if ( this.fullWidth ) {
	
			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );
	
			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);
	
		} else {
	
			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );
	
		}
	
	};
	
	THREE.PerspectiveCamera.prototype.clone = function () {
	
		var camera = new THREE.PerspectiveCamera();
	
		THREE.Camera.prototype.clone.call( this, camera );
	
		camera.zoom = this.zoom;
	
		camera.fov = this.fov;
		camera.aspect = this.aspect;
		camera.near = this.near;
		camera.far = this.far;
	
		camera.projectionMatrix.copy( this.projectionMatrix );
	
		return camera;
	
	};
	
	// File:src/lights/Light.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Light = function ( color ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Light';
		
		this.color = new THREE.Color( color );
	
	};
	
	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Light.prototype.constructor = THREE.Light;
	
	THREE.Light.prototype.clone = function ( light ) {
	
		if ( light === undefined ) light = new THREE.Light();
	
		THREE.Object3D.prototype.clone.call( this, light );
	
		light.color.copy( this.color );
	
		return light;
	
	};
	
	// File:src/lights/AmbientLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AmbientLight = function ( color ) {
	
		THREE.Light.call( this, color );
	
		this.type = 'AmbientLight';
	
	};
	
	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
	
	THREE.AmbientLight.prototype.clone = function () {
	
		var light = new THREE.AmbientLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		return light;
	
	};
	
	// File:src/lights/AreaLight.js
	
	/**
	 * @author MPanknin / http://www.redplant.de/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.AreaLight = function ( color, intensity ) {
	
		THREE.Light.call( this, color );
	
		this.type = 'AreaLight';
	
		this.normal = new THREE.Vector3( 0, - 1, 0 );
		this.right = new THREE.Vector3( 1, 0, 0 );
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
		this.width = 1.0;
		this.height = 1.0;
	
		this.constantAttenuation = 1.5;
		this.linearAttenuation = 0.5;
		this.quadraticAttenuation = 0.1;
	
	};
	
	THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AreaLight.prototype.constructor = THREE.AreaLight;
	
	
	// File:src/lights/DirectionalLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DirectionalLight = function ( color, intensity ) {
	
		THREE.Light.call( this, color );
	
		this.type = 'DirectionalLight';
	
		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
		this.castShadow = false;
		this.onlyShadow = false;
	
		//
	
		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
	
		this.shadowCameraLeft = - 500;
		this.shadowCameraRight = 500;
		this.shadowCameraTop = 500;
		this.shadowCameraBottom = - 500;
	
		this.shadowCameraVisible = false;
	
		this.shadowBias = 0;
		this.shadowDarkness = 0.5;
	
		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;
	
		//
	
		this.shadowCascade = false;
	
		this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
		this.shadowCascadeCount = 2;
	
		this.shadowCascadeBias = [ 0, 0, 0 ];
		this.shadowCascadeWidth = [ 512, 512, 512 ];
		this.shadowCascadeHeight = [ 512, 512, 512 ];
	
		this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
		this.shadowCascadeFarZ  = [ 0.990, 0.998, 1.000 ];
	
		this.shadowCascadeArray = [];
	
		//
	
		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;
	
	};
	
	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
	
	THREE.DirectionalLight.prototype.clone = function () {
	
		var light = new THREE.DirectionalLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		light.target = this.target.clone();
	
		light.intensity = this.intensity;
	
		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;
	
		//
	
		light.shadowCameraNear = this.shadowCameraNear;
		light.shadowCameraFar = this.shadowCameraFar;
	
		light.shadowCameraLeft = this.shadowCameraLeft;
		light.shadowCameraRight = this.shadowCameraRight;
		light.shadowCameraTop = this.shadowCameraTop;
		light.shadowCameraBottom = this.shadowCameraBottom;
	
		light.shadowCameraVisible = this.shadowCameraVisible;
	
		light.shadowBias = this.shadowBias;
		light.shadowDarkness = this.shadowDarkness;
	
		light.shadowMapWidth = this.shadowMapWidth;
		light.shadowMapHeight = this.shadowMapHeight;
	
		//
	
		light.shadowCascade = this.shadowCascade;
	
		light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
		light.shadowCascadeCount = this.shadowCascadeCount;
	
		light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
		light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
		light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );
	
		light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
		light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );
	
		return light;
	
	};
	
	// File:src/lights/HemisphereLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {
	
		THREE.Light.call( this, skyColor );
	
		this.type = 'HemisphereLight';
	
		this.position.set( 0, 100, 0 );
	
		this.groundColor = new THREE.Color( groundColor );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
	};
	
	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
	
	THREE.HemisphereLight.prototype.clone = function () {
	
		var light = new THREE.HemisphereLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		light.groundColor.copy( this.groundColor );
		light.intensity = this.intensity;
	
		return light;
	
	};
	
	// File:src/lights/PointLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PointLight = function ( color, intensity, distance, decay ) {
	
		THREE.Light.call( this, color );
	
		this.type = 'PointLight';
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
	};
	
	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	THREE.PointLight.prototype.constructor = THREE.PointLight;
	
	THREE.PointLight.prototype.clone = function () {
	
		var light = new THREE.PointLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		light.intensity = this.intensity;
		light.distance = this.distance;
		light.decay = this.decay;
	
		return light;
	
	};
	
	// File:src/lights/SpotLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {
	
		THREE.Light.call( this, color );
	
		this.type = 'SpotLight';
	
		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.castShadow = false;
		this.onlyShadow = false;
	
		//
	
		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
		this.shadowCameraFov = 50;
	
		this.shadowCameraVisible = false;
	
		this.shadowBias = 0;
		this.shadowDarkness = 0.5;
	
		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;
	
		//
	
		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;
	
	};
	
	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	THREE.SpotLight.prototype.constructor = THREE.SpotLight;
	
	THREE.SpotLight.prototype.clone = function () {
	
		var light = new THREE.SpotLight();
	
		THREE.Light.prototype.clone.call( this, light );
	
		light.target = this.target.clone();
	
		light.intensity = this.intensity;
		light.distance = this.distance;
		light.angle = this.angle;
		light.exponent = this.exponent;
		light.decay = this.decay;
	
		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;
	
		//
	
		light.shadowCameraNear = this.shadowCameraNear;
		light.shadowCameraFar = this.shadowCameraFar;
		light.shadowCameraFov = this.shadowCameraFov;
	
		light.shadowCameraVisible = this.shadowCameraVisible;
	
		light.shadowBias = this.shadowBias;
		light.shadowDarkness = this.shadowDarkness;
	
		light.shadowMapWidth = this.shadowMapWidth;
		light.shadowMapHeight = this.shadowMapHeight;
	
		return light;
	
	};
	
	// File:src/loaders/Cache.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Cache = {
	
		files: {},
	
		add: function ( key, file ) {
	
			// console.log( 'THREE.Cache', 'Adding key:', key );
	
			this.files[ key ] = file;
	
		},
	
		get: function ( key ) {
	
			// console.log( 'THREE.Cache', 'Checking key:', key );
	
			return this.files[ key ];
	
		},
	
		remove: function ( key ) {
	
			delete this.files[ key ];
	
		},
	
		clear: function () {
	
			this.files = {}
	
		}
	
	};
	
	// File:src/loaders/Loader.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Loader = function ( showStatus ) {
	
		this.showStatus = showStatus;
		this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;
	
		this.imageLoader = new THREE.ImageLoader();
	
		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};
	
	};
	
	THREE.Loader.prototype = {
	
		constructor: THREE.Loader,
	
		crossOrigin: undefined,
	
		addStatusElement: function () {
	
			var e = document.createElement( 'div' );
	
			e.style.position = 'absolute';
			e.style.right = '0px';
			e.style.top = '0px';
			e.style.fontSize = '0.8em';
			e.style.textAlign = 'left';
			e.style.background = 'rgba(0,0,0,0.25)';
			e.style.color = '#fff';
			e.style.width = '120px';
			e.style.padding = '0.5em 0.5em 0.5em 0.5em';
			e.style.zIndex = 1000;
	
			e.innerHTML = 'Loading ...';
	
			return e;
	
		},
	
		updateProgress: function ( progress ) {
	
			var message = 'Loaded ';
	
			if ( progress.total ) {
	
				message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';
	
	
			} else {
	
				message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';
	
			}
	
			this.statusDomElement.innerHTML = message;
	
		},
	
		extractUrlBase: function ( url ) {
	
			var parts = url.split( '/' );
	
			if ( parts.length === 1 ) return './';
	
			parts.pop();
	
			return parts.join( '/' ) + '/';
	
		},
	
		initMaterials: function ( materials, texturePath ) {
	
			var array = [];
	
			for ( var i = 0; i < materials.length; ++ i ) {
	
				array[ i ] = this.createMaterial( materials[ i ], texturePath );
	
			}
	
			return array;
	
		},
	
		needsTangents: function ( materials ) {
	
			for ( var i = 0, il = materials.length; i < il; i ++ ) {
	
				var m = materials[ i ];
	
				if ( m instanceof THREE.ShaderMaterial ) return true;
	
			}
	
			return false;
	
		},
	
		createMaterial: function ( m, texturePath ) {
	
			var scope = this;
	
			function nearest_pow2( n ) {
	
				var l = Math.log( n ) / Math.LN2;
				return Math.pow( 2, Math.round(  l ) );
	
			}
	
			function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {
	
				var fullPath = texturePath + sourceFile;
	
				var texture;
	
				var loader = THREE.Loader.Handlers.get( fullPath );
	
				if ( loader !== null ) {
	
					texture = loader.load( fullPath );
	
				} else {
	
					texture = new THREE.Texture();
	
					loader = scope.imageLoader;
					loader.crossOrigin = scope.crossOrigin;
					loader.load( fullPath, function ( image ) {
	
						if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
							 THREE.Math.isPowerOfTwo( image.height ) === false ) {
	
							var width = nearest_pow2( image.width );
							var height = nearest_pow2( image.height );
	
							var canvas = document.createElement( 'canvas' );
							canvas.width = width;
							canvas.height = height;
	
							var context = canvas.getContext( '2d' );
							context.drawImage( image, 0, 0, width, height );
	
							texture.image = canvas;
	
						} else {
	
							texture.image = image;
	
						}
	
						texture.needsUpdate = true;
	
					} );
	
				}
	
				texture.sourceFile = sourceFile;
	
				if ( repeat ) {
	
					texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );
	
					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;
	
				}
	
				if ( offset ) {
	
					texture.offset.set( offset[ 0 ], offset[ 1 ] );
	
				}
	
				if ( wrap ) {
	
					var wrapMap = {
						'repeat': THREE.RepeatWrapping,
						'mirror': THREE.MirroredRepeatWrapping
					}
	
					if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
					if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];
	
				}
	
				if ( anisotropy ) {
	
					texture.anisotropy = anisotropy;
	
				}
	
				where[ name ] = texture;
	
			}
	
			function rgb2hex( rgb ) {
	
				return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;
	
			}
	
			// defaults
	
			var mtype = 'MeshLambertMaterial';
			var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };
	
			// parameters from model file
	
			if ( m.shading ) {
	
				var shading = m.shading.toLowerCase();
	
				if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
				else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';
	
			}
	
			if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {
	
				mpars.blending = THREE[ m.blending ];
	
			}
	
			if ( m.transparent !== undefined ) {
	
				mpars.transparent = m.transparent;
	
			}
	
			if ( m.opacity !== undefined && m.opacity < 1.0 ) {
	
				mpars.transparent = true;
	
			}
	
			if ( m.depthTest !== undefined ) {
	
				mpars.depthTest = m.depthTest;
	
			}
	
			if ( m.depthWrite !== undefined ) {
	
				mpars.depthWrite = m.depthWrite;
	
			}
	
			if ( m.visible !== undefined ) {
	
				mpars.visible = m.visible;
	
			}
	
			if ( m.flipSided !== undefined ) {
	
				mpars.side = THREE.BackSide;
	
			}
	
			if ( m.doubleSided !== undefined ) {
	
				mpars.side = THREE.DoubleSide;
	
			}
	
			if ( m.wireframe !== undefined ) {
	
				mpars.wireframe = m.wireframe;
	
			}
	
			if ( m.vertexColors !== undefined ) {
	
				if ( m.vertexColors === 'face' ) {
	
					mpars.vertexColors = THREE.FaceColors;
	
				} else if ( m.vertexColors ) {
	
					mpars.vertexColors = THREE.VertexColors;
	
				}
	
			}
	
			// colors
	
			if ( m.colorDiffuse ) {
	
				mpars.color = rgb2hex( m.colorDiffuse );
	
			} else if ( m.DbgColor ) {
	
				mpars.color = m.DbgColor;
	
			}
	
			if ( m.colorSpecular ) {
	
				mpars.specular = rgb2hex( m.colorSpecular );
	
			}
	
			if ( m.colorEmissive ) {
	
				mpars.emissive = rgb2hex( m.colorEmissive );
	
			}
	
			// modifiers
	
			if ( m.transparency !== undefined ) {
	
				console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
				m.opacity = m.transparency;
	
			}
	
			if ( m.opacity !== undefined ) {
	
				mpars.opacity = m.opacity;
	
			}
	
			if ( m.specularCoef ) {
	
				mpars.shininess = m.specularCoef;
	
			}
	
			// textures
	
			if ( m.mapDiffuse && texturePath ) {
	
				create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
	
			}
	
			if ( m.mapLight && texturePath ) {
	
				create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
	
			}
	
			if ( m.mapBump && texturePath ) {
	
				create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
	
			}
	
			if ( m.mapNormal && texturePath ) {
	
				create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
	
			}
	
			if ( m.mapSpecular && texturePath ) {
	
				create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
	
			}
	
			if ( m.mapAlpha && texturePath ) {
	
				create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
	
			}
	
			//
	
			if ( m.mapBumpScale ) {
	
				mpars.bumpScale = m.mapBumpScale;
	
			}
	
			if ( m.mapNormalFactor ) {
	
				mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );
	
			}
	
			var material = new THREE[ mtype ]( mpars );
	
			if ( m.DbgName !== undefined ) material.name = m.DbgName;
	
			return material;
	
		}
	
	};
	
	THREE.Loader.Handlers = {
	
		handlers: [],
	
		add: function ( regex, loader ) {
	
			this.handlers.push( regex, loader );
	
		},
	
		get: function ( file ) {
	
			for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {
	
				var regex = this.handlers[ i ];
				var loader  = this.handlers[ i + 1 ];
	
				if ( regex.test( file ) ) {
	
					return loader;
	
				}
	
			}
	
			return null;
	
		}
	
	};
	
	// File:src/loaders/XHRLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.XHRLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.XHRLoader.prototype = {
	
		constructor: THREE.XHRLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var cached = THREE.Cache.get( url );
	
			if ( cached !== undefined ) {
	
				if ( onLoad ) onLoad( cached );
				return;
	
			}
	
			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );
	
			request.addEventListener( 'load', function ( event ) {
	
				THREE.Cache.add( url, this.response );
	
				if ( onLoad ) onLoad( this.response );
	
				scope.manager.itemEnd( url );
	
			}, false );
	
			if ( onProgress !== undefined ) {
	
				request.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			if ( onError !== undefined ) {
	
				request.addEventListener( 'error', function ( event ) {
	
					onError( event );
	
				}, false );
	
			}
	
			if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
			if ( this.responseType !== undefined ) request.responseType = this.responseType;
	
			request.send( null );
	
			scope.manager.itemStart( url );
	
		},
	
		setResponseType: function ( value ) {
	
			this.responseType = value;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	};
	
	// File:src/loaders/ImageLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ImageLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.ImageLoader.prototype = {
	
		constructor: THREE.ImageLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var cached = THREE.Cache.get( url );
	
			if ( cached !== undefined ) {
	
				onLoad( cached );
				return;
	
			}
	
			var image = document.createElement( 'img' );
	
			image.addEventListener( 'load', function ( event ) {
	
				THREE.Cache.add( url, this );
	
				if ( onLoad ) onLoad( this );
				
				scope.manager.itemEnd( url );
	
			}, false );
	
			if ( onProgress !== undefined ) {
	
				image.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			if ( onError !== undefined ) {
	
				image.addEventListener( 'error', function ( event ) {
	
					onError( event );
	
				}, false );
	
			}
	
			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
	
			image.src = url;
	
			scope.manager.itemStart( url );
	
			return image;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	}
	
	// File:src/loaders/JSONLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.JSONLoader = function ( showStatus ) {
	
		THREE.Loader.call( this, showStatus );
	
		this.withCredentials = false;
	
	};
	
	THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );
	THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;
	
	THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {
	
		// todo: unify load API to for easier SceneLoader use
	
		texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );
	
		this.onLoadStart();
		this.loadAjaxJSON( this, url, callback, texturePath );
	
	};
	
	THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {
	
		var xhr = new XMLHttpRequest();
	
		var length = 0;
	
		xhr.onreadystatechange = function () {
	
			if ( xhr.readyState === xhr.DONE ) {
	
				if ( xhr.status === 200 || xhr.status === 0 ) {
	
					if ( xhr.responseText ) {
	
						var json = JSON.parse( xhr.responseText );
						var metadata = json.metadata;
	
						if ( metadata !== undefined ) {
	
							if ( metadata.type === 'object' ) {
	
								THREE.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;
	
							}
	
							if ( metadata.type === 'scene' ) {
	
								THREE.error( 'THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.' );
								return;
	
							}
	
						}
	
						var result = context.parse( json, texturePath );
						callback( result.geometry, result.materials );
	
					} else {
	
						THREE.error( 'THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.' );
	
					}
	
					// in context of more complex asset initialization
					// do not block on single failed file
					// maybe should go even one more level up
	
					context.onLoadComplete();
	
				} else {
	
					THREE.error( 'THREE.JSONLoader: Couldn\'t load ' + url + ' (' + xhr.status + ')' );
	
				}
	
			} else if ( xhr.readyState === xhr.LOADING ) {
	
				if ( callbackProgress ) {
	
					if ( length === 0 ) {
	
						length = xhr.getResponseHeader( 'Content-Length' );
	
					}
	
					callbackProgress( { total: length, loaded: xhr.responseText.length } );
	
				}
	
			} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {
	
				if ( callbackProgress !== undefined ) {
	
					length = xhr.getResponseHeader( 'Content-Length' );
	
				}
	
			}
	
		};
	
		xhr.open( 'GET', url, true );
		xhr.withCredentials = this.withCredentials;
		xhr.send( null );
	
	};
	
	THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {
	
		var geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
		parseModel( scale );
	
		parseSkin();
		parseMorphing( scale );
	
		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();
	
		function parseModel( scale ) {
	
			function isBitSet( value, position ) {
	
				return value & ( 1 << position );
	
			}
	
			var i, j, fi,
	
			offset, zLength,
	
			colorIndex, normalIndex, uvIndex, materialIndex,
	
			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,
	
			vertex, face, faceA, faceB, hex, normal,
	
			uvLayer, uv, u, v,
	
			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,
	
			nUvLayers = 0;
	
			if ( json.uvs !== undefined ) {
	
				// disregard empty arrays
	
				for ( i = 0; i < json.uvs.length; i ++ ) {
	
					if ( json.uvs[ i ].length ) nUvLayers ++;
	
				}
	
				for ( i = 0; i < nUvLayers; i ++ ) {
	
					geometry.faceVertexUvs[ i ] = [];
	
				}
	
			}
	
			offset = 0;
			zLength = vertices.length;
	
			while ( offset < zLength ) {
	
				vertex = new THREE.Vector3();
	
				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;
	
				geometry.vertices.push( vertex );
	
			}
	
			offset = 0;
			zLength = faces.length;
	
			while ( offset < zLength ) {
	
				type = faces[ offset ++ ];
	
	
				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );
	
				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
				if ( isQuad ) {
	
					faceA = new THREE.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];
	
					faceB = new THREE.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];
	
					offset += 4;
	
					if ( hasMaterial ) {
	
						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;
	
					}
	
					// to get face <=> uv index correspondence
	
					fi = geometry.faces.length;
	
					if ( hasFaceVertexUv ) {
	
						for ( i = 0; i < nUvLayers; i ++ ) {
	
							uvLayer = json.uvs[ i ];
	
							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = []
	
							for ( j = 0; j < 4; j ++ ) {
	
								uvIndex = faces[ offset ++ ];
	
								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];
	
								uv = new THREE.Vector2( u, v );
	
								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
							}
	
						}
	
					}
	
					if ( hasFaceNormal ) {
	
						normalIndex = faces[ offset ++ ] * 3;
	
						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);
	
						faceB.normal.copy( faceA.normal );
	
					}
	
					if ( hasFaceVertexNormal ) {
	
						for ( i = 0; i < 4; i ++ ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
	
							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
						}
	
					}
	
	
					if ( hasFaceColor ) {
	
						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];
	
						faceA.color.setHex( hex );
						faceB.color.setHex( hex );
	
					}
	
	
					if ( hasFaceVertexColor ) {
	
						for ( i = 0; i < 4; i ++ ) {
	
							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];
	
							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );
	
						}
	
					}
	
					geometry.faces.push( faceA );
					geometry.faces.push( faceB );
	
				} else {
	
					face = new THREE.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];
	
					if ( hasMaterial ) {
	
						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;
	
					}
	
					// to get face <=> uv index correspondence
	
					fi = geometry.faces.length;
	
					if ( hasFaceVertexUv ) {
	
						for ( i = 0; i < nUvLayers; i ++ ) {
	
							uvLayer = json.uvs[ i ];
	
							geometry.faceVertexUvs[ i ][ fi ] = [];
	
							for ( j = 0; j < 3; j ++ ) {
	
								uvIndex = faces[ offset ++ ];
	
								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];
	
								uv = new THREE.Vector2( u, v );
	
								geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
							}
	
						}
	
					}
	
					if ( hasFaceNormal ) {
	
						normalIndex = faces[ offset ++ ] * 3;
	
						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);
	
					}
	
					if ( hasFaceVertexNormal ) {
	
						for ( i = 0; i < 3; i ++ ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
							face.vertexNormals.push( normal );
	
						}
	
					}
	
	
					if ( hasFaceColor ) {
	
						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );
	
					}
	
	
					if ( hasFaceVertexColor ) {
	
						for ( i = 0; i < 3; i ++ ) {
	
							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );
	
						}
	
					}
	
					geometry.faces.push( face );
	
				}
	
			}
	
		};
	
		function parseSkin() {
			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
	
			if ( json.skinWeights ) {
	
				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
	
					var x =                               json.skinWeights[ i     ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
	
					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );
	
				}
	
			}
	
			if ( json.skinIndices ) {
	
				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
	
					var a =                               json.skinIndices[ i     ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
	
					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );
	
				}
	
			}
	
			geometry.bones = json.bones;
	
			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
	
				THREE.warn( 'THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
	
			}
	
	
			// could change this to json.animations[0] or remove completely
	
			geometry.animation = json.animation;
			geometry.animations = json.animations;
	
		};
	
		function parseMorphing( scale ) {
	
			if ( json.morphTargets !== undefined ) {
	
				var i, l, v, vl, dstVertices, srcVertices;
	
				for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];
	
					dstVertices = geometry.morphTargets[ i ].vertices;
					srcVertices = json.morphTargets [ i ].vertices;
	
					for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;
	
						dstVertices.push( vertex );
	
					}
	
				}
	
			}
	
			if ( json.morphColors !== undefined ) {
	
				var i, l, c, cl, dstColors, srcColors, color;
	
				for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {
	
					geometry.morphColors[ i ] = {};
					geometry.morphColors[ i ].name = json.morphColors[ i ].name;
					geometry.morphColors[ i ].colors = [];
	
					dstColors = geometry.morphColors[ i ].colors;
					srcColors = json.morphColors [ i ].colors;
	
					for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {
	
						color = new THREE.Color( 0xffaa00 );
						color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
						dstColors.push( color );
	
					}
	
				}
	
			}
	
		};
	
		if ( json.materials === undefined || json.materials.length === 0 ) {
	
			return { geometry: geometry };
	
		} else {
	
			var materials = this.initMaterials( json.materials, texturePath );
	
			if ( this.needsTangents( materials ) ) {
	
				geometry.computeTangents();
	
			}
	
			return { geometry: geometry, materials: materials };
	
		}
	
	};
	
	// File:src/loaders/LoadingManager.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {
	
		var scope = this;
	
		var loaded = 0, total = 0;
	
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
	
		this.itemStart = function ( url ) {
	
			total ++;
	
		};
	
		this.itemEnd = function ( url ) {
	
			loaded ++;
	
			if ( scope.onProgress !== undefined ) {
	
				scope.onProgress( url, loaded, total );
	
			}
	
			if ( loaded === total && scope.onLoad !== undefined ) {
	
				scope.onLoad();
	
			}
	
		};
	
	};
	
	THREE.DefaultLoadingManager = new THREE.LoadingManager();
	
	// File:src/loaders/BufferGeometryLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometryLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.BufferGeometryLoader.prototype = {
	
		constructor: THREE.BufferGeometryLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json ) {
	
			var geometry = new THREE.BufferGeometry();
	
			var attributes = json.data.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
				var typedArray = new self[ attribute.type ]( attribute.array );
	
				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );
	
			}
	
			var offsets = json.data.offsets;
	
			if ( offsets !== undefined ) {
	
				geometry.offsets = JSON.parse( JSON.stringify( offsets ) );
	
			}
	
			var boundingSphere = json.data.boundingSphere;
	
			if ( boundingSphere !== undefined ) {
	
				var center = new THREE.Vector3();
	
				if ( boundingSphere.center !== undefined ) {
	
					center.fromArray( boundingSphere.center );
	
				}
	
				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );
	
			}
	
			return geometry;
	
		}
	
	};
	
	// File:src/loaders/MaterialLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MaterialLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.MaterialLoader.prototype = {
	
		constructor: THREE.MaterialLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json ) {
	
			var material = new THREE[ json.type ];
	
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
	
			// for PointCloudMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
			if ( json.materials !== undefined ) {
	
				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {
	
					material.materials.push( this.parse( json.materials[ i ] ) );
	
				}
	
			}
	
			return material;
	
		}
	
	};
	
	// File:src/loaders/ObjectLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ObjectLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';
	
	};
	
	THREE.ObjectLoader.prototype = {
	
		constructor: THREE.ObjectLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.texturePath === '' ) {
	
				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
	
			}
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				scope.parse( JSON.parse( text ), onLoad );
	
			}, onProgress, onError );
	
		},
	
		setTexturePath: function ( value ) {
	
			this.texturePath = value;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json, onLoad ) {
	
			var geometries = this.parseGeometries( json.geometries );
	
			var images = this.parseImages( json.images, function () {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			} );
			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
			var object = this.parseObject( json.object, geometries, materials );
	
			if ( json.images === undefined || json.images.length === 0 ) {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			}
	
			return object;
	
		},
	
		parseGeometries: function ( json ) {
	
			var geometries = {};
	
			if ( json !== undefined ) {
	
				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var geometry;
					var data = json[ i ];
	
					switch ( data.type ) {
	
						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);
	
							break;
	
						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible
	
							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);
	
							break;
	
						case 'CircleGeometry':
	
							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments
							);
	
							break;
	
						case 'CylinderGeometry':
	
							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded
							);
	
							break;
	
						case 'SphereGeometry':
	
							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'IcosahedronGeometry':
	
							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'TorusGeometry':
	
							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);
	
							break;
	
						case 'TorusKnotGeometry':
	
							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);
	
							break;
	
						case 'BufferGeometry':
	
							geometry = bufferGeometryLoader.parse( data );
	
							break;
	
						case 'Geometry':
	
							geometry = geometryLoader.parse( data.data ).geometry;
	
							break;
	
					}
	
					geometry.uuid = data.uuid;
	
					if ( data.name !== undefined ) geometry.name = data.name;
	
					geometries[ data.uuid ] = geometry;
	
				}
	
			}
	
			return geometries;
	
		},
	
		parseMaterials: function ( json, textures ) {
	
			var materials = {};
	
			if ( json !== undefined ) {
	
				var getTexture = function ( name ) {
	
					if ( textures[ name ] === undefined ) {
	
						THREE.warn( 'THREE.ObjectLoader: Undefined texture', name );
	
					}
	
					return textures[ name ];
	
				};
	
				var loader = new THREE.MaterialLoader();
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var data = json[ i ];
					var material = loader.parse( data );
	
					material.uuid = data.uuid;
	
					if ( data.name !== undefined ) material.name = data.name;
	
					if ( data.map !== undefined ) {
	
						material.map = getTexture( data.map );
	
					}
	
					if ( data.bumpMap !== undefined ) {
	
						material.bumpMap = getTexture( data.bumpMap );
						if ( data.bumpScale ) {
							material.bumpScale = new THREE.Vector2( data.bumpScale, data.bumpScale );
						}
	
					}
	
					if ( data.alphaMap !== undefined ) {
	
						material.alphaMap = getTexture( data.alphaMap );
	
					}
	
					if ( data.envMap !== undefined ) {
	
						material.envMap = getTexture( data.envMap );
	
					}
	
					if ( data.normalMap !== undefined ) {
	
						material.normalMap = getTexture( data.normalMap );
						if ( data.normalScale ) {
							material.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );
						}
	
					}
	
					if ( data.lightMap !== undefined ) {
	
						material.lightMap = getTexture( data.lightMap );
	
					}
	
					if ( data.specularMap !== undefined ) {
	
						material.specularMap = getTexture( data.specularMap );
	
					}
	
					materials[ data.uuid ] = material;
	
				}
	
			}
	
			return materials;
	
		},
	
		parseImages: function ( json, onLoad ) {
	
			var scope = this;
			var images = {};
	
			if ( json !== undefined && json.length > 0 ) {
	
				var manager = new THREE.LoadingManager( onLoad );
	
				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );
	
				var loadImage = function ( url ) {
	
					scope.manager.itemStart( url );
	
					return loader.load( url, function () {
	
						scope.manager.itemEnd( url );
	
					} );
	
				};
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
	
					images[ image.uuid ] = loadImage( path );
	
				}
	
			}
	
			return images;
	
		},
	
		parseTextures: function ( json, images ) {
	
			var textures = {};
	
			if ( json !== undefined ) {
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var data = json[ i ];
	
					if ( data.image === undefined ) {
	
						THREE.warn( 'THREE.ObjectLoader: No "image" speficied for', data.uuid );
	
					}
	
					if ( images[ data.image ] === undefined ) {
	
						THREE.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
					}
	
					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;
	
					texture.uuid = data.uuid;
	
					if ( data.name !== undefined ) texture.name = data.name;
					if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
					if ( data.minFilter !== undefined ) texture.minFilter = THREE[ data.minFilter ];
					if ( data.magFilter !== undefined ) texture.magFilter = THREE[ data.magFilter ];
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
					if ( data.wrap instanceof Array ) {
	
						texture.wrapS = THREE[ data.wrap[ 0 ] ];
						texture.wrapT = THREE[ data.wrap[ 1 ] ];
	
					}
	
					textures[ data.uuid ] = texture;
	
				}
	
			}
	
			return textures;
	
		},
	
		parseObject: function () {
	
			var matrix = new THREE.Matrix4();
	
			return function ( data, geometries, materials ) {
	
				var object;
	
				var getGeometry = function ( name ) {
	
					if ( geometries[ name ] === undefined ) {
	
						THREE.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
					}
	
					return geometries[ name ];
	
				};
	
				var getMaterial = function ( name ) {
	
					if ( materials[ name ] === undefined ) {
	
						THREE.warn( 'THREE.ObjectLoader: Undefined material', name );
	
					}
	
					return materials[ name ];
	
				};
	
				switch ( data.type ) {
	
					case 'Scene':
	
						object = new THREE.Scene();
	
						break;
	
					case 'PerspectiveCamera':
	
						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
						break;
	
					case 'OrthographicCamera':
	
						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
						break;
	
					case 'AmbientLight':
	
						object = new THREE.AmbientLight( data.color );
	
						break;
	
					case 'DirectionalLight':
	
						object = new THREE.DirectionalLight( data.color, data.intensity );
	
						break;
	
					case 'PointLight':
	
						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );
	
						break;
	
					case 'SpotLight':
	
						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );
	
						break;
	
					case 'HemisphereLight':
	
						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );
	
						break;
	
					case 'Mesh':
	
						object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );
	
						break;
	
					case 'Line':
	
						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
						break;
	
					case 'PointCloud':
	
						object = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );
	
						break;
	
					case 'Sprite':
	
						object = new THREE.Sprite( getMaterial( data.material ) );
	
						break;
	
					case 'Group':
	
						object = new THREE.Group();
	
						break;
	
					default:
	
						object = new THREE.Object3D();
	
				}
	
				object.uuid = data.uuid;
	
				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {
	
					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );
	
				} else {
	
					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
				}
	
				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;
	
				if ( data.children !== undefined ) {
	
					for ( var child in data.children ) {
	
						object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
					}
	
				}
	
				return object;
	
			}
	
		}()
	
	};
	
	// File:src/loaders/TextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.TextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.TextureLoader.prototype = {
	
		constructor: THREE.TextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.ImageLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( image ) {
	
				var texture = new THREE.Texture( image );
				texture.needsUpdate = true;
	
				if ( onLoad !== undefined ) {
	
					onLoad( texture );
	
				}
	
			}, onProgress, onError );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	};
	
	// File:src/loaders/BinaryTextureLoader.js
	
	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */
	
	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {
	
		// override in sub classes
		this._parser = null;
	
	};
	
	THREE.BinaryTextureLoader.prototype = {
	
		constructor: THREE.BinaryTextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texture = new THREE.DataTexture( );
	
			var loader = new THREE.XHRLoader();
			loader.setResponseType( 'arraybuffer' );
	
			loader.load( url, function ( buffer ) {
	
				var texData = scope._parser( buffer );
	
				if ( !texData ) return;
	
				if ( undefined !== texData.image ) {
	
					texture.image = texData.image;
	
				} else if ( undefined !== texData.data ) {
	
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
	
				}
	
				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
	
				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
	
				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	
				if ( undefined !== texData.format ) {
	
					texture.format = texData.format;
	
				}
				if ( undefined !== texData.type ) {
	
					texture.type = texData.type;
	
				}
	
				if ( undefined !== texData.mipmaps ) {
	
					texture.mipmaps = texData.mipmaps;
	
				}
	
				if ( 1 === texData.mipmapCount ) {
	
					texture.minFilter = THREE.LinearFilter;
	
				}
	
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture, texData );
	
			}, onProgress, onError );
	
	
			return texture;
	
		}
	
	};
	
	// File:src/loaders/CompressedTextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */
	
	THREE.CompressedTextureLoader = function () {
	
		// override in sub classes
		this._parser = null;
	
	};
	
	
	THREE.CompressedTextureLoader.prototype = {
	
		constructor: THREE.CompressedTextureLoader,
	
		load: function ( url, onLoad, onError ) {
	
			var scope = this;
	
			var images = [];
	
			var texture = new THREE.CompressedTexture();
			texture.image = images;
	
			var loader = new THREE.XHRLoader();
			loader.setResponseType( 'arraybuffer' );
	
			if ( url instanceof Array ) {
	
				var loaded = 0;
	
				var loadTexture = function ( i ) {
	
					loader.load( url[ i ], function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};
	
						loaded += 1;
	
						if ( loaded === 6 ) {
	
							if (texDatas.mipmapCount == 1)
	 							texture.minFilter = THREE.LinearFilter;
	
							texture.format = texDatas.format;
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					} );
	
				};
	
				for ( var i = 0, il = url.length; i < il; ++ i ) {
	
					loadTexture( i );
	
				}
	
			} else {
	
				// compressed cubemap texture stored in a single DDS file
	
				loader.load( url, function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					if ( texDatas.isCubemap ) {
	
						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
						for ( var f = 0; f < faces; f ++ ) {
	
							images[ f ] = { mipmaps : [] };
	
							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;
	
							}
	
						}
	
					} else {
	
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
	
					}
	
					if ( texDatas.mipmapCount === 1 ) {
	
						texture.minFilter = THREE.LinearFilter;
	
					}
	
					texture.format = texDatas.format;
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture );
	
				} );
	
			}
	
			return texture;
	
		}
	
	};
	
	// File:src/materials/Material.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Material = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Material';
	
		this.side = THREE.FrontSide;
	
		this.opacity = 1;
		this.transparent = false;
	
		this.blending = THREE.NormalBlending;
	
		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
	
		this.depthTest = true;
		this.depthWrite = true;
	
		this.colorWrite = true;
	
		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
	
		this.alphaTest = 0;
	
		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
		this.visible = true;
	
		this._needsUpdate = true;
	
	};
	
	THREE.Material.prototype = {
	
		constructor: THREE.Material,
	
		get needsUpdate () {
	
			return this._needsUpdate;
	
		},
	
		set needsUpdate ( value ) {
	
			if ( value === true ) this.update();
	
			this._needsUpdate = value;
	
		},
	
		setValues: function ( values ) {
	
			if ( values === undefined ) return;
	
			for ( var key in values ) {
	
				var newValue = values[ key ];
	
				if ( newValue === undefined ) {
	
					THREE.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;
	
				}
	
				if ( key in this ) {
	
					var currentValue = this[ key ];
	
					if ( currentValue instanceof THREE.Color ) {
	
						currentValue.set( newValue );
	
					} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {
	
						currentValue.copy( newValue );
	
					} else if ( key == 'overdraw' ) {
	
						// ensure overdraw is backwards-compatable with legacy boolean type
						this[ key ] = Number( newValue );
	
					} else {
	
						this[ key ] = newValue;
	
					}
	
				}
	
			}
	
		},
	
		toJSON: function () {
	
			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type
			};
	
			if ( this.name !== "" ) output.name = this.name;
	
			if ( this instanceof THREE.MeshBasicMaterial ) {
	
				output.color = this.color.getHex();
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;
	
			} else if ( this instanceof THREE.MeshLambertMaterial ) {
	
				output.color = this.color.getHex();
				output.emissive = this.emissive.getHex();
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;
	
			} else if ( this instanceof THREE.MeshPhongMaterial ) {
	
				output.color = this.color.getHex();
				output.emissive = this.emissive.getHex();
				output.specular = this.specular.getHex();
				output.shininess = this.shininess;
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;
	
			} else if ( this instanceof THREE.MeshNormalMaterial ) {
	
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;
	
			} else if ( this instanceof THREE.MeshDepthMaterial ) {
	
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;
	
			} else if ( this instanceof THREE.PointCloudMaterial ) {
	
				output.size  = this.size;
				output.sizeAttenuation = this.sizeAttenuation;
				output.color = this.color.getHex();
	
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
	
			} else if ( this instanceof THREE.ShaderMaterial ) {
	
				output.uniforms = this.uniforms;
				output.vertexShader = this.vertexShader;
				output.fragmentShader = this.fragmentShader;
	
			} else if ( this instanceof THREE.SpriteMaterial ) {
	
				output.color = this.color.getHex();
	
			}
	
			if ( this.opacity < 1 ) output.opacity = this.opacity;
			if ( this.transparent !== false ) output.transparent = this.transparent;
			if ( this.wireframe !== false ) output.wireframe = this.wireframe;
	
			return output;
	
		},
	
		clone: function ( material ) {
	
			if ( material === undefined ) material = new THREE.Material();
	
			material.name = this.name;
	
			material.side = this.side;
	
			material.opacity = this.opacity;
			material.transparent = this.transparent;
	
			material.blending = this.blending;
	
			material.blendSrc = this.blendSrc;
			material.blendDst = this.blendDst;
			material.blendEquation = this.blendEquation;
			material.blendSrcAlpha = this.blendSrcAlpha;
			material.blendDstAlpha = this.blendDstAlpha;
			material.blendEquationAlpha = this.blendEquationAlpha;
	
			material.depthTest = this.depthTest;
			material.depthWrite = this.depthWrite;
	
			material.polygonOffset = this.polygonOffset;
			material.polygonOffsetFactor = this.polygonOffsetFactor;
			material.polygonOffsetUnits = this.polygonOffsetUnits;
	
			material.alphaTest = this.alphaTest;
	
			material.overdraw = this.overdraw;
	
			material.visible = this.visible;
	
			return material;
	
		},
	
		update: function () {
	
			this.dispatchEvent( { type: 'update' } );
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );
	
	THREE.MaterialIdCount = 0;
	
	// File:src/materials/LineBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
	
	THREE.LineBasicMaterial.prototype.clone = function () {
	
		var material = new THREE.LineBasicMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.linewidth = this.linewidth;
		material.linecap = this.linecap;
		material.linejoin = this.linejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.fog = this.fog;
	
		return material;
	
	};
	
	// File:src/materials/LineDashedMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineDashedMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineDashedMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
	
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
	
		this.vertexColors = false;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
	
	THREE.LineDashedMaterial.prototype.clone = function () {
	
		var material = new THREE.LineDashedMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.linewidth = this.linewidth;
	
		material.scale = this.scale;
		material.dashSize = this.dashSize;
		material.gapSize = this.gapSize;
	
		material.vertexColors = this.vertexColors;
	
		material.fog = this.fog;
	
		return material;
	
	};
	
	// File:src/materials/MeshBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.MeshBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // emissive
	
		this.map = null;
	
		this.lightMap = null;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
	
	THREE.MeshBasicMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshBasicMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.map = this.map;
	
		material.lightMap = this.lightMap;
	
		material.specularMap = this.specularMap;
	
		material.alphaMap = this.alphaMap;
	
		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;
	
		material.fog = this.fog;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
	
		return material;
	
	};
	
	// File:src/materials/MeshLambertMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshLambertMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshLambertMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );
	
		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );
	
		this.map = null;
	
		this.lightMap = null;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
	
	THREE.MeshLambertMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshLambertMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.emissive.copy( this.emissive );
	
		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );
	
		material.map = this.map;
	
		material.lightMap = this.lightMap;
	
		material.specularMap = this.specularMap;
	
		material.alphaMap = this.alphaMap;
	
		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;
	
		material.fog = this.fog;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;
	
		return material;
	
	};
	
	// File:src/materials/MeshPhongMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshPhongMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshPhongMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;
	
		this.metal = false;
	
		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );
	
		this.map = null;
	
		this.lightMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
	
	THREE.MeshPhongMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshPhongMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.emissive.copy( this.emissive );
		material.specular.copy( this.specular );
		material.shininess = this.shininess;
	
		material.metal = this.metal;
	
		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );
	
		material.map = this.map;
	
		material.lightMap = this.lightMap;
	
		material.bumpMap = this.bumpMap;
		material.bumpScale = this.bumpScale;
	
		material.normalMap = this.normalMap;
		material.normalScale.copy( this.normalScale );
	
		material.specularMap = this.specularMap;
	
		material.alphaMap = this.alphaMap;
	
		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;
	
		material.fog = this.fog;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;
	
		return material;
	
	};
	
	// File:src/materials/MeshDepthMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshDepthMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshDepthMaterial';
	
		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
	
	THREE.MeshDepthMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshDepthMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
	
		return material;
	
	};
	
	// File:src/materials/MeshNormalMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshNormalMaterial = function ( parameters ) {
	
		THREE.Material.call( this, parameters );
	
		this.type = 'MeshNormalMaterial';
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
	
	THREE.MeshNormalMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshNormalMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
	
		return material;
	
	};
	
	// File:src/materials/MeshFaceMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MeshFaceMaterial = function ( materials ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.type = 'MeshFaceMaterial';
		
		this.materials = materials instanceof Array ? materials : [];
	
	};
	
	THREE.MeshFaceMaterial.prototype = {
	
		constructor: THREE.MeshFaceMaterial,
	
		toJSON: function () {
	
			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};
	
			for ( var i = 0, l = this.materials.length; i < l; i ++ ) {
	
				output.materials.push( this.materials[ i ].toJSON() );
	
			}
	
			return output;
	
		},
	
		clone: function () {
	
			var material = new THREE.MeshFaceMaterial();
	
			for ( var i = 0; i < this.materials.length; i ++ ) {
	
				material.materials.push( this.materials[ i ].clone() );
	
			}
	
			return material;
	
		}
	
	};
	
	// File:src/materials/PointCloudMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.PointCloudMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'PointCloudMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.map = null;
	
		this.size = 1;
		this.sizeAttenuation = true;
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;
	
	THREE.PointCloudMaterial.prototype.clone = function () {
	
		var material = new THREE.PointCloudMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.map = this.map;
	
		material.size = this.size;
		material.sizeAttenuation = this.sizeAttenuation;
	
		material.vertexColors = this.vertexColors;
	
		material.fog = this.fog;
	
		return material;
	
	};
	
	// backwards compatibility
	
	THREE.ParticleBasicMaterial = function ( parameters ) {
	
		THREE.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
		return new THREE.PointCloudMaterial( parameters );
	
	};
	
	THREE.ParticleSystemMaterial = function ( parameters ) {
	
		THREE.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
		return new THREE.PointCloudMaterial( parameters );
	
	};
	
	// File:src/materials/ShaderMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.ShaderMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'ShaderMaterial';
	
		this.defines = {};
		this.uniforms = {};
		this.attributes = null;
	
		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
		this.shading = THREE.SmoothShading;
	
		this.linewidth = 1;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false; // set to use scene fog
	
		this.lights = false; // set to use scene lights
	
		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream
	
		this.skinning = false; // set to use skinning attribute streams
	
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals
	
		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};
	
		this.index0AttributeName = undefined;
	
		this.setValues( parameters );
	
	};
	
	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
	
	THREE.ShaderMaterial.prototype.clone = function () {
	
		var material = new THREE.ShaderMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.fragmentShader = this.fragmentShader;
		material.vertexShader = this.vertexShader;
	
		material.uniforms = THREE.UniformsUtils.clone( this.uniforms );
	
		material.attributes = this.attributes;
		material.defines = this.defines;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
	
		material.fog = this.fog;
	
		material.lights = this.lights;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
	
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;
	
		return material;
	
	};
	
	// File:src/materials/RawShaderMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RawShaderMaterial = function ( parameters ) {
	
		THREE.ShaderMaterial.call( this, parameters );
	
		this.type = 'RawShaderMaterial';
	
	};
	
	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
	
	THREE.RawShaderMaterial.prototype.clone = function () {
	
		var material = new THREE.RawShaderMaterial();
	
		THREE.ShaderMaterial.prototype.clone.call( this, material );
	
		return material;
	
	};
	
	// File:src/materials/SpriteMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.SpriteMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'SpriteMaterial';
	
		this.color = new THREE.Color( 0xffffff );
		this.map = null;
	
		this.rotation = 0;
	
		this.fog = false;
	
		// set parameters
	
		this.setValues( parameters );
	
	};
	
	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
	
	THREE.SpriteMaterial.prototype.clone = function () {
	
		var material = new THREE.SpriteMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.map = this.map;
	
		material.rotation = this.rotation;
	
		material.fog = this.fog;
	
		return material;
	
	};
	
	// File:src/textures/Texture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.sourceFile = '';
	
		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];
	
		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
	
		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
		this._needsUpdate = false;
		this.onUpdate = null;
	
	};
	
	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
	
	THREE.Texture.prototype = {
	
		constructor: THREE.Texture,
	
		get needsUpdate () {
	
			return this._needsUpdate;
	
		},
	
		set needsUpdate ( value ) {
	
			if ( value === true ) this.update();
	
			this._needsUpdate = value;
	
		},
	
		clone: function ( texture ) {
	
			if ( texture === undefined ) texture = new THREE.Texture();
	
			texture.image = this.image;
			texture.mipmaps = this.mipmaps.slice( 0 );
	
			texture.mapping = this.mapping;
	
			texture.wrapS = this.wrapS;
			texture.wrapT = this.wrapT;
	
			texture.magFilter = this.magFilter;
			texture.minFilter = this.minFilter;
	
			texture.anisotropy = this.anisotropy;
	
			texture.format = this.format;
			texture.type = this.type;
	
			texture.offset.copy( this.offset );
			texture.repeat.copy( this.repeat );
	
			texture.generateMipmaps = this.generateMipmaps;
			texture.premultiplyAlpha = this.premultiplyAlpha;
			texture.flipY = this.flipY;
			texture.unpackAlignment = this.unpackAlignment;
	
			return texture;
	
		},
	
		update: function () {
	
			this.dispatchEvent( { type: 'update' } );
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );
	
	THREE.TextureIdCount = 0;
	
	// File:src/textures/CubeTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
		
		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.images = images;
	
	};
	
	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
	
	THREE.CubeTexture.clone = function ( texture ) {
	
		if ( texture === undefined ) texture = new THREE.CubeTexture();
	
		THREE.Texture.prototype.clone.call( this, texture );
	
		texture.images = this.images;
	
		return texture;
	
	};
	
	// File:src/textures/CompressedTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;
	
		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )
	
		this.flipY = false;
	
		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files
	
		this.generateMipmaps = false;
	
	};
	
	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
	
	THREE.CompressedTexture.prototype.clone = function () {
	
		var texture = new THREE.CompressedTexture();
	
		THREE.Texture.prototype.clone.call( this, texture );
	
		return texture;
	
	};
	
	// File:src/textures/DataTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { data: data, width: width, height: height };
	
	};
	
	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;
	
	THREE.DataTexture.prototype.clone = function () {
	
		var texture = new THREE.DataTexture();
	
		THREE.Texture.prototype.clone.call( this, texture );
	
		return texture;
	
	};
	
	// File:src/textures/VideoTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.generateMipmaps = false;
	
		var scope = this;
	
		var update = function () {
	
			requestAnimationFrame( update );
	
			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
	
				scope.needsUpdate = true;
	
			}
	
		};
	
		update();
	
	};
	
	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
	
	// File:src/objects/Group.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Group = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Group';
	
	};
	
	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Group.prototype.constructor = THREE.Group;
	
	// File:src/objects/PointCloud.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.PointCloud = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'PointCloud';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );
	
	};
	
	THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );
	THREE.PointCloud.prototype.constructor = THREE.PointCloud;
	
	THREE.PointCloud.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
	
		return function ( raycaster, intersects ) {
	
			var object = this;
			var geometry = object.geometry;
			var threshold = raycaster.params.PointCloud.threshold;
	
			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			if ( geometry.boundingBox !== null ) {
	
				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {
	
					return;
	
				}
	
			}
	
			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var position = new THREE.Vector3();
	
			var testPoint = function ( point, index ) {
	
				var rayPointDistance = ray.distanceToPoint( point );
	
				if ( rayPointDistance < localThreshold ) {
	
					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( object.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
					intersects.push( {
	
						distance: distance,
						distanceToRay: rayPointDistance,
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object
	
					} );
	
				}
	
			};
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
	
				if ( attributes.index !== undefined ) {
	
					var indices = attributes.index.array;
					var offsets = geometry.offsets;
	
					if ( offsets.length === 0 ) {
	
						var offset = {
							start: 0,
							count: indices.length,
							index: 0
						};
	
						offsets = [ offset ];
	
					}
	
					for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {
	
						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;
	
						for ( var i = start, il = start + count; i < il; i ++ ) {
	
							var a = index + indices[ i ];
	
							position.fromArray( positions, a * 3 );
	
							testPoint( position, a );
	
						}
	
					}
	
				} else {
	
					var pointCount = positions.length / 3;
	
					for ( var i = 0; i < pointCount; i ++ ) {
	
						position.set(
							positions[ 3 * i ],
							positions[ 3 * i + 1 ],
							positions[ 3 * i + 2 ]
						);
	
						testPoint( position, i );
	
					}
	
				}
	
			} else {
	
				var vertices = this.geometry.vertices;
	
				for ( var i = 0; i < vertices.length; i ++ ) {
	
					testPoint( vertices[ i ], i );
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.PointCloud.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	// Backwards compatibility
	
	THREE.ParticleSystem = function ( geometry, material ) {
	
		THREE.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
		return new THREE.PointCloud( geometry, material );
	
	};
	
	// File:src/objects/Line.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Line = function ( geometry, material, mode ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Line';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.mode = mode !== undefined ? mode : THREE.LineStrip;
	
	};
	
	THREE.LineStrip = 0;
	THREE.LinePieces = 1;
	
	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Line.prototype.constructor = THREE.Line;
	
	THREE.Line.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		return function ( raycaster, intersects ) {
	
			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;
	
			var geometry = this.geometry;
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			// Checking boundingSphere distance to ray
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );
	
			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {
	
				return;
	
			}
	
			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this.mode === THREE.LineStrip ? 1 : 2;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var attributes = geometry.attributes;
	
				if ( attributes.index !== undefined ) {
	
					var indices = attributes.index.array;
					var positions = attributes.position.array;
					var offsets = geometry.offsets;
	
					if ( offsets.length === 0 ) {
	
						offsets = [ { start: 0, count: indices.length, index: 0 } ];
	
					}
	
					for ( var oi = 0; oi < offsets.length; oi ++) {
	
						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;
	
						for ( var i = start; i < start + count - 1; i += step ) {
	
							var a = index + indices[ i ];
							var b = index + indices[ i + 1 ];
	
							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );
	
							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
							if ( distSq > precisionSq ) continue;
	
							var distance = ray.origin.distanceTo( interRay );
	
							if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								offsetIndex: oi,
								face: null,
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					}
	
				} else {
	
					var positions = attributes.position.array;
	
					for ( var i = 0; i < positions.length / 3 - 1; i += step ) {
	
						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );
	
						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
						if ( distSq > precisionSq ) continue;
	
						var distance = ray.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				}
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
	
				for ( var i = 0; i < nbVertices - 1; i += step ) {
	
					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
					if ( distSq > precisionSq ) continue;
	
					var distance = ray.origin.distanceTo( interRay );
	
					if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
					intersects.push( {
	
						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this
	
					} );
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Line.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	// File:src/objects/Mesh.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */
	
	THREE.Mesh = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Mesh';
		
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.updateMorphTargets();
	
	};
	
	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Mesh.prototype.constructor = THREE.Mesh;
	
	THREE.Mesh.prototype.updateMorphTargets = function () {
	
		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {
	
			this.morphTargetBase = - 1;
			this.morphTargetForcedOrder = [];
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};
	
			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {
	
				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;
	
			}
	
		}
	
	};
	
	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {
	
		if ( this.morphTargetDictionary[ name ] !== undefined ) {
	
			return this.morphTargetDictionary[ name ];
	
		}
	
		THREE.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );
	
		return 0;
	
	};
	
	
	THREE.Mesh.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();
	
		return function ( raycaster, intersects ) {
	
			var geometry = this.geometry;
	
			// Checking boundingSphere distance to ray
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );
	
			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {
	
				return;
	
			}
	
			// Check boundingBox before continuing
	
			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			if ( geometry.boundingBox !== null ) {
	
				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {
	
					return;
	
				}
	
			}
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var material = this.material;
	
				if ( material === undefined ) return;
	
				var attributes = geometry.attributes;
	
				var a, b, c;
				var precision = raycaster.precision;
	
				if ( attributes.index !== undefined ) {
	
					var indices = attributes.index.array;
					var positions = attributes.position.array;
					var offsets = geometry.offsets;
	
					if ( offsets.length === 0 ) {
	
						offsets = [ { start: 0, count: indices.length, index: 0 } ];
	
					}
	
					for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {
	
						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;
	
						for ( var i = start, il = start + count; i < il; i += 3 ) {
	
							a = index + indices[ i ];
							b = index + indices[ i + 1 ];
							c = index + indices[ i + 2 ];
	
							vA.fromArray( positions, a * 3 );
							vB.fromArray( positions, b * 3 );
							vC.fromArray( positions, c * 3 );
	
							if ( material.side === THREE.BackSide ) {
	
								var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );
	
							} else {
	
								var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );
	
							}
	
							if ( intersectionPoint === null ) continue;
	
							intersectionPoint.applyMatrix4( this.matrixWorld );
	
							var distance = raycaster.ray.origin.distanceTo( intersectionPoint );
	
							if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								point: intersectionPoint,
								face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					}
	
				} else {
	
					var positions = attributes.position.array;
	
					for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {
	
						a = i;
						b = i + 1;
						c = i + 2;
	
						vA.fromArray( positions, j );
						vB.fromArray( positions, j + 3 );
						vC.fromArray( positions, j + 6 );
	
						if ( material.side === THREE.BackSide ) {
	
							var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );
	
						} else {
	
							var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );
	
						}
	
						if ( intersectionPoint === null ) continue;
	
						intersectionPoint.applyMatrix4( this.matrixWorld );
	
						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );
	
						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							point: intersectionPoint,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				}
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
				var objectMaterials = isFaceMaterial === true ? this.material.materials : null;
	
				var a, b, c;
				var precision = raycaster.precision;
	
				var vertices = geometry.vertices;
	
				for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {
	
					var face = geometry.faces[ f ];
	
					var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;
	
					if ( material === undefined ) continue;
	
					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];
	
					if ( material.morphTargets === true ) {
	
						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;
	
						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );
	
						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
							var influence = morphInfluences[ t ];
	
							if ( influence === 0 ) continue;
	
							var targets = morphTargets[ t ].vertices;
	
							vA.x += ( targets[ face.a ].x - a.x ) * influence;
							vA.y += ( targets[ face.a ].y - a.y ) * influence;
							vA.z += ( targets[ face.a ].z - a.z ) * influence;
	
							vB.x += ( targets[ face.b ].x - b.x ) * influence;
							vB.y += ( targets[ face.b ].y - b.y ) * influence;
							vB.z += ( targets[ face.b ].z - b.z ) * influence;
	
							vC.x += ( targets[ face.c ].x - c.x ) * influence;
							vC.y += ( targets[ face.c ].y - c.y ) * influence;
							vC.z += ( targets[ face.c ].z - c.z ) * influence;
	
						}
	
						vA.add( a );
						vB.add( b );
						vC.add( c );
	
						a = vA;
						b = vB;
						c = vC;
	
					}
	
					if ( material.side === THREE.BackSide ) {
	
						var intersectionPoint = ray.intersectTriangle( c, b, a, true );
	
					} else {
	
						var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );
	
					}
	
					if ( intersectionPoint === null ) continue;
	
					intersectionPoint.applyMatrix4( this.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );
	
					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;
	
					intersects.push( {
	
						distance: distance,
						point: intersectionPoint,
						face: face,
						faceIndex: f,
						object: this
	
					} );
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Mesh.prototype.clone = function ( object, recursive ) {
	
		if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );
	
		THREE.Object3D.prototype.clone.call( this, object, recursive );
	
		return object;
	
	};
	
	// File:src/objects/Bone.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Bone = function ( skin ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Bone';
	
		this.skin = skin;
	
	};
	
	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Bone.prototype.constructor = THREE.Bone;
	
	// File:src/objects/Skeleton.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {
	
		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
		this.identityMatrix = new THREE.Matrix4();
	
		// copy the bone array
	
		bones = bones || [];
	
		this.bones = bones.slice( 0 );
	
		// create a bone texture or an array of floats
	
		if ( this.useVertexTexture ) {
	
			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
			//       16x16 pixel texture max   64 bones (16 * 16 / 4)
			//       32x32 pixel texture max  256 bones (32 * 32 / 4)
			//       64x64 pixel texture max 1024 bones (64 * 64 / 4)
	
			var size;
	
			if ( this.bones.length > 256 )
				size = 64;
			else if ( this.bones.length > 64 )
				size = 32;
			else if ( this.bones.length > 16 )
				size = 16;
			else
				size = 8;
	
			this.boneTextureWidth = size;
			this.boneTextureHeight = size;
	
			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
			this.boneTexture.minFilter = THREE.NearestFilter;
			this.boneTexture.magFilter = THREE.NearestFilter;
			this.boneTexture.generateMipmaps = false;
			this.boneTexture.flipY = false;
	
		} else {
	
			this.boneMatrices = new Float32Array( 16 * this.bones.length );
	
		}
	
		// use the supplied bone inverses or calculate the inverses
	
		if ( boneInverses === undefined ) {
	
			this.calculateInverses();
	
		} else {
	
			if ( this.bones.length === boneInverses.length ) {
	
				this.boneInverses = boneInverses.slice( 0 );
	
			} else {
	
				THREE.warn( 'THREE.Skeleton bonInverses is the wrong length.' );
	
				this.boneInverses = [];
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					this.boneInverses.push( new THREE.Matrix4() );
	
				}
	
			}
	
		}
	
	};
	
	THREE.Skeleton.prototype.calculateInverses = function () {
	
		this.boneInverses = [];
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			var inverse = new THREE.Matrix4();
	
			if ( this.bones[ b ] ) {
	
				inverse.getInverse( this.bones[ b ].matrixWorld );
	
			}
	
			this.boneInverses.push( inverse );
	
		}
	
	};
	
	THREE.Skeleton.prototype.pose = function () {
	
		var bone;
	
		// recover the bind-time world matrices
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			bone = this.bones[ b ];
	
			if ( bone ) {
	
				bone.matrixWorld.getInverse( this.boneInverses[ b ] );
	
			}
	
		}
	
		// compute the local matrices, positions, rotations and scales
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			bone = this.bones[ b ];
	
			if ( bone ) {
	
				if ( bone.parent ) {
	
					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );
	
				} else {
	
					bone.matrix.copy( bone.matrixWorld );
	
				}
	
				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
			}
	
		}
	
	};
	
	THREE.Skeleton.prototype.update = ( function () {
	
		var offsetMatrix = new THREE.Matrix4();
		
		return function () {
	
			// flatten bone matrices to array
	
			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
				// compute the offset between the current and the original transform
	
				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;
	
				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );
	
			}
	
			if ( this.useVertexTexture ) {
	
				this.boneTexture.needsUpdate = true;
	
			}
			
		};
	
	} )();
	
	
	// File:src/objects/SkinnedMesh.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.type = 'SkinnedMesh';
	
		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();
	
		// init bones
	
		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.
	
		var bones = [];
	
		if ( this.geometry && this.geometry.bones !== undefined ) {
	
			var bone, gbone, p, q, s;
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				p = gbone.pos;
				q = gbone.rotq;
				s = gbone.scl;
	
				bone = new THREE.Bone( this );
				bones.push( bone );
	
				bone.name = gbone.name;
				bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
				bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );
	
				if ( s !== undefined ) {
	
					bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );
	
				} else {
	
					bone.scale.set( 1, 1, 1 );
	
				}
	
			}
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				if ( gbone.parent !== - 1 ) {
	
					bones[ gbone.parent ].add( bones[ b ] );
	
				} else {
	
					this.add( bones[ b ] );
	
				}
	
			}
	
		}
	
		this.normalizeSkinWeights();
	
		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );
	
	};
	
	
	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
	
	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {
	
		this.skeleton = skeleton;
	
		if ( bindMatrix === undefined ) {
	
			this.updateMatrixWorld( true );
	
			bindMatrix = this.matrixWorld;
	
		}
	
		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );
	
	};
	
	THREE.SkinnedMesh.prototype.pose = function () {
	
		this.skeleton.pose();
	
	};
	
	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
	
		if ( this.geometry instanceof THREE.Geometry ) {
	
			for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {
	
				var sw = this.geometry.skinWeights[ i ];
	
				var scale = 1.0 / sw.lengthManhattan();
	
				if ( scale !== Infinity ) {
	
					sw.multiplyScalar( scale );
	
				} else {
	
					sw.set( 1 ); // this will be normalized by the shader anyway
	
				}
	
			}
	
		} else {
	
			// skinning weights assumed to be normalized for THREE.BufferGeometry
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {
	
		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );
	
		if ( this.bindMode === "attached" ) {
	
			this.bindMatrixInverse.getInverse( this.matrixWorld );
	
		} else if ( this.bindMode === "detached" ) {
	
			this.bindMatrixInverse.getInverse( this.bindMatrix );
	
		} else {
	
			THREE.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.clone = function( object ) {
	
		if ( object === undefined ) {
	
			object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );
	
		}
	
		THREE.Mesh.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	
	// File:src/objects/MorphAnimMesh.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphAnimMesh = function ( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.type = 'MorphAnimMesh';
	
		// API
	
		this.duration = 1000; // milliseconds
		this.mirroredLoop = false;
		this.time = 0;
	
		// internals
	
		this.lastKeyframe = 0;
		this.currentKeyframe = 0;
	
		this.direction = 1;
		this.directionBackwards = false;
	
		this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );
	
	};
	
	THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;
	
	THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {
	
		this.startKeyframe = start;
		this.endKeyframe = end;
	
		this.length = this.endKeyframe - this.startKeyframe + 1;
	
	};
	
	THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
	
		this.direction = 1;
		this.directionBackwards = false;
	
	};
	
	THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
	
		this.direction = - 1;
		this.directionBackwards = true;
	
	};
	
	THREE.MorphAnimMesh.prototype.parseAnimations = function () {
	
		var geometry = this.geometry;
	
		if ( ! geometry.animations ) geometry.animations = {};
	
		var firstAnimation, animations = geometry.animations;
	
		var pattern = /([a-z]+)_?(\d+)/;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var parts = morph.name.match( pattern );
	
			if ( parts && parts.length > 1 ) {
	
				var label = parts[ 1 ];
	
				if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };
	
				var animation = animations[ label ];
	
				if ( i < animation.start ) animation.start = i;
				if ( i > animation.end ) animation.end = i;
	
				if ( ! firstAnimation ) firstAnimation = label;
	
			}
	
		}
	
		geometry.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {
	
		if ( ! this.geometry.animations ) this.geometry.animations = {};
	
		this.geometry.animations[ label ] = { start: start, end: end };
	
	};
	
	THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {
	
		var animation = this.geometry.animations[ label ];
	
		if ( animation ) {
	
			this.setFrameRange( animation.start, animation.end );
			this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
			this.time = 0;
	
		} else {
	
			THREE.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );
	
		}
	
	};
	
	THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {
	
		var frameTime = this.duration / this.length;
	
		this.time += this.direction * delta;
	
		if ( this.mirroredLoop ) {
	
			if ( this.time > this.duration || this.time < 0 ) {
	
				this.direction *= - 1;
	
				if ( this.time > this.duration ) {
	
					this.time = this.duration;
					this.directionBackwards = true;
	
				}
	
				if ( this.time < 0 ) {
	
					this.time = 0;
					this.directionBackwards = false;
	
				}
	
			}
	
		} else {
	
			this.time = this.time % this.duration;
	
			if ( this.time < 0 ) this.time += this.duration;
	
		}
	
		var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );
	
		if ( keyframe !== this.currentKeyframe ) {
	
			this.morphTargetInfluences[ this.lastKeyframe ] = 0;
			this.morphTargetInfluences[ this.currentKeyframe ] = 1;
	
			this.morphTargetInfluences[ keyframe ] = 0;
	
			this.lastKeyframe = this.currentKeyframe;
			this.currentKeyframe = keyframe;
	
		}
	
		var mix = ( this.time % frameTime ) / frameTime;
	
		if ( this.directionBackwards ) {
	
			mix = 1 - mix;
	
		}
	
		this.morphTargetInfluences[ this.currentKeyframe ] = mix;
		this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;
	
	};
	
	THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {
	
		var influences = this.morphTargetInfluences;
	
		for ( var i = 0, l = influences.length; i < l; i ++ ) {
	
			influences[ i ] = 0;
	
		}
	
		if ( a > -1 ) influences[ a ] = 1 - t;
		if ( b > -1 ) influences[ b ] = t;
	
	};
	
	THREE.MorphAnimMesh.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );
	
		object.duration = this.duration;
		object.mirroredLoop = this.mirroredLoop;
		object.time = this.time;
	
		object.lastKeyframe = this.lastKeyframe;
		object.currentKeyframe = this.currentKeyframe;
	
		object.direction = this.direction;
		object.directionBackwards = this.directionBackwards;
	
		THREE.Mesh.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	// File:src/objects/LOD.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LOD = function () {
	
		THREE.Object3D.call( this );
	
		this.objects = [];
	
	};
	
	
	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LOD.prototype.constructor = THREE.LOD;
	
	THREE.LOD.prototype.addLevel = function ( object, distance ) {
	
		if ( distance === undefined ) distance = 0;
	
		distance = Math.abs( distance );
	
		for ( var l = 0; l < this.objects.length; l ++ ) {
	
			if ( distance < this.objects[ l ].distance ) {
	
				break;
	
			}
	
		}
	
		this.objects.splice( l, 0, { distance: distance, object: object } );
		this.add( object );
	
	};
	
	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {
	
		for ( var i = 1, l = this.objects.length; i < l; i ++ ) {
	
			if ( distance < this.objects[ i ].distance ) {
	
				break;
	
			}
	
		}
	
		return this.objects[ i - 1 ].object;
	
	};
	
	THREE.LOD.prototype.raycast = ( function () {
	
		var matrixPosition = new THREE.Vector3();
	
		return function ( raycaster, intersects ) {
	
			matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
			var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
			this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
		};
	
	}() );
	
	THREE.LOD.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function ( camera ) {
	
			if ( this.objects.length > 1 ) {
	
				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );
	
				var distance = v1.distanceTo( v2 );
	
				this.objects[ 0 ].object.visible = true;
	
				for ( var i = 1, l = this.objects.length; i < l; i ++ ) {
	
					if ( distance >= this.objects[ i ].distance ) {
	
						this.objects[ i - 1 ].object.visible = false;
						this.objects[ i     ].object.visible = true;
	
					} else {
	
						break;
	
					}
	
				}
	
				for ( ; i < l; i ++ ) {
	
					this.objects[ i ].object.visible = false;
	
				}
	
			}
	
		};
	
	}();
	
	THREE.LOD.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.LOD();
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
			var x = this.objects[ i ].object.clone();
			x.visible = i === 0;
			object.addLevel( x, this.objects[ i ].distance );
		}
	
		return object;
	
	};
	
	// File:src/objects/Sprite.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Sprite = ( function () {
	
		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );
	
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
		return function ( material ) {
	
			THREE.Object3D.call( this );
	
			this.type = 'Sprite';
	
			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();
	
		};
	
	} )();
	
	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Sprite.prototype.constructor = THREE.Sprite;
	
	THREE.Sprite.prototype.raycast = ( function () {
	
		var matrixPosition = new THREE.Vector3();
	
		return function ( raycaster, intersects ) {
	
			matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
			var distance = raycaster.ray.distanceToPoint( matrixPosition );
	
			if ( distance > this.scale.x ) {
	
				return;
	
			}
	
			intersects.push( {
	
				distance: distance,
				point: this.position,
				face: null,
				object: this
	
			} );
	
		};
	
	}() );
	
	THREE.Sprite.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Sprite( this.material );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	// Backwards compatibility
	
	THREE.Particle = THREE.Sprite;
	
	// File:src/objects/LensFlare.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlare = function ( texture, size, distance, blending, color ) {
	
		THREE.Object3D.call( this );
	
		this.lensFlares = [];
	
		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;
	
		if ( texture !== undefined ) {
	
			this.add( texture, size, distance, blending, color );
	
		}
	
	};
	
	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LensFlare.prototype.constructor = THREE.LensFlare;
	
	
	/*
	 * Add: adds another flare
	 */
	
	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {
	
		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;
	
		distance = Math.min( distance, Math.max( 0, distance ) );
	
		this.lensFlares.push( {
			texture: texture, 			// THREE.Texture
			size: size, 				// size in pixels (-1 = use texture.width)
			distance: distance, 		// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
			scale: 1, 					// scale
			rotation: 1, 				// rotation
			opacity: opacity,			// opacity
			color: color,				// color
			blending: blending			// blending
		} );
	
	};
	
	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */
	
	THREE.LensFlare.prototype.updateLensFlares = function () {
	
		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;
	
		for ( f = 0; f < fl; f ++ ) {
	
			flare = this.lensFlares[ f ];
	
			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;
	
			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
		}
	
	};
	
	
	// File:src/scenes/Scene.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Scene = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Scene';
	
		this.fog = null;
		this.overrideMaterial = null;
	
		this.autoUpdate = true; // checked by the renderer
	
	};
	
	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;
	
	THREE.Scene.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Scene();
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		if ( this.fog !== null ) object.fog = this.fog.clone();
		if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();
	
		object.autoUpdate = this.autoUpdate;
		object.matrixAutoUpdate = this.matrixAutoUpdate;
	
		return object;
	
	};
	
	// File:src/scenes/Fog.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Fog = function ( color, near, far ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
	
		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;
	
	};
	
	THREE.Fog.prototype.clone = function () {
	
		return new THREE.Fog( this.color.getHex(), this.near, this.far );
	
	};
	
	// File:src/scenes/FogExp2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.FogExp2 = function ( color, density ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;
	
	};
	
	THREE.FogExp2.prototype.clone = function () {
	
		return new THREE.FogExp2( this.color.getHex(), this.density );
	
	};
	
	// File:src/renderers/shaders/ShaderChunk.js
	
	THREE.ShaderChunk = {};
	
	// File:src/renderers/shaders/ShaderChunk/common.glsl
	
	THREE.ShaderChunk[ 'common' ] ="#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n\tfloat distance = dot( planeNormal, point-pointOnPlane );\n\treturn point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\tif ( decayExponent > 0.0 ) {\n\t  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n\t}\n\treturn 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n\treturn a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n\treturn a;\n#endif\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl
	
	THREE.ShaderChunk[ 'alphatest_fragment' ] ="#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_lambert_vertex' ] ="vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n\tfloat dotProduct = dot( transformedNormal, dirVector );\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t#endif\n\n\t#endif\n\n\t#ifdef WRAP_AROUND\n\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n\t\t#endif\n\n\t#endif\n\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n\t#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\t\tlVector = normalize( lVector );\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n\t\t\tlVector = normalize( lVector );\n\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n\t\t\t#endif\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n\t\t#endif\n\n\t}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack += ambientLightColor;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_pars_fragment' ] ="#ifdef USE_MAP\n\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl
	
	THREE.ShaderChunk[ 'default_vertex' ] ="#ifdef USE_SKINNING\n\n\tvec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n\tvec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_pars_fragment' ] ="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'skinnormal_vertex' ] ="#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\t#ifdef USE_MORPHNORMALS\n\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n\t#else\n\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] ="#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n\tuniform float logDepthBufFC;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'lightmap_pars_vertex' ] ="#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_fragment' ] ="#ifndef FLAT_SHADED\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n\t#endif\n\n#else\n\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\t\tlVector = normalize( lVector );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\ttotalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n\t\t\t\t// specular\n\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\ttotalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n\t\tlVector = normalize( lVector );\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\t// diffuse\n\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n\t\t\t#else\n\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t\t#endif\n\n\t\t\ttotalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n\t\t\t// specular\n\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n\t\t\ttotalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\t\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, dirVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\ttotalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n\t\t// specular\n\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n\t\t/*\n\t\t// fresnel term from skin shader\n\t\tconst float F0 = 0.128;\n\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\n\t\tfloat exponential = pow( base, 5.0 );\n\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\n\t\t*/\n\n\t\t/*\n\t\t// fresnel term from fresnel shader\n\t\tconst float mFresnelBias = 0.08;\n\t\tconst float mFresnelScale = 0.3;\n\t\tconst float mFresnelPower = 5.0;\n\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n\t\t*/\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\ttotalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\ttotalDiffuseLight += hemiColor;\n\n\t\t// specular (sky light)\n\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n\t\t// specular (ground light)\n\n\t\tvec3 lVectorGround = -lVector;\n\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n\t\ttotalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n\t}\n\n#endif\n\n#ifdef METAL\n\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_pars_fragment' ] ="#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'morphnormal_vertex' ] ="#ifdef USE_MORPHNORMALS\n\n\tvec3 morphedNormal = vec3( 0.0 );\n\n\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n\tmorphedNormal += normal;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_fragment' ] ="#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tuniform float refractionRatio;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_fragment' ] ="#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'normalmap_pars_fragment' ] ="#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_phong_pars_vertex' ] ="#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_pars_fragment' ] ="#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\tuniform sampler2D lightMap;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_vertex' ] ="#ifdef USE_SHADOWMAP\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n\t}\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_phong_vertex' ] ="#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl
	
	THREE.ShaderChunk[ 'map_fragment' ] ="#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\n\n\tdiffuseColor *= texelColor;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl
	
	THREE.ShaderChunk[ 'lightmap_vertex' ] ="#ifdef USE_LIGHTMAP\n\n\tvUv2 = uv2;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_fragment' ] ="#ifdef USE_MAP\n\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'color_pars_fragment' ] ="#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl
	
	THREE.ShaderChunk[ 'color_vertex' ] ="#ifdef USE_COLOR\n\n\tvColor.xyz = inputToLinear( color.xyz );\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_vertex' ] ="#ifdef USE_SKINNING\n\n\t#ifdef USE_MORPHTARGETS\n\n\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n\t#else\n\n\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_vertex' ] ="#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvarying vec3 vReflect;\n\n\tuniform float refractionRatio;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl
	
	THREE.ShaderChunk[ 'linear_to_gamma_fragment' ] ="\n\toutgoingLight = linearToOutput( outgoingLight );\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'color_pars_vertex' ] ="#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_lambert_pars_vertex' ] ="uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'map_pars_vertex' ] ="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_fragment' ] ="#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\n\tenvColor.xyz = inputToLinear( envColor.xyz );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_pars_fragment' ] ="#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_vertex' ] ="#ifdef USE_LOGDEPTHBUF\n\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n\t#endif\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] ="#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_fragment' ] ="float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_fragment' ] ="#ifdef USE_FOG\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t#else\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t#endif\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n\t\tfogFactor = whiteCompliment( fogFactor );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\n\t#endif\n\t\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'bumpmap_pars_fragment' ] ="#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'defaultnormal_vertex' ] ="#ifdef USE_SKINNING\n\n\tvec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n\tvec3 objectNormal = morphedNormal;\n\n#else\n\n\tvec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n\tobjectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_pars_fragment' ] ="uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl
	
	THREE.ShaderChunk[ 'skinbase_vertex' ] ="#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl
	
	THREE.ShaderChunk[ 'map_vertex' ] ="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_fragment' ] ="#ifdef USE_LIGHTMAP\n\n\toutgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_vertex' ] ="#ifdef USE_SHADOWMAP\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl
	
	THREE.ShaderChunk[ 'color_fragment' ] ="#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_vertex' ] ="#ifdef USE_MORPHTARGETS\n\n\tvec3 morphed = vec3( 0.0 );\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n\tmorphed += position;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_vertex' ] ="#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t#else\n\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmap_fragment' ] ="#ifdef USE_SHADOWMAP\n\n\t#ifdef SHADOWMAP_DEBUG\n\n\t\tvec3 frustumColors[3];\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n\t#endif\n\n\t#ifdef SHADOWMAP_CASCADE\n\n\t\tint inFrustumCount = 0;\n\n\t#endif\n\n\tfloat fDepth;\n\tvec3 shadowColor = vec3( 1.0 );\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\tinFrustumCount += int( inFrustum );\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n\t\t#else\n\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\t#endif\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\t\t\tshadow += 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tshadow /= 9.0;\n\n\t\t*/\n\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\n\n\t\t\t\tmat3 shadowKernel;\n\t\t\t\tmat3 depthKernel;\n\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\n\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n\t\t\t\tvec4 shadowValues;\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#else\n\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\tif ( fDepth < shadowCoord.z )\n\n\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n\t\t\t#endif\n\n\t\t}\n\n\n\t\t#ifdef SHADOWMAP_DEBUG\n\n\t\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n\t\t\t#else\n\n\t\t\t\tif ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t}\n\n\t// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n\tshadowColor = inputToLinear( shadowColor );\n\n\toutgoingLight = outgoingLight * shadowColor;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl
	
	THREE.ShaderChunk[ 'worldpos_vertex' ] ="#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n\t#ifdef USE_SKINNING\n\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\n\t#elif defined( USE_MORPHTARGETS )\n\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n\t#else\n\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_fragment' ] ="#ifdef USE_SHADOWMAP\n\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\n\tuniform float shadowBias[ MAX_SHADOWS ];\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\tfloat depth = dot( rgba_depth, bit_shift );\n\t\treturn depth;\n\n\t}\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_pars_vertex' ] ="#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] ="#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_fragment' ] ="#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_pars_fragment' ] ="#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n";
	
	// File:src/renderers/shaders/UniformsUtils.js
	
	/**
	 * Uniform Utilities
	 */
	
	THREE.UniformsUtils = {
	
		merge: function ( uniforms ) {
	
			var merged = {};
	
			for ( var u = 0; u < uniforms.length; u ++ ) {
	
				var tmp = this.clone( uniforms[ u ] );
	
				for ( var p in tmp ) {
	
					merged[ p ] = tmp[ p ];
	
				}
	
			}
	
			return merged;
	
		},
	
		clone: function ( uniforms_src ) {
	
			var uniforms_dst = {};
	
			for ( var u in uniforms_src ) {
	
				uniforms_dst[ u ] = {};
	
				for ( var p in uniforms_src[ u ] ) {
	
					var parameter_src = uniforms_src[ u ][ p ];
	
					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.clone();
	
					} else if ( parameter_src instanceof Array ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.slice();
	
					} else {
	
						uniforms_dst[ u ][ p ] = parameter_src;
	
					}
	
				}
	
			}
	
			return uniforms_dst;
	
		}
	
	};
	
	// File:src/renderers/shaders/UniformsLib.js
	
	/**
	 * Uniforms library for shared webgl shaders
	 */
	
	THREE.UniformsLib = {
	
		common: {
	
			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
	
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
	
			"lightMap" : { type: "t", value: null },
			"specularMap" : { type: "t", value: null },
			"alphaMap" : { type: "t", value: null },
	
			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: - 1 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 },
	
			"morphTargetInfluences" : { type: "f", value: 0 }
	
		},
	
		bump: {
	
			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }
	
		},
	
		normalmap: {
	
			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
		},
	
		fog : {
	
			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		lights: {
	
			"ambientLightColor" : { type: "fv", value: [] },
	
			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },
	
			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },
	
			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },
			"pointLightDecay" : { type: "fv1", value: [] },
	
			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] },
			"spotLightDecay" : { type: "fv1", value: [] }
	
		},
	
		particle: {
	
			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
	
			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		shadowmap: {
	
			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },
	
			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },
	
			"shadowMatrix" : { type: "m4v", value: [] }
	
		}
	
	};
	
	// File:src/renderers/shaders/ShaderLib.js
	
	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	
	THREE.ShaderLib = {
	
		'basic': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]
	
			] ),
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
	
				"	#ifdef USE_ENVMAP",
	
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"	#endif",
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb;", // simple shader
	
					THREE.ShaderChunk[ "lightmap_fragment" ],		// TODO: Light map on an otherwise unlit surface doesn't make sense.
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],		// TODO: Shadows on an otherwise unlit surface doesn't make sense.
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
	
				"}"
	
			].join("\n")
	
		},
	
		'lambert': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}
	
			] ),
	
			vertexShader: [
	
				"#define LAMBERT",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
				"	varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float opacity;",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
				"	varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
	
				"	#ifdef DOUBLE_SIDED",
	
						//"float isFront = float( gl_FrontFacing );",
						//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",
	
				"		if ( gl_FrontFacing )",
				"			outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
				"		else",
				"			outgoingLight += diffuseColor.rgb * vLightBack + emissive;",
	
				"	#else",
	
				"		outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
	
				"	#endif",
	
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
	
				"}"
	
			].join("\n")
	
		},
	
		'phong': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "bump" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}
	
			] ),
	
			vertexShader: [
	
				"#define PHONG",
	
				"varying vec3 vViewPosition;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED
	
				"	vNormal = normalize( transformedNormal );",
	
				"#endif",
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"	vViewPosition = -mvPosition.xyz;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"#define PHONG",
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
	
					THREE.ShaderChunk[ "lights_phong_fragment" ],
	
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
	
				"}"
	
			].join("\n")
	
		},
	
		'particle_basic': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "particle" ],
				THREE.UniformsLib[ "shadowmap" ]
	
			] ),
	
			vertexShader: [
	
				"uniform float size;",
				"uniform float scale;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	
				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",
	
				"	gl_Position = projectionMatrix * mvPosition;",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 psColor;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( psColor, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb;", // simple shader
	
					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
	
				"}"
	
			].join("\n")
	
		},
	
		'dashed': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
	
				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}
	
			] ),
	
			vertexShader: [
	
				"uniform float scale;",
				"attribute float lineDistance;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
				"	vLineDistance = scale * lineDistance;",
	
				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"uniform float dashSize;",
				"uniform float totalSize;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",
	
				"		discard;",
	
				"	}",
	
				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb;", // simple shader
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
	
				"}"
	
			].join("\n")
	
		},
	
		'depth': {
	
			uniforms: {
	
				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"	#ifdef USE_LOGDEPTHBUF_EXT",
	
				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",
	
				"	#else",
	
				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",
	
				"	#endif",
	
				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",   // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
	
				"}"
	
			].join("\n")
	
		},
	
		'normal': {
	
			uniforms: {
	
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vNormal = normalize( normalMatrix * normal );",
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform float opacity;",
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'cube': {
	
			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vWorldPosition = transformDirection( position, modelMatrix );",
	
				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform samplerCube tCube;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'equirect': {
	
			uniforms: { "tEquirect": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vWorldPosition = transformDirection( position, modelMatrix );",
	
				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform sampler2D tEquirect;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
					// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
					"vec3 direction = normalize( vWorldPosition );",
					"vec2 sampleUV;",
					"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
					"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
					"gl_FragColor = texture2D( tEquirect, sampleUV );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */
	
		'depthRGBA': {
	
			uniforms: {},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"vec4 pack_depth( const in float depth ) {",
	
				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",
	
				"}",
	
				"void main() {",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"	#ifdef USE_LOGDEPTHBUF_EXT",
	
				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",
	
				"	#else",
	
				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",
	
				"	#endif",
	
					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",
	
				"}"
	
			].join("\n")
	
		}
	
	};
	
	// File:src/renderers/WebGLRenderer.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.WebGLRenderer = function ( parameters ) {
	
		console.log( 'THREE.WebGLRenderer', THREE.REVISION );
	
		parameters = parameters || {};
	
		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,
	
		pixelRatio = 1,
	
		_precision = parameters.precision !== undefined ? parameters.precision : 'highp',
	
		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,
	
		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0;
	
		var lights = [];
	
		var _webglObjects = {};
		var _webglObjectsImmediate = [];
	
		var opaqueObjects = [];
		var transparentObjects = [];
	
		var sprites = [];
		var lensFlares = [];
	
		// public properties
	
		this.domElement = _canvas;
		this.context = null;
	
		// clearing
	
		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
	
		// scene graph
	
		this.sortObjects = true;
	
		// physically based shading
	
		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;
	
		// shadow map
	
		this.shadowMapEnabled = false;
		this.shadowMapType = THREE.PCFShadowMap;
		this.shadowMapCullFace = THREE.CullFaceFront;
		this.shadowMapDebug = false;
		this.shadowMapCascade = false;
	
		// morphs
	
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
	
		// flags
	
		this.autoScaleCubemaps = true;
	
		// info
	
		this.info = {
	
			memory: {
	
				programs: 0,
				geometries: 0,
				textures: 0
	
			},
	
			render: {
	
				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0
	
			}
	
		};
	
		// internal properties
	
		var _this = this,
	
		_programs = [],
	
		// internal state cache
	
		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,
	
		_usedTextureUnits = 0,
	
		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = _canvas.width,
		_viewportHeight = _canvas.height,
		_currentWidth = 0,
		_currentHeight = 0,
	
		// frustum
	
		_frustum = new THREE.Frustum(),
	
		 // camera matrices cache
	
		_projScreenMatrix = new THREE.Matrix4(),
	
		_vector3 = new THREE.Vector3(),
	
		// light arrays cache
	
		_direction = new THREE.Vector3(),
	
		_lightsNeedUpdate = true,
	
		_lights = {
	
			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors:[], positions: [] },
			point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
			spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
			hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }
	
		};
	
		// initialize
	
		var _gl;
	
		try {
	
			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};
	
			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );
	
			if ( _gl === null ) {
	
				if ( _canvas.getContext( 'webgl') !== null ) {
	
					throw 'Error creating WebGL context with your selected attributes.';
	
				} else {
	
					throw 'Error creating WebGL context.';
	
				}
	
			}
	
			_canvas.addEventListener( 'webglcontextlost', function ( event ) {
	
				event.preventDefault();
	
				resetGLState();
				setDefaultGLState();
	
				_webglObjects = {};
	
			}, false);
	
		} catch ( error ) {
	
			THREE.error( 'THREE.WebGLRenderer: ' + error );
	
		}
	
		var state = new THREE.WebGLState( _gl, paramThreeToGL );
	
		if ( _gl.getShaderPrecisionFormat === undefined ) {
	
			_gl.getShaderPrecisionFormat = function () {
	
				return {
					'rangeMin': 1,
					'rangeMax': 1,
					'precision': 1
				};
	
			}
	
		}
	
		var extensions = new THREE.WebGLExtensions( _gl );
	
		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );
	
		if ( _logarithmicDepthBuffer ) {
	
			extensions.get( 'EXT_frag_depth' );
	
		}
	
		//
	
		var glClearColor = function ( r, g, b, a ) {
	
			if ( _premultipliedAlpha === true ) {
	
				r *= a; g *= a; b *= a;
	
			}
	
			_gl.clearColor( r, g, b, a );
	
		};
	
		var setDefaultGLState = function () {
	
			_gl.clearColor( 0, 0, 0, 1 );
			_gl.clearDepth( 1 );
			_gl.clearStencil( 0 );
	
			_gl.enable( _gl.DEPTH_TEST );
			_gl.depthFunc( _gl.LEQUAL );
	
			_gl.frontFace( _gl.CCW );
			_gl.cullFace( _gl.BACK );
			_gl.enable( _gl.CULL_FACE );
	
			_gl.enable( _gl.BLEND );
			_gl.blendEquation( _gl.FUNC_ADD );
			_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );
	
			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		var resetGLState = function () {
	
			_currentProgram = null;
			_currentCamera = null;
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
	
			_lightsNeedUpdate = true;
	
			state.reset();
	
		};
	
		setDefaultGLState();
	
		this.context = _gl;
		this.state = state;
	
		// GPU capabilities
	
		var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
		var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
		var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
		var _supportsVertexTextures = _maxVertexTextures > 0;
		var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );
	
		//
	
		var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
		var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	
		var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
		var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	
		var getCompressedTextureFormats = ( function () {
	
			var array;
	
			return function () {
	
				if ( array !== undefined ) {
	
					return array;
	
				}
	
				array = [];
	
				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {
	
					var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );
	
					for ( var i = 0; i < formats.length; i ++ ) {
	
						array.push( formats[ i ] );
	
					}
	
				}
	
				return array;
	
			};
	
		} )();
	
		// clamp precision to maximum available
	
		var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
		var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;
	
		if ( _precision === 'highp' && ! highpAvailable ) {
	
			if ( mediumpAvailable ) {
	
				_precision = 'mediump';
				THREE.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );
	
			} else {
	
				_precision = 'lowp';
				THREE.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );
	
			}
	
		}
	
		if ( _precision === 'mediump' && ! mediumpAvailable ) {
	
			_precision = 'lowp';
			THREE.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );
	
		}
	
		// Plugins
	
		var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );
	
		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );
	
		// API
	
		this.getContext = function () {
	
			return _gl;
	
		};
	
		this.forceContextLoss = function () {
	
			extensions.get( 'WEBGL_lose_context' ).loseContext();
	
		};
	
		this.supportsVertexTextures = function () {
	
			return _supportsVertexTextures;
	
		};
	
		this.supportsFloatTextures = function () {
	
			return extensions.get( 'OES_texture_float' );
	
		};
	
		this.supportsHalfFloatTextures = function () {
	
			return extensions.get( 'OES_texture_half_float' );
	
		};
	
		this.supportsStandardDerivatives = function () {
	
			return extensions.get( 'OES_standard_derivatives' );
	
		};
	
		this.supportsCompressedTextureS3TC = function () {
	
			return extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
		};
	
		this.supportsCompressedTexturePVRTC = function () {
	
			return extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
		};
	
		this.supportsBlendMinMax = function () {
	
			return extensions.get( 'EXT_blend_minmax' );
	
		};
	
		this.getMaxAnisotropy = ( function () {
	
			var value;
	
			return function () {
	
				if ( value !== undefined ) {
	
					return value;
	
				}
	
				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;
	
				return value;
	
			}
	
		} )();
	
		this.getPrecision = function () {
	
			return _precision;
	
		};
	
		this.getPixelRatio = function () {
	
			return pixelRatio;
	
		};
	
		this.setPixelRatio = function ( value ) {
	
			pixelRatio = value;
	
		};
	
		this.setSize = function ( width, height, updateStyle ) {
	
			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;
	
			if ( updateStyle !== false ) {
	
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
	
			}
	
			this.setViewport( 0, 0, width, height );
	
		};
	
		this.setViewport = function ( x, y, width, height ) {
	
			_viewportX = x * pixelRatio;
			_viewportY = y * pixelRatio;
	
			_viewportWidth = width * pixelRatio;
			_viewportHeight = height * pixelRatio;
	
			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
	
		};
	
		this.setScissor = function ( x, y, width, height ) {
	
			_gl.scissor(
				x * pixelRatio,
				y * pixelRatio,
				width * pixelRatio,
				height * pixelRatio
			);
	
		};
	
		this.enableScissorTest = function ( enable ) {
	
			enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );
	
		};
	
		// Clearing
	
		this.getClearColor = function () {
	
			return _clearColor;
	
		};
	
		this.setClearColor = function ( color, alpha ) {
	
			_clearColor.set( color );
	
			_clearAlpha = alpha !== undefined ? alpha : 1;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.getClearAlpha = function () {
	
			return _clearAlpha;
	
		};
	
		this.setClearAlpha = function ( alpha ) {
	
			_clearAlpha = alpha;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.clear = function ( color, depth, stencil ) {
	
			var bits = 0;
	
			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
			_gl.clear( bits );
	
		};
	
		this.clearColor = function () {
	
			_gl.clear( _gl.COLOR_BUFFER_BIT );
	
		};
	
		this.clearDepth = function () {
	
			_gl.clear( _gl.DEPTH_BUFFER_BIT );
	
		};
	
		this.clearStencil = function () {
	
			_gl.clear( _gl.STENCIL_BUFFER_BIT );
	
		};
	
		this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );
	
		};
	
		// Reset
	
		this.resetGLState = resetGLState;
	
		// Buffer allocation
	
		function createParticleBuffers ( geometry ) {
	
			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
	
			_this.info.memory.geometries ++;
	
		};
	
		function createLineBuffers ( geometry ) {
	
			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
			geometry.__webglLineDistanceBuffer = _gl.createBuffer();
	
			_this.info.memory.geometries ++;
	
		};
	
		function createMeshBuffers ( geometryGroup ) {
	
			geometryGroup.__webglVertexBuffer = _gl.createBuffer();
			geometryGroup.__webglNormalBuffer = _gl.createBuffer();
			geometryGroup.__webglTangentBuffer = _gl.createBuffer();
			geometryGroup.__webglColorBuffer = _gl.createBuffer();
			geometryGroup.__webglUVBuffer = _gl.createBuffer();
			geometryGroup.__webglUV2Buffer = _gl.createBuffer();
	
			geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
			geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();
	
			geometryGroup.__webglFaceBuffer = _gl.createBuffer();
			geometryGroup.__webglLineBuffer = _gl.createBuffer();
	
			var numMorphTargets = geometryGroup.numMorphTargets;
	
			if ( numMorphTargets ) {
	
				geometryGroup.__webglMorphTargetsBuffers = [];
	
				for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {
	
					geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );
	
				}
	
			}
	
			var numMorphNormals = geometryGroup.numMorphNormals;
	
			if ( numMorphNormals ) {
	
				geometryGroup.__webglMorphNormalsBuffers = [];
	
				for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {
	
					geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );
	
				}
	
			}
	
			_this.info.memory.geometries ++;
	
		};
	
		// Events
	
		var onObjectRemoved = function ( event ) {
	
			var object = event.target;
	
			object.traverse( function ( child ) {
	
				child.removeEventListener( 'remove', onObjectRemoved );
	
				removeObject( child );
	
			} );
	
		};
	
		var onGeometryDispose = function ( event ) {
	
			var geometry = event.target;
	
			geometry.removeEventListener( 'dispose', onGeometryDispose );
	
			deallocateGeometry( geometry );
	
		};
	
		var onTextureDispose = function ( event ) {
	
			var texture = event.target;
	
			texture.removeEventListener( 'dispose', onTextureDispose );
	
			deallocateTexture( texture );
	
			_this.info.memory.textures --;
	
	
		};
	
		var onRenderTargetDispose = function ( event ) {
	
			var renderTarget = event.target;
	
			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
			deallocateRenderTarget( renderTarget );
	
			_this.info.memory.textures --;
	
		};
	
		var onMaterialDispose = function ( event ) {
	
			var material = event.target;
	
			material.removeEventListener( 'dispose', onMaterialDispose );
	
			deallocateMaterial( material );
	
		};
	
		// Buffer deallocation
	
		var deleteBuffers = function ( geometry ) {
	
			var buffers = [
				'__webglVertexBuffer',
				'__webglNormalBuffer',
				'__webglTangentBuffer',
				'__webglColorBuffer',
				'__webglUVBuffer',
				'__webglUV2Buffer',
	
				'__webglSkinIndicesBuffer',
				'__webglSkinWeightsBuffer',
	
				'__webglFaceBuffer',
				'__webglLineBuffer',
	
				'__webglLineDistanceBuffer'
			];
	
			for ( var i = 0, l = buffers.length; i < l; i ++ ) {
	
				var name = buffers[ i ];
	
				if ( geometry[ name ] !== undefined ) {
	
					_gl.deleteBuffer( geometry[ name ] );
	
					delete geometry[ name ];
	
				}
	
			}
	
			// custom attributes
	
			if ( geometry.__webglCustomAttributesList !== undefined ) {
	
				for ( var name in geometry.__webglCustomAttributesList ) {
	
					_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );
	
				}
	
				delete geometry.__webglCustomAttributesList;
	
			}
	
			_this.info.memory.geometries --;
	
		};
	
		var deallocateGeometry = function ( geometry ) {
	
			delete geometry.__webglInit;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				for ( var name in geometry.attributes ) {
	
					var attribute = geometry.attributes[ name ];
	
					if ( attribute.buffer !== undefined ) {
	
						_gl.deleteBuffer( attribute.buffer );
	
						delete attribute.buffer;
	
					}
	
				}
	
				_this.info.memory.geometries --;
	
			} else {
	
				var geometryGroupsList = geometryGroups[ geometry.id ];
	
				if ( geometryGroupsList !== undefined ) {
	
					for ( var i = 0, l = geometryGroupsList.length; i < l; i ++ ) {
	
						var geometryGroup = geometryGroupsList[ i ];
	
						if ( geometryGroup.numMorphTargets !== undefined ) {
	
							for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {
	
								_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );
	
							}
	
							delete geometryGroup.__webglMorphTargetsBuffers;
	
						}
	
						if ( geometryGroup.numMorphNormals !== undefined ) {
	
							for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {
	
								_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );
	
							}
	
							delete geometryGroup.__webglMorphNormalsBuffers;
	
						}
	
						deleteBuffers( geometryGroup );
	
					}
	
					delete geometryGroups[ geometry.id ];
	
				} else {
	
					deleteBuffers( geometry );
	
				}
	
			}
	
			// TOFIX: Workaround for deleted geometry being currently bound
	
			_currentGeometryProgram = '';
	
		};
	
		var deallocateTexture = function ( texture ) {
	
			if ( texture.image && texture.image.__webglTextureCube ) {
	
				// cube texture
	
				_gl.deleteTexture( texture.image.__webglTextureCube );
	
				delete texture.image.__webglTextureCube;
	
			} else {
	
				// 2D texture
	
				if ( texture.__webglInit === undefined ) return;
	
				_gl.deleteTexture( texture.__webglTexture );
	
				delete texture.__webglTexture;
				delete texture.__webglInit;
	
			}
	
		};
	
		var deallocateRenderTarget = function ( renderTarget ) {
	
			if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;
	
			_gl.deleteTexture( renderTarget.__webglTexture );
	
			delete renderTarget.__webglTexture;
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );
	
				}
	
			} else {
	
				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );
	
			}
	
			delete renderTarget.__webglFramebuffer;
			delete renderTarget.__webglRenderbuffer;
	
		};
	
		var deallocateMaterial = function ( material ) {
	
			var program = material.program.program;
	
			if ( program === undefined ) return;
	
			material.program = undefined;
	
			// only deallocate GL program if this was the last use of shared program
			// assumed there is only single copy of any program in the _programs list
			// (that's how it's constructed)
	
			var i, il, programInfo;
			var deleteProgram = false;
	
			for ( i = 0, il = _programs.length; i < il; i ++ ) {
	
				programInfo = _programs[ i ];
	
				if ( programInfo.program === program ) {
	
					programInfo.usedTimes --;
	
					if ( programInfo.usedTimes === 0 ) {
	
						deleteProgram = true;
	
					}
	
					break;
	
				}
	
			}
	
			if ( deleteProgram === true ) {
	
				// avoid using array.splice, this is costlier than creating new array from scratch
	
				var newPrograms = [];
	
				for ( i = 0, il = _programs.length; i < il; i ++ ) {
	
					programInfo = _programs[ i ];
	
					if ( programInfo.program !== program ) {
	
						newPrograms.push( programInfo );
	
					}
	
				}
	
				_programs = newPrograms;
	
				_gl.deleteProgram( program );
	
				_this.info.memory.programs --;
	
			}
	
		};
	
		// Buffer initialization
	
		function initCustomAttributes ( object ) {
	
			var geometry = object.geometry;
			var material = object.material;
	
			var nvertices = geometry.vertices.length;
	
			if ( material.attributes ) {
	
				if ( geometry.__webglCustomAttributesList === undefined ) {
	
					geometry.__webglCustomAttributesList = [];
	
				}
	
				for ( var name in material.attributes ) {
	
					var attribute = material.attributes[ name ];
	
					if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {
	
						attribute.__webglInitialized = true;
	
						var size = 1;   // "f" and "i"
	
						if ( attribute.type === 'v2' ) size = 2;
						else if ( attribute.type === 'v3' ) size = 3;
						else if ( attribute.type === 'v4' ) size = 4;
						else if ( attribute.type === 'c'  ) size = 3;
	
						attribute.size = size;
	
						attribute.array = new Float32Array( nvertices * size );
	
						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = name;
	
						attribute.needsUpdate = true;
	
					}
	
					geometry.__webglCustomAttributesList.push( attribute );
	
				}
	
			}
	
		};
	
		function initParticleBuffers ( geometry, object ) {
	
			var nvertices = geometry.vertices.length;
	
			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
	
			geometry.__webglParticleCount = nvertices;
	
			initCustomAttributes( object );
	
		};
	
		function initLineBuffers ( geometry, object ) {
	
			var nvertices = geometry.vertices.length;
	
			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
			geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );
	
			geometry.__webglLineCount = nvertices;
	
			initCustomAttributes( object );
	
		};
	
		function initMeshBuffers ( geometryGroup, object ) {
	
			var geometry = object.geometry,
				faces3 = geometryGroup.faces3,
	
				nvertices = faces3.length * 3,
				ntris     = faces3.length * 1,
				nlines    = faces3.length * 3,
	
				material = getBufferMaterial( object, geometryGroup );
	
			geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
			geometryGroup.__uvArray = new Float32Array( nvertices * 2 );
	
			if ( geometry.faceVertexUvs.length > 1 ) {
	
				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );
	
			}
	
			if ( geometry.hasTangents ) {
	
				geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );
	
			}
	
			if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {
	
				geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
				geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );
	
			}
	
			var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3
	
			geometryGroup.__typeArray = UintArray;
			geometryGroup.__faceArray = new UintArray( ntris * 3 );
			geometryGroup.__lineArray = new UintArray( nlines * 2 );
	
			var numMorphTargets = geometryGroup.numMorphTargets;
	
			if ( numMorphTargets ) {
	
				geometryGroup.__morphTargetsArrays = [];
	
				for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {
	
					geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );
	
				}
	
			}
	
			var numMorphNormals = geometryGroup.numMorphNormals;
	
			if ( numMorphNormals ) {
	
				geometryGroup.__morphNormalsArrays = [];
	
				for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {
	
					geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );
	
				}
	
			}
	
			geometryGroup.__webglFaceCount = ntris * 3;
			geometryGroup.__webglLineCount = nlines * 2;
	
	
			// custom attributes
	
			if ( material.attributes ) {
	
				if ( geometryGroup.__webglCustomAttributesList === undefined ) {
	
					geometryGroup.__webglCustomAttributesList = [];
	
				}
	
				for ( var name in material.attributes ) {
	
					// Do a shallow copy of the attribute object so different geometryGroup chunks use different
					// attribute buffers which are correctly indexed in the setMeshBuffers function
	
					var originalAttribute = material.attributes[ name ];
	
					var attribute = {};
	
					for ( var property in originalAttribute ) {
	
						attribute[ property ] = originalAttribute[ property ];
	
					}
	
					if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {
	
						attribute.__webglInitialized = true;
	
						var size = 1;   // "f" and "i"
	
						if ( attribute.type === 'v2' ) size = 2;
						else if ( attribute.type === 'v3' ) size = 3;
						else if ( attribute.type === 'v4' ) size = 4;
						else if ( attribute.type === 'c'  ) size = 3;
	
						attribute.size = size;
	
						attribute.array = new Float32Array( nvertices * size );
	
						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = name;
	
						originalAttribute.needsUpdate = true;
						attribute.__original = originalAttribute;
	
					}
	
					geometryGroup.__webglCustomAttributesList.push( attribute );
	
				}
	
			}
	
			geometryGroup.__inittedArrays = true;
	
		};
	
		function getBufferMaterial( object, geometryGroup ) {
	
			return object.material instanceof THREE.MeshFaceMaterial
				 ? object.material.materials[ geometryGroup.materialIndex ]
				 : object.material;
	
		}
	
		function materialNeedsFaceNormals ( material ) {
	
			return material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;
	
		}
	
		// Buffer setting
	
		function setParticleBuffers ( geometry, hint, object ) {
	
			var v, c, vertex, offset, color,
	
			vertices = geometry.vertices,
			vl = vertices.length,
	
			colors = geometry.colors,
			cl = colors.length,
	
			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
	
			customAttributes = geometry.__webglCustomAttributesList,
			i, il,
			ca, cal, value,
			customAttribute;
	
			if ( dirtyVertices ) {
	
				for ( v = 0; v < vl; v ++ ) {
	
					vertex = vertices[ v ];
	
					offset = v * 3;
	
					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyColors ) {
	
				for ( c = 0; c < cl; c ++ ) {
	
					color = colors[ c ];
	
					offset = c * 3;
	
					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined ||  customAttribute.boundTo === 'vertices' ) ) {
	
						cal = customAttribute.value.length;
	
						offset = 0;
	
						if ( customAttribute.size === 1 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								customAttribute.array[ ca ] = customAttribute.value[ ca ];
	
							}
	
						} else if ( customAttribute.size === 2 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
	
								offset += 2;
	
							}
	
						} else if ( customAttribute.size === 3 ) {
	
							if ( customAttribute.type === 'c' ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;
	
									offset += 3;
	
								}
	
							} else {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;
	
									offset += 3;
	
								}
	
							}
	
						} else if ( customAttribute.size === 4 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;
	
								offset += 4;
	
							}
	
						}
	
					}
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
					customAttribute.needsUpdate = false;
	
				}
	
			}
	
		}
	
		function setLineBuffers ( geometry, hint ) {
	
			var v, c, d, vertex, offset, color,
	
			vertices = geometry.vertices,
			colors = geometry.colors,
			lineDistances = geometry.lineDistances,
	
			vl = vertices.length,
			cl = colors.length,
			dl = lineDistances.length,
	
			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
			lineDistanceArray = geometry.__lineDistanceArray,
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyLineDistances = geometry.lineDistancesNeedUpdate,
	
			customAttributes = geometry.__webglCustomAttributesList,
	
			i, il,
			ca, cal, value,
			customAttribute;
	
			if ( dirtyVertices ) {
	
				for ( v = 0; v < vl; v ++ ) {
	
					vertex = vertices[ v ];
	
					offset = v * 3;
	
					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyColors ) {
	
				for ( c = 0; c < cl; c ++ ) {
	
					color = colors[ c ];
	
					offset = c * 3;
	
					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
			}
	
			if ( dirtyLineDistances ) {
	
				for ( d = 0; d < dl; d ++ ) {
	
					lineDistanceArray[ d ] = lineDistances[ d ];
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) {
	
						offset = 0;
	
						cal = customAttribute.value.length;
	
						if ( customAttribute.size === 1 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								customAttribute.array[ ca ] = customAttribute.value[ ca ];
	
							}
	
						} else if ( customAttribute.size === 2 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
	
								offset += 2;
	
							}
	
						} else if ( customAttribute.size === 3 ) {
	
							if ( customAttribute.type === 'c' ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;
	
									offset += 3;
	
								}
	
							} else {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;
	
									offset += 3;
	
								}
	
							}
	
						} else if ( customAttribute.size === 4 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ]    = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;
	
								offset += 4;
	
							}
	
						}
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
						customAttribute.needsUpdate = false;
	
					}
	
				}
	
			}
	
		}
	
		function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {
	
			if ( ! geometryGroup.__inittedArrays ) {
	
				return;
	
			}
	
			var needsFaceNormals = materialNeedsFaceNormals( material );
	
			var f, fl, fi, face,
			vertexNormals, faceNormal,
			vertexColors, faceColor,
			vertexTangents,
			uv, uv2, v1, v2, v3, t1, t2, t3, n1, n2, n3,
			c1, c2, c3,
			sw1, sw2, sw3,
			si1, si2, si3,
			i, il,
			vn, uvi, uv2i,
			vk, vkl, vka,
			nka, chf, faceVertexNormals,
	
			vertexIndex = 0,
	
			offset = 0,
			offset_uv = 0,
			offset_uv2 = 0,
			offset_face = 0,
			offset_normal = 0,
			offset_tangent = 0,
			offset_line = 0,
			offset_color = 0,
			offset_skin = 0,
			offset_morphTarget = 0,
			offset_custom = 0,
	
			value,
	
			vertexArray = geometryGroup.__vertexArray,
			uvArray = geometryGroup.__uvArray,
			uv2Array = geometryGroup.__uv2Array,
			normalArray = geometryGroup.__normalArray,
			tangentArray = geometryGroup.__tangentArray,
			colorArray = geometryGroup.__colorArray,
	
			skinIndexArray = geometryGroup.__skinIndexArray,
			skinWeightArray = geometryGroup.__skinWeightArray,
	
			morphTargetsArrays = geometryGroup.__morphTargetsArrays,
			morphNormalsArrays = geometryGroup.__morphNormalsArrays,
	
			customAttributes = geometryGroup.__webglCustomAttributesList,
			customAttribute,
	
			faceArray = geometryGroup.__faceArray,
			lineArray = geometryGroup.__lineArray,
	
			geometry = object.geometry, // this is shared for all chunks
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyElements = geometry.elementsNeedUpdate,
			dirtyUvs = geometry.uvsNeedUpdate,
			dirtyNormals = geometry.normalsNeedUpdate,
			dirtyTangents = geometry.tangentsNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyMorphTargets = geometry.morphTargetsNeedUpdate,
	
			vertices = geometry.vertices,
			chunk_faces3 = geometryGroup.faces3,
			obj_faces = geometry.faces,
	
			obj_uvs  = geometry.faceVertexUvs[ 0 ],
			obj_uvs2 = geometry.faceVertexUvs[ 1 ],
	
			obj_skinIndices = geometry.skinIndices,
			obj_skinWeights = geometry.skinWeights,
	
			morphTargets = geometry.morphTargets,
			morphNormals = geometry.morphNormals;
	
			if ( dirtyVertices ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ] ];
	
					v1 = vertices[ face.a ];
					v2 = vertices[ face.b ];
					v3 = vertices[ face.c ];
	
					vertexArray[ offset ]     = v1.x;
					vertexArray[ offset + 1 ] = v1.y;
					vertexArray[ offset + 2 ] = v1.z;
	
					vertexArray[ offset + 3 ] = v2.x;
					vertexArray[ offset + 4 ] = v2.y;
					vertexArray[ offset + 5 ] = v2.z;
	
					vertexArray[ offset + 6 ] = v3.x;
					vertexArray[ offset + 7 ] = v3.y;
					vertexArray[ offset + 8 ] = v3.z;
	
					offset += 9;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyMorphTargets ) {
	
				for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {
	
					offset_morphTarget = 0;
	
					for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
						chf = chunk_faces3[ f ];
						face = obj_faces[ chf ];
	
						// morph positions
	
						v1 = morphTargets[ vk ].vertices[ face.a ];
						v2 = morphTargets[ vk ].vertices[ face.b ];
						v3 = morphTargets[ vk ].vertices[ face.c ];
	
						vka = morphTargetsArrays[ vk ];
	
						vka[ offset_morphTarget ]     = v1.x;
						vka[ offset_morphTarget + 1 ] = v1.y;
						vka[ offset_morphTarget + 2 ] = v1.z;
	
						vka[ offset_morphTarget + 3 ] = v2.x;
						vka[ offset_morphTarget + 4 ] = v2.y;
						vka[ offset_morphTarget + 5 ] = v2.z;
	
						vka[ offset_morphTarget + 6 ] = v3.x;
						vka[ offset_morphTarget + 7 ] = v3.y;
						vka[ offset_morphTarget + 8 ] = v3.z;
	
						// morph normals
	
						if ( material.morphNormals ) {
	
							if ( needsFaceNormals ) {
	
								n1 = morphNormals[ vk ].faceNormals[ chf ];
								n2 = n1;
								n3 = n1;
	
							} else {
	
								faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];
	
								n1 = faceVertexNormals.a;
								n2 = faceVertexNormals.b;
								n3 = faceVertexNormals.c;
	
							}
	
							nka = morphNormalsArrays[ vk ];
	
							nka[ offset_morphTarget ]     = n1.x;
							nka[ offset_morphTarget + 1 ] = n1.y;
							nka[ offset_morphTarget + 2 ] = n1.z;
	
							nka[ offset_morphTarget + 3 ] = n2.x;
							nka[ offset_morphTarget + 4 ] = n2.y;
							nka[ offset_morphTarget + 5 ] = n2.z;
	
							nka[ offset_morphTarget + 6 ] = n3.x;
							nka[ offset_morphTarget + 7 ] = n3.y;
							nka[ offset_morphTarget + 8 ] = n3.z;
	
						}
	
						//
	
						offset_morphTarget += 9;
	
					}
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );
	
					if ( material.morphNormals ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
						_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );
	
					}
	
				}
	
			}
	
			if ( obj_skinWeights.length ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ] ];
	
					// weights
	
					sw1 = obj_skinWeights[ face.a ];
					sw2 = obj_skinWeights[ face.b ];
					sw3 = obj_skinWeights[ face.c ];
	
					skinWeightArray[ offset_skin ]     = sw1.x;
					skinWeightArray[ offset_skin + 1 ] = sw1.y;
					skinWeightArray[ offset_skin + 2 ] = sw1.z;
					skinWeightArray[ offset_skin + 3 ] = sw1.w;
	
					skinWeightArray[ offset_skin + 4 ] = sw2.x;
					skinWeightArray[ offset_skin + 5 ] = sw2.y;
					skinWeightArray[ offset_skin + 6 ] = sw2.z;
					skinWeightArray[ offset_skin + 7 ] = sw2.w;
	
					skinWeightArray[ offset_skin + 8 ]  = sw3.x;
					skinWeightArray[ offset_skin + 9 ]  = sw3.y;
					skinWeightArray[ offset_skin + 10 ] = sw3.z;
					skinWeightArray[ offset_skin + 11 ] = sw3.w;
	
					// indices
	
					si1 = obj_skinIndices[ face.a ];
					si2 = obj_skinIndices[ face.b ];
					si3 = obj_skinIndices[ face.c ];
	
					skinIndexArray[ offset_skin ]     = si1.x;
					skinIndexArray[ offset_skin + 1 ] = si1.y;
					skinIndexArray[ offset_skin + 2 ] = si1.z;
					skinIndexArray[ offset_skin + 3 ] = si1.w;
	
					skinIndexArray[ offset_skin + 4 ] = si2.x;
					skinIndexArray[ offset_skin + 5 ] = si2.y;
					skinIndexArray[ offset_skin + 6 ] = si2.z;
					skinIndexArray[ offset_skin + 7 ] = si2.w;
	
					skinIndexArray[ offset_skin + 8 ]  = si3.x;
					skinIndexArray[ offset_skin + 9 ]  = si3.y;
					skinIndexArray[ offset_skin + 10 ] = si3.z;
					skinIndexArray[ offset_skin + 11 ] = si3.w;
	
					offset_skin += 12;
	
				}
	
				if ( offset_skin > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );
	
				}
	
			}
	
			if ( dirtyColors ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ] ];
	
					vertexColors = face.vertexColors;
					faceColor = face.color;
	
					if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {
	
						c1 = vertexColors[ 0 ];
						c2 = vertexColors[ 1 ];
						c3 = vertexColors[ 2 ];
	
					} else {
	
						c1 = faceColor;
						c2 = faceColor;
						c3 = faceColor;
	
					}
	
					colorArray[ offset_color ]     = c1.r;
					colorArray[ offset_color + 1 ] = c1.g;
					colorArray[ offset_color + 2 ] = c1.b;
	
					colorArray[ offset_color + 3 ] = c2.r;
					colorArray[ offset_color + 4 ] = c2.g;
					colorArray[ offset_color + 5 ] = c2.b;
	
					colorArray[ offset_color + 6 ] = c3.r;
					colorArray[ offset_color + 7 ] = c3.g;
					colorArray[ offset_color + 8 ] = c3.b;
	
					offset_color += 9;
	
				}
	
				if ( offset_color > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
				}
	
			}
	
			if ( dirtyTangents && geometry.hasTangents ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ] ];
	
					vertexTangents = face.vertexTangents;
	
					t1 = vertexTangents[ 0 ];
					t2 = vertexTangents[ 1 ];
					t3 = vertexTangents[ 2 ];
	
					tangentArray[ offset_tangent ]     = t1.x;
					tangentArray[ offset_tangent + 1 ] = t1.y;
					tangentArray[ offset_tangent + 2 ] = t1.z;
					tangentArray[ offset_tangent + 3 ] = t1.w;
	
					tangentArray[ offset_tangent + 4 ] = t2.x;
					tangentArray[ offset_tangent + 5 ] = t2.y;
					tangentArray[ offset_tangent + 6 ] = t2.z;
					tangentArray[ offset_tangent + 7 ] = t2.w;
	
					tangentArray[ offset_tangent + 8 ]  = t3.x;
					tangentArray[ offset_tangent + 9 ]  = t3.y;
					tangentArray[ offset_tangent + 10 ] = t3.z;
					tangentArray[ offset_tangent + 11 ] = t3.w;
	
					offset_tangent += 12;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );
	
			}
	
			if ( dirtyNormals ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ] ];
	
					vertexNormals = face.vertexNormals;
					faceNormal = face.normal;
	
					if ( vertexNormals.length === 3 && needsFaceNormals === false ) {
	
						for ( i = 0; i < 3; i ++ ) {
	
							vn = vertexNormals[ i ];
	
							normalArray[ offset_normal ]     = vn.x;
							normalArray[ offset_normal + 1 ] = vn.y;
							normalArray[ offset_normal + 2 ] = vn.z;
	
							offset_normal += 3;
	
						}
	
					} else {
	
						for ( i = 0; i < 3; i ++ ) {
	
							normalArray[ offset_normal ]     = faceNormal.x;
							normalArray[ offset_normal + 1 ] = faceNormal.y;
							normalArray[ offset_normal + 2 ] = faceNormal.z;
	
							offset_normal += 3;
	
						}
	
					}
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );
	
			}
	
			if ( dirtyUvs && obj_uvs ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					fi = chunk_faces3[ f ];
	
					uv = obj_uvs[ fi ];
	
					if ( uv === undefined ) continue;
	
					for ( i = 0; i < 3; i ++ ) {
	
						uvi = uv[ i ];
	
						uvArray[ offset_uv ]     = uvi.x;
						uvArray[ offset_uv + 1 ] = uvi.y;
	
						offset_uv += 2;
	
					}
	
				}
	
				if ( offset_uv > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );
	
				}
	
			}
	
			if ( dirtyUvs && obj_uvs2 ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					fi = chunk_faces3[ f ];
	
					uv2 = obj_uvs2[ fi ];
	
					if ( uv2 === undefined ) continue;
	
					for ( i = 0; i < 3; i ++ ) {
	
						uv2i = uv2[ i ];
	
						uv2Array[ offset_uv2 ]     = uv2i.x;
						uv2Array[ offset_uv2 + 1 ] = uv2i.y;
	
						offset_uv2 += 2;
	
					}
	
				}
	
				if ( offset_uv2 > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );
	
				}
	
			}
	
			if ( dirtyElements ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					faceArray[ offset_face ]   = vertexIndex;
					faceArray[ offset_face + 1 ] = vertexIndex + 1;
					faceArray[ offset_face + 2 ] = vertexIndex + 2;
	
					offset_face += 3;
	
					lineArray[ offset_line ]     = vertexIndex;
					lineArray[ offset_line + 1 ] = vertexIndex + 1;
	
					lineArray[ offset_line + 2 ] = vertexIndex;
					lineArray[ offset_line + 3 ] = vertexIndex + 2;
	
					lineArray[ offset_line + 4 ] = vertexIndex + 1;
					lineArray[ offset_line + 5 ] = vertexIndex + 2;
	
					offset_line += 6;
	
					vertexIndex += 3;
	
				}
	
				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );
	
				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( ! customAttribute.__original.needsUpdate ) continue;
	
					offset_custom = 0;
	
					if ( customAttribute.size === 1 ) {
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ] ];
	
								customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];
								customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
								customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];
	
								offset_custom += 3;
	
							}
	
						} else if ( customAttribute.boundTo === 'faces' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								customAttribute.array[ offset_custom ]     = value;
								customAttribute.array[ offset_custom + 1 ] = value;
								customAttribute.array[ offset_custom + 2 ] = value;
	
								offset_custom += 3;
	
							}
	
						}
	
					} else if ( customAttribute.size === 2 ) {
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ] ];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
	
								customAttribute.array[ offset_custom ]     = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;
	
								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;
	
								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;
	
								offset_custom += 6;
	
							}
	
						} else if ( customAttribute.boundTo === 'faces' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
	
								customAttribute.array[ offset_custom ]     = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;
	
								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;
	
								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;
	
								offset_custom += 6;
	
							}
	
						}
	
					} else if ( customAttribute.size === 3 ) {
	
						var pp;
	
						if ( customAttribute.type === 'c' ) {
	
							pp = [ 'r', 'g', 'b' ];
	
						} else {
	
							pp = [ 'x', 'y', 'z' ];
	
						}
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ] ];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
	
								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];
	
								offset_custom += 9;
	
							}
	
						} else if ( customAttribute.boundTo === 'faces' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
	
								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];
	
								offset_custom += 9;
	
							}
	
						} else if ( customAttribute.boundTo === 'faceVertices' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];
	
								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];
	
								offset_custom += 9;
	
							}
	
						}
	
					} else if ( customAttribute.size === 4 ) {
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ] ];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
	
								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								offset_custom += 12;
	
							}
	
						} else if ( customAttribute.boundTo === 'faces' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
	
								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								offset_custom += 12;
	
							}
	
						} else if ( customAttribute.boundTo === 'faceVertices' ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];
	
								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								offset_custom += 12;
	
							}
	
						}
	
					}
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
				}
	
			}
	
			if ( dispose ) {
	
				delete geometryGroup.__inittedArrays;
				delete geometryGroup.__colorArray;
				delete geometryGroup.__normalArray;
				delete geometryGroup.__tangentArray;
				delete geometryGroup.__uvArray;
				delete geometryGroup.__uv2Array;
				delete geometryGroup.__faceArray;
				delete geometryGroup.__vertexArray;
				delete geometryGroup.__lineArray;
				delete geometryGroup.__skinIndexArray;
				delete geometryGroup.__skinWeightArray;
	
			}
	
		};
	
		// Buffer rendering
	
		this.renderBufferImmediate = function ( object, program, material ) {
	
			state.initAttributes();
	
			if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
			if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
			if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
			if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();
	
			if ( object.hasPositions ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( program.attributes.position );
	
				_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasNormals ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );
	
				if ( material instanceof THREE.MeshPhongMaterial === false &&
					   material.shading === THREE.FlatShading ) {
	
					var nx, ny, nz,
						nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
						normalArray,
						i, il = object.count * 3;
	
					for ( i = 0; i < il; i += 9 ) {
	
						normalArray = object.normalArray;
	
						nax  = normalArray[ i ];
						nay  = normalArray[ i + 1 ];
						naz  = normalArray[ i + 2 ];
	
						nbx  = normalArray[ i + 3 ];
						nby  = normalArray[ i + 4 ];
						nbz  = normalArray[ i + 5 ];
	
						ncx  = normalArray[ i + 6 ];
						ncy  = normalArray[ i + 7 ];
						ncz  = normalArray[ i + 8 ];
	
						nx = ( nax + nbx + ncx ) / 3;
						ny = ( nay + nby + ncy ) / 3;
						nz = ( naz + nbz + ncz ) / 3;
	
						normalArray[ i ]   = nx;
						normalArray[ i + 1 ] = ny;
						normalArray[ i + 2 ] = nz;
	
						normalArray[ i + 3 ] = nx;
						normalArray[ i + 4 ] = ny;
						normalArray[ i + 5 ] = nz;
	
						normalArray[ i + 6 ] = nx;
						normalArray[ i + 7 ] = ny;
						normalArray[ i + 8 ] = nz;
	
					}
	
				}
	
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( program.attributes.normal );
	
				_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasUvs && material.map ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( program.attributes.uv );
	
				_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( program.attributes.color );
	
				_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			state.disableUnusedAttributes();
	
			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
			object.count = 0;
	
		};
	
		function setupVertexAttributes( material, program, geometry, startIndex ) {
	
			var geometryAttributes = geometry.attributes;
	
			var programAttributes = program.attributes;
			var programAttributesKeys = program.attributesKeys;
	
			for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {
	
				var key = programAttributesKeys[ i ];
				var programAttribute = programAttributes[ key ];
	
				if ( programAttribute >= 0 ) {
	
					var geometryAttribute = geometryAttributes[ key ];
	
					if ( geometryAttribute !== undefined ) {
	
						var size = geometryAttribute.itemSize;
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );
	
						state.enableAttribute( programAttribute );
	
						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32
	
					} else if ( material.defaultAttributeValues !== undefined ) {
	
						if ( material.defaultAttributeValues[ key ].length === 2 ) {
	
							_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );
	
						} else if ( material.defaultAttributeValues[ key ].length === 3 ) {
	
							_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );
	
						}
	
					}
	
				}
	
			}
	
			state.disableUnusedAttributes();
	
		}
	
		this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {
	
			if ( material.visible === false ) return;
	
			updateObject( object );
	
			var program = setProgram( camera, lights, fog, material, object );
	
			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;
	
			if ( geometryProgram !== _currentGeometryProgram ) {
	
				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;
	
			}
	
			if ( updateBuffers ) {
	
				state.initAttributes();
	
			}
	
			// render mesh
	
			if ( object instanceof THREE.Mesh ) {
	
				var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;
	
				var index = geometry.attributes.index;
	
				if ( index ) {
	
					// indexed triangles
	
					var type, size;
	
					if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {
	
						type = _gl.UNSIGNED_INT;
						size = 4;
	
					} else {
	
						type = _gl.UNSIGNED_SHORT;
						size = 2;
	
					}
	
					var offsets = geometry.offsets;
	
					if ( offsets.length === 0 ) {
	
						if ( updateBuffers ) {
	
							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
	
						}
	
						_gl.drawElements( mode, index.array.length, type, 0 );
	
						_this.info.render.calls ++;
						_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
						_this.info.render.faces += index.array.length / 3;
	
					} else {
	
						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change
	
						updateBuffers = true;
	
						for ( var i = 0, il = offsets.length; i < il; i ++ ) {
	
							var startIndex = offsets[ i ].index;
	
							if ( updateBuffers ) {
	
								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
	
							}
	
							// render indexed triangles
	
							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );
	
							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
							_this.info.render.faces += offsets[ i ].count / 3;
	
						}
	
					}
	
				} else {
	
					// non-indexed triangles
	
					if ( updateBuffers ) {
	
						setupVertexAttributes( material, program, geometry, 0 );
	
					}
	
					var position = geometry.attributes[ 'position' ];
	
					// render non-indexed triangles
	
					_gl.drawArrays( mode, 0, position.array.length / position.itemSize );
	
					_this.info.render.calls ++;
					_this.info.render.vertices += position.array.length / position.itemSize;
					_this.info.render.faces += position.array.length / ( 3 * position.itemSize );
	
				}
	
			} else if ( object instanceof THREE.PointCloud ) {
	
				// render particles
	
				var mode = _gl.POINTS;
	
				var index = geometry.attributes.index;
	
				if ( index ) {
	
					// indexed points
	
					var type, size;
	
					if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {
	
						type = _gl.UNSIGNED_INT;
						size = 4;
	
					} else {
	
						type = _gl.UNSIGNED_SHORT;
						size = 2;
	
					}
	
					var offsets = geometry.offsets;
	
					if ( offsets.length === 0 ) {
	
						if ( updateBuffers ) {
	
							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
	
						}
	
						_gl.drawElements( mode, index.array.length, type, 0);
	
						_this.info.render.calls ++;
						_this.info.render.points += index.array.length;
	
					} else {
	
						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change
	
						if ( offsets.length > 1 ) updateBuffers = true;
	
						for ( var i = 0, il = offsets.length; i < il; i ++ ) {
	
							var startIndex = offsets[ i ].index;
	
							if ( updateBuffers ) {
	
								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
	
							}
	
							// render indexed points
	
							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );
	
							_this.info.render.calls ++;
							_this.info.render.points += offsets[ i ].count;
	
						}
	
					}
	
				} else {
	
					// non-indexed points
	
					if ( updateBuffers ) {
	
						setupVertexAttributes( material, program, geometry, 0 );
	
					}
	
					var position = geometry.attributes.position;
					var offsets = geometry.offsets;
	
					if ( offsets.length === 0 ) {
	
						_gl.drawArrays( mode, 0, position.array.length / 3 );
	
						_this.info.render.calls ++;
						_this.info.render.points += position.array.length / 3;
	
					} else {
	
						for ( var i = 0, il = offsets.length; i < il; i ++ ) {
	
							_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );
	
							_this.info.render.calls ++;
							_this.info.render.points += offsets[ i ].count;
	
						}
	
					}
	
				}
	
			} else if ( object instanceof THREE.Line ) {
	
				var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;
	
				state.setLineWidth( material.linewidth * pixelRatio );
	
				var index = geometry.attributes.index;
	
				if ( index ) {
	
					// indexed lines
	
					var type, size;
	
					if ( index.array instanceof Uint32Array ) {
	
						type = _gl.UNSIGNED_INT;
						size = 4;
	
					} else {
	
						type = _gl.UNSIGNED_SHORT;
						size = 2;
	
					}
	
					var offsets = geometry.offsets;
	
					if ( offsets.length === 0 ) {
	
						if ( updateBuffers ) {
	
							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
	
						}
	
						_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array
	
						_this.info.render.calls ++;
						_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
	
					} else {
	
						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change
	
						if ( offsets.length > 1 ) updateBuffers = true;
	
						for ( var i = 0, il = offsets.length; i < il; i ++ ) {
	
							var startIndex = offsets[ i ].index;
	
							if ( updateBuffers ) {
	
								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
	
							}
	
							// render indexed lines
	
							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array
	
							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
	
						}
	
					}
	
				} else {
	
					// non-indexed lines
	
					if ( updateBuffers ) {
	
						setupVertexAttributes( material, program, geometry, 0 );
	
					}
	
					var position = geometry.attributes.position;
					var offsets = geometry.offsets;
	
					if ( offsets.length === 0 ) {
	
						_gl.drawArrays( mode, 0, position.array.length / 3 );
	
						_this.info.render.calls ++;
						_this.info.render.vertices += position.array.length / 3;
	
					} else {
	
						for ( var i = 0, il = offsets.length; i < il; i ++ ) {
	
							_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );
	
							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count;
	
						}
	
					}
	
				}
	
			}
	
		};
	
		this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {
	
			if ( material.visible === false ) return;
	
			updateObject( object );
	
			var program = setProgram( camera, lights, fog, material, object );
	
			var attributes = program.attributes;
	
			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;
	
			if ( geometryProgram !== _currentGeometryProgram ) {
	
				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;
	
			}
	
			if ( updateBuffers ) {
	
				state.initAttributes();
	
			}
	
			// vertices
	
			if ( ! material.morphTargets && attributes.position >= 0 ) {
	
				if ( updateBuffers ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
	
					state.enableAttribute( attributes.position );
	
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
			} else {
	
				if ( object.morphTargetBase ) {
	
					setupMorphTargets( material, geometryGroup, object );
	
				}
	
			}
	
	
			if ( updateBuffers ) {
	
				// custom attributes
	
				// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers
	
				if ( geometryGroup.__webglCustomAttributesList ) {
	
					for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {
	
						var attribute = geometryGroup.__webglCustomAttributesList[ i ];
	
						if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
	
							state.enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
	
							_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );
	
						}
	
					}
	
				}
	
	
				// colors
	
				if ( attributes.color >= 0 ) {
	
					if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
	
						state.enableAttribute( attributes.color );
	
						_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
					} else if ( material.defaultAttributeValues !== undefined ) {
	
	
						_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );
	
					}
	
				}
	
				// normals
	
				if ( attributes.normal >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
	
					state.enableAttribute( attributes.normal );
	
					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// tangents
	
				if ( attributes.tangent >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
	
					state.enableAttribute( attributes.tangent );
	
					_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// uvs
	
				if ( attributes.uv >= 0 ) {
	
					if ( object.geometry.faceVertexUvs[ 0 ] ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
	
						state.enableAttribute( attributes.uv );
	
						_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
					} else if ( material.defaultAttributeValues !== undefined ) {
	
	
						_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );
	
					}
	
				}
	
				if ( attributes.uv2 >= 0 ) {
	
					if ( object.geometry.faceVertexUvs[ 1 ] ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
	
						state.enableAttribute( attributes.uv2 );
	
						_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );
	
					} else if ( material.defaultAttributeValues !== undefined ) {
	
	
						_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );
	
					}
	
				}
	
				if ( material.skinning &&
					 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
	
					state.enableAttribute( attributes.skinIndex );
	
					_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
	
					state.enableAttribute( attributes.skinWeight );
	
					_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// line distances
	
				if ( attributes.lineDistance >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
	
					state.enableAttribute( attributes.lineDistance );
	
					_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );
	
				}
	
			}
	
			state.disableUnusedAttributes();
	
			// render mesh
	
			if ( object instanceof THREE.Mesh ) {
	
				var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;
	
				// wireframe
	
				if ( material.wireframe ) {
	
					state.setLineWidth( material.wireframeLinewidth * pixelRatio );
	
					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
					_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );
	
				// triangles
	
				} else {
	
					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
					_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );
	
				}
	
				_this.info.render.calls ++;
				_this.info.render.vertices += geometryGroup.__webglFaceCount;
				_this.info.render.faces += geometryGroup.__webglFaceCount / 3;
	
			// render lines
	
			} else if ( object instanceof THREE.Line ) {
	
				var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;
	
				state.setLineWidth( material.linewidth * pixelRatio );
	
				_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );
	
				_this.info.render.calls ++;
	
			// render particles
	
			} else if ( object instanceof THREE.PointCloud ) {
	
				_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );
	
				_this.info.render.calls ++;
				_this.info.render.points += geometryGroup.__webglParticleCount;
	
			}
	
		};
	
		function setupMorphTargets ( material, geometryGroup, object ) {
	
			// set base
	
			var attributes = material.program.attributes;
	
			if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
	
				state.enableAttribute( attributes.position );
	
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			} else if ( attributes.position >= 0 ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
	
				state.enableAttribute( attributes.position );
	
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.morphTargetForcedOrder.length ) {
	
				// set forced order
	
				var m = 0;
				var order = object.morphTargetForcedOrder;
				var influences = object.morphTargetInfluences;
	
				var attribute;
	
				while ( m < material.numSupportedMorphTargets && m < order.length ) {
	
					attribute = attributes[ 'morphTarget' + m ];
	
					if ( attribute >= 0 ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
	
						state.enableAttribute( attribute );
	
						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );
	
					}
	
					attribute = attributes[ 'morphNormal' + m ];
	
					if ( attribute >= 0 && material.morphNormals ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
	
						state.enableAttribute( attribute );
	
						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );
	
					}
	
					object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];
	
					m ++;
	
				}
	
			} else {
	
				// find the most influencing
	
				var activeInfluenceIndices = [];
				var influences = object.morphTargetInfluences;
				var morphTargets = object.geometry.morphTargets;
	
				if ( influences.length > morphTargets.length ) {
	
					console.warn( 'THREE.WebGLRenderer: Influences array is bigger than morphTargets array.' );
					influences.length = morphTargets.length;
	
				}
	
				for ( var i = 0, il = influences.length; i < il; i ++ ) {
	
					var influence = influences[ i ];
	
					activeInfluenceIndices.push( [ influence, i ] );
	
				}
	
				if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {
	
					activeInfluenceIndices.sort( numericalSort );
					activeInfluenceIndices.length = material.numSupportedMorphTargets;
	
				} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {
	
					activeInfluenceIndices.sort( numericalSort );
	
				} else if ( activeInfluenceIndices.length === 0 ) {
	
					activeInfluenceIndices.push( [ 0, 0 ] );
	
				}
	
				var attribute;
	
				for ( var m = 0, ml = material.numSupportedMorphTargets; m < ml; m ++ ) {
	
					if ( activeInfluenceIndices[ m ] ) {
	
						var influenceIndex = activeInfluenceIndices[ m ][ 1 ];
	
						attribute = attributes[ 'morphTarget' + m ];
	
						if ( attribute >= 0 ) {
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
	
							state.enableAttribute( attribute );
	
							_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );
	
						}
	
						attribute = attributes[ 'morphNormal' + m ];
	
						if ( attribute >= 0 && material.morphNormals ) {
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
	
							state.enableAttribute( attribute );
	
							_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );
	
						}
	
						object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];
	
					} else {
	
						/*
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
						if ( material.morphNormals ) {
	
							_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
						}
						*/
	
						object.__webglMorphTargetInfluences[ m ] = 0;
	
					}
	
				}
	
			}
	
			// load updated influences uniform
	
			if ( material.program.uniforms.morphTargetInfluences !== null ) {
	
				_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );
	
			}
	
		}
	
		// Sorting
	
		function painterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} else if ( a.material.id !== b.material.id ) {
	
				return a.material.id - b.material.id;
	
			} else if ( a.z !== b.z ) {
	
				return a.z - b.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		function reversePainterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		function numericalSort ( a, b ) {
	
			return b[ 0 ] - a[ 0 ];
	
		}
	
		// Rendering
	
		this.render = function ( scene, camera, renderTarget, forceClear ) {
	
			if ( camera instanceof THREE.Camera === false ) {
	
				THREE.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			var fog = scene.fog;
	
			// reset caching for this frame
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
			_lightsNeedUpdate = true;
	
			// update scene graph
	
			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			if ( camera.parent === undefined ) camera.updateMatrixWorld();
	
			// update Skeleton objects
	
			scene.traverse( function ( object ) {
	
				if ( object instanceof THREE.SkinnedMesh ) {
	
					object.skeleton.update();
	
				}
	
			} );
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			lights.length = 0;
			opaqueObjects.length = 0;
			transparentObjects.length = 0;
	
			sprites.length = 0;
			lensFlares.length = 0;
	
			projectObject( scene );
	
			if ( _this.sortObjects === true ) {
	
				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );
	
			}
	
			// custom render plugins (pre pass)
	
			shadowMapPlugin.render( scene, camera );
	
			//
	
			_this.info.render.calls = 0;
			_this.info.render.vertices = 0;
			_this.info.render.faces = 0;
			_this.info.render.points = 0;
	
			this.setRenderTarget( renderTarget );
	
			if ( this.autoClear || forceClear ) {
	
				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
			}
	
			// set matrices for immediate objects
	
			for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {
	
				var webglObject = _webglObjectsImmediate[ i ];
				var object = webglObject.object;
	
				if ( object.visible ) {
	
					setupMatrices( object, camera );
	
					unrollImmediateBufferMaterial( webglObject );
	
				}
	
			}
	
			if ( scene.overrideMaterial ) {
	
				var overrideMaterial = scene.overrideMaterial;
	
				setMaterial( overrideMaterial );
	
				renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );
				renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, overrideMaterial );
	
			} else {
	
				// opaque pass (front-to-back order)
	
				state.setBlending( THREE.NoBlending );
	
				renderObjects( opaqueObjects, camera, lights, fog, null );
				renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, null );
	
				// transparent pass (back-to-front order)
	
				renderObjects( transparentObjects, camera, lights, fog, null );
				renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, null );
	
			}
	
			// custom render plugins (post pass)
	
			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );
	
			// Generate mipmap if we're using any kind of mipmap filtering
	
			if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {
	
				updateRenderTargetMipmap( renderTarget );
	
			}
	
			// Ensure depth buffer writing is enabled so it can be cleared on next render
	
			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );
	
			// _gl.finish();
	
		};
	
		function projectObject( object ) {
	
			if ( object.visible === false ) return;
	
			if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {
	
				// skip
	
			} else {
	
				initObject( object );
	
				if ( object instanceof THREE.Light ) {
	
					lights.push( object );
	
				} else if ( object instanceof THREE.Sprite ) {
	
					sprites.push( object );
	
				} else if ( object instanceof THREE.LensFlare ) {
	
					lensFlares.push( object );
	
				} else {
	
					var webglObjects = _webglObjects[ object.id ];
	
					if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {
	
						for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {
	
							var webglObject = webglObjects[ i ];
	
							unrollBufferMaterial( webglObject );
	
							webglObject.render = true;
	
							if ( _this.sortObjects === true ) {
	
								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );
	
								webglObject.z = _vector3.z;
	
							}
	
						}
	
					}
	
				}
	
			}
	
			for ( var i = 0, l = object.children.length; i < l; i ++ ) {
	
				projectObject( object.children[ i ] );
	
			}
	
		}
	
		function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {
	
			var material;
	
			for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
				var webglObject = renderList[ i ];
	
				var object = webglObject.object;
				var buffer = webglObject.buffer;
	
				setupMatrices( object, camera );
	
				if ( overrideMaterial ) {
	
					material = overrideMaterial;
	
				} else {
	
					material = webglObject.material;
	
					if ( ! material ) continue;
	
					setMaterial( material );
	
				}
	
				_this.setMaterialFaces( material );
	
				if ( buffer instanceof THREE.BufferGeometry ) {
	
					_this.renderBufferDirect( camera, lights, fog, material, buffer, object );
	
				} else {
	
					_this.renderBuffer( camera, lights, fog, material, buffer, object );
	
				}
	
			}
	
		}
	
		function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {
	
			var material;
	
			for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
				var webglObject = renderList[ i ];
				var object = webglObject.object;
	
				if ( object.visible ) {
	
					if ( overrideMaterial ) {
	
						material = overrideMaterial;
	
					} else {
	
						material = webglObject[ materialType ];
	
						if ( ! material ) continue;
	
						setMaterial( material );
	
					}
	
					_this.renderImmediateObject( camera, lights, fog, material, object );
	
				}
	
			}
	
		}
	
		this.renderImmediateObject = function ( camera, lights, fog, material, object ) {
	
			var program = setProgram( camera, lights, fog, material, object );
	
			_currentGeometryProgram = '';
	
			_this.setMaterialFaces( material );
	
			if ( object.immediateRenderCallback ) {
	
				object.immediateRenderCallback( program, _gl, _frustum );
	
			} else {
	
				object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );
	
			}
	
		};
	
		function unrollImmediateBufferMaterial ( globject ) {
	
			var object = globject.object,
				material = object.material;
	
			if ( material.transparent ) {
	
				globject.transparent = material;
				globject.opaque = null;
	
			} else {
	
				globject.opaque = material;
				globject.transparent = null;
	
			}
	
		}
	
		function unrollBufferMaterial ( globject ) {
	
			var object = globject.object;
			var buffer = globject.buffer;
	
			var geometry = object.geometry;
			var material = object.material;
	
			if ( material instanceof THREE.MeshFaceMaterial ) {
	
				var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;
	
				material = material.materials[ materialIndex ];
	
				globject.material = material;
	
				if ( material.transparent ) {
	
					transparentObjects.push( globject );
	
				} else {
	
					opaqueObjects.push( globject );
	
				}
	
			} else if ( material ) {
	
				globject.material = material;
	
				if ( material.transparent ) {
	
					transparentObjects.push( globject );
	
				} else {
	
					opaqueObjects.push( globject );
	
				}
	
			}
	
		}
	
		function initObject( object ) {
	
			if ( object.__webglInit === undefined ) {
	
				object.__webglInit = true;
				object._modelViewMatrix = new THREE.Matrix4();
				object._normalMatrix = new THREE.Matrix3();
	
				object.addEventListener( 'removed', onObjectRemoved );
	
			}
	
			var geometry = object.geometry;
	
			if ( geometry === undefined ) {
	
				// ImmediateRenderObject
	
			} else if ( geometry.__webglInit === undefined ) {
	
				geometry.__webglInit = true;
				geometry.addEventListener( 'dispose', onGeometryDispose );
	
				if ( geometry instanceof THREE.BufferGeometry ) {
	
					_this.info.memory.geometries ++;
	
				} else if ( object instanceof THREE.Mesh ) {
	
					initGeometryGroups( object, geometry );
	
				} else if ( object instanceof THREE.Line ) {
	
					if ( geometry.__webglVertexBuffer === undefined ) {
	
						createLineBuffers( geometry );
						initLineBuffers( geometry, object );
	
						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;
						geometry.lineDistancesNeedUpdate = true;
	
					}
	
				} else if ( object instanceof THREE.PointCloud ) {
	
					if ( geometry.__webglVertexBuffer === undefined ) {
	
						createParticleBuffers( geometry );
						initParticleBuffers( geometry, object );
	
						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;
	
					}
	
				}
	
			}
	
			if ( object.__webglActive === undefined) {
	
				object.__webglActive = true;
	
				if ( object instanceof THREE.Mesh ) {
	
					if ( geometry instanceof THREE.BufferGeometry ) {
	
						addBuffer( _webglObjects, geometry, object );
	
					} else if ( geometry instanceof THREE.Geometry ) {
	
						var geometryGroupsList = geometryGroups[ geometry.id ];
	
						for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {
	
							addBuffer( _webglObjects, geometryGroupsList[ i ], object );
	
						}
	
					}
	
				} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {
	
					addBuffer( _webglObjects, geometry, object );
	
				} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {
	
					addBufferImmediate( _webglObjectsImmediate, object );
	
				}
	
			}
	
		}
	
		// Geometry splitting
	
		var geometryGroups = {};
		var geometryGroupCounter = 0;
	
		function makeGroups( geometry, usesFaceMaterial ) {
	
			var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;
	
			var groupHash, hash_map = {};
	
			var numMorphTargets = geometry.morphTargets.length;
			var numMorphNormals = geometry.morphNormals.length;
	
			var group;
			var groups = {};
			var groupsList = [];
	
			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {
	
				var face = geometry.faces[ f ];
				var materialIndex = usesFaceMaterial ? face.materialIndex : 0;
	
				if ( ! ( materialIndex in hash_map ) ) {
	
					hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };
	
				}
	
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;
	
				if ( ! ( groupHash in groups ) ) {
	
					group = {
						id: geometryGroupCounter ++,
						faces3: [],
						materialIndex: materialIndex,
						vertices: 0,
						numMorphTargets: numMorphTargets,
						numMorphNormals: numMorphNormals
					};
	
					groups[ groupHash ] = group;
					groupsList.push( group );
	
				}
	
				if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {
	
					hash_map[ materialIndex ].counter += 1;
					groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;
	
					if ( ! ( groupHash in groups ) ) {
	
						group = {
							id: geometryGroupCounter ++,
							faces3: [],
							materialIndex: materialIndex,
							vertices: 0,
							numMorphTargets: numMorphTargets,
							numMorphNormals: numMorphNormals
						};
	
						groups[ groupHash ] = group;
						groupsList.push( group );
	
					}
	
				}
	
				groups[ groupHash ].faces3.push( f );
				groups[ groupHash ].vertices += 3;
	
			}
	
			return groupsList;
	
		}
	
		function initGeometryGroups( object, geometry ) {
	
			var material = object.material, addBuffers = false;
	
			if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {
	
				delete _webglObjects[ object.id ];
	
				geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );
	
				geometry.groupsNeedUpdate = false;
	
			}
	
			var geometryGroupsList = geometryGroups[ geometry.id ];
	
			// create separate VBOs per geometry chunk
	
			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {
	
				var geometryGroup = geometryGroupsList[ i ];
	
				// initialise VBO on the first access
	
				if ( geometryGroup.__webglVertexBuffer === undefined ) {
	
					createMeshBuffers( geometryGroup );
					initMeshBuffers( geometryGroup, object );
	
					geometry.verticesNeedUpdate = true;
					geometry.morphTargetsNeedUpdate = true;
					geometry.elementsNeedUpdate = true;
					geometry.uvsNeedUpdate = true;
					geometry.normalsNeedUpdate = true;
					geometry.tangentsNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
	
					addBuffers = true;
	
				} else {
	
					addBuffers = false;
	
				}
	
				if ( addBuffers || object.__webglActive === undefined ) {
	
					addBuffer( _webglObjects, geometryGroup, object );
	
				}
	
			}
	
			object.__webglActive = true;
	
		}
	
		function addBuffer( objlist, buffer, object ) {
	
			var id = object.id;
			objlist[id] = objlist[id] || [];
			objlist[id].push(
				{
					id: id,
					buffer: buffer,
					object: object,
					material: null,
					z: 0
				}
			);
	
		};
	
		function addBufferImmediate( objlist, object ) {
	
			objlist.push(
				{
					id: null,
					object: object,
					opaque: null,
					transparent: null,
					z: 0
				}
			);
	
		};
	
		// Objects updates
	
		function updateObject( object ) {
	
			var geometry = object.geometry;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var attributes = geometry.attributes;
				var attributesKeys = geometry.attributesKeys;
	
				for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {
	
					var key = attributesKeys[ i ];
					var attribute = attributes[ key ];
					var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;
	
					if ( attribute.buffer === undefined ) {
	
						attribute.buffer = _gl.createBuffer();
						_gl.bindBuffer( bufferType, attribute.buffer );
						_gl.bufferData( bufferType, attribute.array, ( attribute instanceof THREE.DynamicBufferAttribute ) ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW );
	
						attribute.needsUpdate = false;
	
					} else if ( attribute.needsUpdate === true ) {
	
						_gl.bindBuffer( bufferType, attribute.buffer );
	
						if ( attribute.updateRange === undefined || attribute.updateRange.count === -1 ) { // Not using update ranges
	
							_gl.bufferSubData( bufferType, 0, attribute.array );
	
						} else if ( attribute.updateRange.count === 0 ) {
	
							console.error( 'THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );
	
						} else {
	
							_gl.bufferSubData( bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT,
											   attribute.array.subarray( attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count ) );
	
							attribute.updateRange.count = 0; // reset range
	
						}
	
						attribute.needsUpdate = false;
	
					}
	
				}
	
			} else if ( object instanceof THREE.Mesh ) {
	
				// check all geometry groups
	
				if ( geometry.groupsNeedUpdate === true ) {
	
					initGeometryGroups( object, geometry );
	
				}
	
				var geometryGroupsList = geometryGroups[ geometry.id ];
	
				for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {
	
					var geometryGroup = geometryGroupsList[ i ];
					var material = getBufferMaterial( object, geometryGroup );
	
					var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
					if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {
	
						setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );
	
					}
	
				}
	
				geometry.verticesNeedUpdate = false;
				geometry.morphTargetsNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;
	
				material.attributes && clearCustomAttributes( material );
	
			} else if ( object instanceof THREE.Line ) {
	
				var material = getBufferMaterial( object, geometry );
				var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {
	
					setLineBuffers( geometry, _gl.DYNAMIC_DRAW );
	
				}
	
				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.lineDistancesNeedUpdate = false;
	
				material.attributes && clearCustomAttributes( material );
	
			} else if ( object instanceof THREE.PointCloud ) {
	
				var material = getBufferMaterial( object, geometry );
				var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty ) {
	
					setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );
	
				}
	
				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
	
				material.attributes && clearCustomAttributes( material );
	
			}
	
		}
	
		// Objects updates - custom attributes check
	
		function areCustomAttributesDirty( material ) {
	
			for ( var name in material.attributes ) {
	
				if ( material.attributes[ name ].needsUpdate ) return true;
	
			}
	
			return false;
	
		}
	
		function clearCustomAttributes( material ) {
	
			for ( var name in material.attributes ) {
	
				material.attributes[ name ].needsUpdate = false;
	
			}
	
		}
	
		// Objects removal
	
		function removeObject( object ) {
	
			if ( object instanceof THREE.Mesh  ||
				 object instanceof THREE.PointCloud ||
				 object instanceof THREE.Line ) {
	
				delete _webglObjects[ object.id ];
	
			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {
	
				removeInstances( _webglObjectsImmediate, object );
	
			}
	
			delete object.__webglInit;
			delete object._modelViewMatrix;
			delete object._normalMatrix;
	
			delete object.__webglActive;
	
		}
	
		function removeInstances( objlist, object ) {
	
			for ( var o = objlist.length - 1; o >= 0; o -- ) {
	
				if ( objlist[ o ].object === object ) {
	
					objlist.splice( o, 1 );
	
				}
	
			}
	
		}
	
		// Materials
	
		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointCloudMaterial: 'particle_basic'
		};
	
		function initMaterial( material, lights, fog, object ) {
	
			material.addEventListener( 'dispose', onMaterialDispose );
	
			var shaderID = shaderIDs[ material.type ];
	
			if ( shaderID ) {
	
				var shader = THREE.ShaderLib[ shaderID ];
	
				material.__webglShader = {
					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				}
	
			} else {
	
				material.__webglShader = {
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				}
	
			}
	
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
	
			var maxLightCount = allocateLights( lights );
			var maxShadows = allocateShadows( lights );
			var maxBones = allocateBones( object );
	
			var parameters = {
	
				precision: _precision,
				supportsVertexTextures: _supportsVertexTextures,
	
				map: !! material.map,
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				lightMap: !! material.lightMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,
	
				combine: material.combine,
	
				vertexColors: material.vertexColors,
	
				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,
	
				flatShading: material.shading === THREE.FlatShading,
	
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: _logarithmicDepthBuffer,
	
				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,
	
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: _this.maxMorphTargets,
				maxMorphNormals: _this.maxMorphNormals,
	
				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,
	
				maxShadows: maxShadows,
				shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
				shadowMapType: _this.shadowMapType,
				shadowMapDebug: _this.shadowMapDebug,
				shadowMapCascade: _this.shadowMapCascade,
	
				alphaTest: material.alphaTest,
				metal: material.metal,
				wrapAround: material.wrapAround,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide
	
			};
	
			// Generate code
	
			var chunks = [];
	
			if ( shaderID ) {
	
				chunks.push( shaderID );
	
			} else {
	
				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );
	
			}
	
			if ( material.defines !== undefined ) {
	
				for ( var name in material.defines ) {
	
					chunks.push( name );
					chunks.push( material.defines[ name ] );
	
				}
	
			}
	
			for ( var name in parameters ) {
	
				chunks.push( name );
				chunks.push( parameters[ name ] );
	
			}
	
			var code = chunks.join();
	
			var program;
	
			// Check if code has been already compiled
	
			for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {
	
				var programInfo = _programs[ p ];
	
				if ( programInfo.code === code ) {
	
					program = programInfo;
					program.usedTimes ++;
	
					break;
	
				}
	
			}
	
			if ( program === undefined ) {
	
				program = new THREE.WebGLProgram( _this, code, material, parameters );
				_programs.push( program );
	
				_this.info.memory.programs = _programs.length;
	
			}
	
			material.program = program;
	
			var attributes = program.attributes;
	
			if ( material.morphTargets ) {
	
				material.numSupportedMorphTargets = 0;
	
				var id, base = 'morphTarget';
	
				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
					id = base + i;
	
					if ( attributes[ id ] >= 0 ) {
	
						material.numSupportedMorphTargets ++;
	
					}
	
				}
	
			}
	
			if ( material.morphNormals ) {
	
				material.numSupportedMorphNormals = 0;
	
				var id, base = 'morphNormal';
	
				for ( i = 0; i < _this.maxMorphNormals; i ++ ) {
	
					id = base + i;
	
					if ( attributes[ id ] >= 0 ) {
	
						material.numSupportedMorphNormals ++;
	
					}
	
				}
	
			}
	
			material.uniformsList = [];
	
			for ( var u in material.__webglShader.uniforms ) {
	
				var location = material.program.uniforms[ u ];
	
				if ( location ) {
					material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
				}
	
			}
	
		}
	
		function setMaterial( material ) {
	
			if ( material.transparent === true ) {
	
				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );
	
			} else {
	
				state.setBlending( THREE.NoBlending );
	
			}
	
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
		}
	
		function setProgram( camera, lights, fog, material, object ) {
	
			_usedTextureUnits = 0;
	
			if ( material.needsUpdate ) {
	
				if ( material.program ) deallocateMaterial( material );
	
				initMaterial( material, lights, fog, object );
				material.needsUpdate = false;
	
			}
	
			if ( material.morphTargets ) {
	
				if ( ! object.__webglMorphTargetInfluences ) {
	
					object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );
	
				}
	
			}
	
			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;
	
			var program = material.program,
				p_uniforms = program.uniforms,
				m_uniforms = material.__webglShader.uniforms;
	
			if ( program.id !== _currentProgram ) {
	
				_gl.useProgram( program.program );
				_currentProgram = program.id;
	
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
	
			}
	
			if ( material.id !== _currentMaterialId ) {
	
				if ( _currentMaterialId === -1 ) refreshLights = true;
				_currentMaterialId = material.id;
	
				refreshMaterial = true;
	
			}
	
			if ( refreshProgram || camera !== _currentCamera ) {
	
				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				if ( _logarithmicDepthBuffer ) {
	
					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
				}
	
	
				if ( camera !== _currentCamera ) _currentCamera = camera;
	
				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
	
				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {
	
					if ( p_uniforms.cameraPosition !== null ) {
	
						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );
	
					}
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {
	
					if ( p_uniforms.viewMatrix !== null ) {
	
						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );
	
					}
	
				}
	
			}
	
			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen
	
			if ( material.skinning ) {
	
				if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {
	
					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );
	
				}
	
				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {
	
					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );
	
				}
	
				if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {
	
					if ( p_uniforms.boneTexture !== null ) {
	
						var textureUnit = getTextureUnit();
	
						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );
	
					}
	
					if ( p_uniforms.boneTextureWidth !== null ) {
	
						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );
	
					}
	
					if ( p_uniforms.boneTextureHeight !== null ) {
	
						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );
	
					}
	
				} else if ( object.skeleton && object.skeleton.boneMatrices ) {
	
					if ( p_uniforms.boneGlobalMatrices !== null ) {
	
						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );
	
					}
	
				}
	
			}
	
			if ( refreshMaterial ) {
	
				// refresh uniforms common to several materials
	
				if ( fog && material.fog ) {
	
					refreshUniformsFog( m_uniforms, fog );
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {
	
					if ( _lightsNeedUpdate ) {
	
						refreshLights = true;
						setupLights( lights );
						_lightsNeedUpdate = false;
					}
	
					if ( refreshLights ) {
						refreshUniformsLights( m_uniforms, _lights );
						markUniformsLightsNeedsUpdate( m_uniforms, true );
					} else {
						markUniformsLightsNeedsUpdate( m_uniforms, false );
					}
	
				}
	
				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
				}
	
				// refresh single material specific uniforms
	
				if ( material instanceof THREE.LineBasicMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
	
				} else if ( material instanceof THREE.LineDashedMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );
	
				} else if ( material instanceof THREE.PointCloudMaterial ) {
	
					refreshUniformsParticle( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsPhong( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshLambertMaterial ) {
	
					refreshUniformsLambert( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;
	
				} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
					m_uniforms.opacity.value = material.opacity;
	
				}
	
				if ( object.receiveShadow && ! material._shadowPass ) {
	
					refreshUniformsShadow( m_uniforms, lights );
	
				}
	
				// load common uniforms
	
				loadUniformsGeneric( material.uniformsList );
	
			}
	
			loadUniformsMatrices( p_uniforms, object );
	
			if ( p_uniforms.modelMatrix !== null ) {
	
				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );
	
			}
	
			return program;
	
		}
	
		// Uniforms (refresh uniforms objects)
	
		function refreshUniformsCommon ( uniforms, material ) {
	
			uniforms.opacity.value = material.opacity;
	
			uniforms.diffuse.value = material.color;
	
			uniforms.map.value = material.map;
			uniforms.lightMap.value = material.lightMap;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			// uv repeat and offset setting priorities
			//  1. color map
			//  2. specular map
			//  3. normal map
			//  4. bump map
			//  5. alpha map
	
			var uvScaleMap;
	
			if ( material.map ) {
	
				uvScaleMap = material.map;
	
			} else if ( material.specularMap ) {
	
				uvScaleMap = material.specularMap;
	
			} else if ( material.normalMap ) {
	
				uvScaleMap = material.normalMap;
	
			} else if ( material.bumpMap ) {
	
				uvScaleMap = material.bumpMap;
	
			} else if ( material.alphaMap ) {
	
				uvScaleMap = material.alphaMap;
	
			}
	
			if ( uvScaleMap !== undefined ) {
	
				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;
	
			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;
	
		}
	
		function refreshUniformsLine ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
	
		}
	
		function refreshUniformsDash ( uniforms, material ) {
	
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
	
		}
	
		function refreshUniformsParticle ( uniforms, material ) {
	
			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.
	
			uniforms.map.value = material.map;
	
			if ( material.map !== null ) {
	
				var offset = material.map.offset;
				var repeat = material.map.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
		}
	
		function refreshUniformsFog ( uniforms, fog ) {
	
			uniforms.fogColor.value = fog.color;
	
			if ( fog instanceof THREE.Fog ) {
	
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
	
			} else if ( fog instanceof THREE.FogExp2 ) {
	
				uniforms.fogDensity.value = fog.density;
	
			}
	
		}
	
		function refreshUniformsPhong ( uniforms, material ) {
	
			uniforms.shininess.value = material.shininess;
	
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;
	
			if ( material.wrapAround ) {
	
				uniforms.wrapRGB.value.copy( material.wrapRGB );
	
			}
	
		}
	
		function refreshUniformsLambert ( uniforms, material ) {
	
			uniforms.emissive.value = material.emissive;
	
			if ( material.wrapAround ) {
	
				uniforms.wrapRGB.value.copy( material.wrapRGB );
	
			}
	
		}
	
		function refreshUniformsLights ( uniforms, lights ) {
	
			uniforms.ambientLightColor.value = lights.ambient;
	
			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;
	
			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;
			uniforms.pointLightDecay.value = lights.point.decays;
	
			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;
			uniforms.spotLightDecay.value = lights.spot.decays;
	
			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;
	
		}
	
		// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
		function markUniformsLightsNeedsUpdate ( uniforms, value ) {
	
			uniforms.ambientLightColor.needsUpdate = value;
	
			uniforms.directionalLightColor.needsUpdate = value;
			uniforms.directionalLightDirection.needsUpdate = value;
	
			uniforms.pointLightColor.needsUpdate = value;
			uniforms.pointLightPosition.needsUpdate = value;
			uniforms.pointLightDistance.needsUpdate = value;
			uniforms.pointLightDecay.needsUpdate = value;
	
			uniforms.spotLightColor.needsUpdate = value;
			uniforms.spotLightPosition.needsUpdate = value;
			uniforms.spotLightDistance.needsUpdate = value;
			uniforms.spotLightDirection.needsUpdate = value;
			uniforms.spotLightAngleCos.needsUpdate = value;
			uniforms.spotLightExponent.needsUpdate = value;
			uniforms.spotLightDecay.needsUpdate = value;
	
			uniforms.hemisphereLightSkyColor.needsUpdate = value;
			uniforms.hemisphereLightGroundColor.needsUpdate = value;
			uniforms.hemisphereLightDirection.needsUpdate = value;
	
		}
	
		function refreshUniformsShadow ( uniforms, lights ) {
	
			if ( uniforms.shadowMatrix ) {
	
				var j = 0;
	
				for ( var i = 0, il = lights.length; i < il; i ++ ) {
	
					var light = lights[ i ];
	
					if ( ! light.castShadow ) continue;
	
					if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {
	
						uniforms.shadowMap.value[ j ] = light.shadowMap;
						uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;
	
						uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;
	
						uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
						uniforms.shadowBias.value[ j ] = light.shadowBias;
	
						j ++;
	
					}
	
				}
	
			}
	
		}
	
		// Uniforms (load to GPU)
	
		function loadUniformsMatrices ( uniforms, object ) {
	
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );
	
			if ( uniforms.normalMatrix ) {
	
				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );
	
			}
	
		}
	
		function getTextureUnit() {
	
			var textureUnit = _usedTextureUnits;
	
			if ( textureUnit >= _maxTextures ) {
	
				THREE.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );
	
			}
	
			_usedTextureUnits += 1;
	
			return textureUnit;
	
		}
	
		function loadUniformsGeneric ( uniforms ) {
	
			var texture, textureUnit, offset;
	
			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {
	
				var uniform = uniforms[ j ][ 0 ];
	
				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;
	
				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];
	
				switch ( type ) {
	
					case '1i':
						_gl.uniform1i( location, value );
						break;
	
					case '1f':
						_gl.uniform1f( location, value );
						break;
	
					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;
	
					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;
	
					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;
	
					case '1iv':
						_gl.uniform1iv( location, value );
						break;
	
					case '3iv':
						_gl.uniform3iv( location, value );
						break;
	
					case '1fv':
						_gl.uniform1fv( location, value );
						break;
	
					case '2fv':
						_gl.uniform2fv( location, value );
						break;
	
					case '3fv':
						_gl.uniform3fv( location, value );
						break;
	
					case '4fv':
						_gl.uniform4fv( location, value );
						break;
	
					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;
	
					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;
	
					//
	
					case 'i':
	
						// single integer
						_gl.uniform1i( location, value );
	
						break;
	
					case 'f':
	
						// single float
						_gl.uniform1f( location, value );
	
						break;
	
					case 'v2':
	
						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );
	
						break;
	
					case 'v3':
	
						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );
	
						break;
	
					case 'v4':
	
						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );
	
						break;
	
					case 'c':
	
						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );
	
						break;
	
					case 'iv1':
	
						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );
	
						break;
	
					case 'iv':
	
						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );
	
						break;
	
					case 'fv1':
	
						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );
	
						break;
	
					case 'fv':
	
						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );
	
						break;
	
					case 'v2v':
	
						// array of THREE.Vector2
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 2 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							offset = i * 2;
	
							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;
	
						}
	
						_gl.uniform2fv( location, uniform._array );
	
						break;
	
					case 'v3v':
	
						// array of THREE.Vector3
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 3 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							offset = i * 3;
	
							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;
							uniform._array[ offset + 2 ] = value[ i ].z;
	
						}
	
						_gl.uniform3fv( location, uniform._array );
	
						break;
	
					case 'v4v':
	
						// array of THREE.Vector4
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 4 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							offset = i * 4;
	
							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;
							uniform._array[ offset + 2 ] = value[ i ].z;
							uniform._array[ offset + 3 ] = value[ i ].w;
	
						}
	
						_gl.uniform4fv( location, uniform._array );
	
						break;
	
					case 'm3':
	
						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );
	
						break;
	
					case 'm3v':
	
						// array of THREE.Matrix3
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 9 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );
	
						}
	
						_gl.uniformMatrix3fv( location, false, uniform._array );
	
						break;
	
					case 'm4':
	
						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );
	
						break;
	
					case 'm4v':
	
						// array of THREE.Matrix4
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 16 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );
	
						}
	
						_gl.uniformMatrix4fv( location, false, uniform._array );
	
						break;
	
					case 't':
	
						// single THREE.Texture (2d or cube)
	
						texture = value;
						textureUnit = getTextureUnit();
	
						_gl.uniform1i( location, textureUnit );
	
						if ( ! texture ) continue;
	
						if ( texture instanceof THREE.CubeTexture ||
						   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/
	
							setCubeTexture( texture, textureUnit );
	
						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
							setCubeTextureDynamic( texture, textureUnit );
	
						} else {
	
							_this.setTexture( texture, textureUnit );
	
						}
	
						break;
	
					case 'tv':
	
						// array of THREE.Texture (2d)
	
						if ( uniform._array === undefined ) {
	
							uniform._array = [];
	
						}
	
						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {
	
							uniform._array[ i ] = getTextureUnit();
	
						}
	
						_gl.uniform1iv( location, uniform._array );
	
						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {
	
							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];
	
							if ( ! texture ) continue;
	
							_this.setTexture( texture, textureUnit );
	
						}
	
						break;
	
					default:
	
						THREE.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );
	
				}
	
			}
	
		}
	
		function setupMatrices ( object, camera ) {
	
			object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object._normalMatrix.getNormalMatrix( object._modelViewMatrix );
	
		}
	
		function setColorLinear( array, offset, color, intensity ) {
	
			array[ offset ]     = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;
	
		}
	
		function setupLights ( lights ) {
	
			var l, ll, light,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,
			distance,
	
			zlights = _lights,
	
			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,
	
			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,
			pointDecays = zlights.point.decays,
	
			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,
			spotDecays = zlights.spot.decays,
	
			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,
	
			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,
	
			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,
	
			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;
	
			for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
				light = lights[ l ];
	
				if ( light.onlyShadow ) continue;
	
				color = light.color;
				intensity = light.intensity;
				distance = light.distance;
	
				if ( light instanceof THREE.AmbientLight ) {
	
					if ( ! light.visible ) continue;
	
					r += color.r;
					g += color.g;
					b += color.b;
	
				} else if ( light instanceof THREE.DirectionalLight ) {
	
					dirCount += 1;
	
					if ( ! light.visible ) continue;
	
					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();
	
					dirOffset = dirLength * 3;
	
					dirPositions[ dirOffset ]     = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;
	
					setColorLinear( dirColors, dirOffset, color, intensity );
	
					dirLength += 1;
	
				} else if ( light instanceof THREE.PointLight ) {
	
					pointCount += 1;
	
					if ( ! light.visible ) continue;
	
					pointOffset = pointLength * 3;
	
					setColorLinear( pointColors, pointOffset, color, intensity );
	
					_vector3.setFromMatrixPosition( light.matrixWorld );
	
					pointPositions[ pointOffset ]     = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;
	
					// distance is 0 if decay is 0, because there is no attenuation at all.
					pointDistances[ pointLength ] = distance;
					pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					pointLength += 1;
	
				} else if ( light instanceof THREE.SpotLight ) {
	
					spotCount += 1;
	
					if ( ! light.visible ) continue;
	
					spotOffset = spotLength * 3;
	
					setColorLinear( spotColors, spotOffset, color, intensity );
	
					_direction.setFromMatrixPosition( light.matrixWorld );
	
					spotPositions[ spotOffset ]     = _direction.x;
					spotPositions[ spotOffset + 1 ] = _direction.y;
					spotPositions[ spotOffset + 2 ] = _direction.z;
	
					spotDistances[ spotLength ] = distance;
	
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();
	
					spotDirections[ spotOffset ]     = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;
	
					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;
					spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					spotLength += 1;
	
				} else if ( light instanceof THREE.HemisphereLight ) {
	
					hemiCount += 1;
	
					if ( ! light.visible ) continue;
	
					_direction.setFromMatrixPosition( light.matrixWorld );
					_direction.normalize();
	
					hemiOffset = hemiLength * 3;
	
					hemiPositions[ hemiOffset ]     = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;
	
					skyColor = light.color;
					groundColor = light.groundColor;
	
					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );
	
					hemiLength += 1;
	
				}
	
			}
	
			// null eventual remains from removed lights
			// (this is to avoid if in shader)
	
			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;
	
			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;
	
			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;
	
		}
	
		// GL state setting
	
		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
			if ( cullFace === THREE.CullFaceNone ) {
	
				_gl.disable( _gl.CULL_FACE );
	
			} else {
	
				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {
	
					_gl.frontFace( _gl.CW );
	
				} else {
	
					_gl.frontFace( _gl.CCW );
	
				}
	
				if ( cullFace === THREE.CullFaceBack ) {
	
					_gl.cullFace( _gl.BACK );
	
				} else if ( cullFace === THREE.CullFaceFront ) {
	
					_gl.cullFace( _gl.FRONT );
	
				} else {
	
					_gl.cullFace( _gl.FRONT_AND_BACK );
	
				}
	
				_gl.enable( _gl.CULL_FACE );
	
			}
	
		};
	
		this.setMaterialFaces = function ( material ) {
	
			state.setDoubleSided( material.side === THREE.DoubleSide );
			state.setFlipSided( material.side === THREE.BackSide );
	
		};
	
		// Textures
	
		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {
	
			var extension;
	
			if ( isImagePowerOfTwo ) {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
			} else {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {
	
					THREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );
	
				}
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {
	
					THREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );
	
				}
	
			}
	
			extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
			if ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {
	
				if ( texture.anisotropy > 1 || texture.__currentAnisotropy ) {
	
					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					texture.__currentAnisotropy = texture.anisotropy;
	
				}
	
			}
	
		}
	
		this.uploadTexture = function ( texture ) {
	
			if ( texture.__webglInit === undefined ) {
	
				texture.__webglInit = true;
	
				texture.addEventListener( 'dispose', onTextureDispose );
	
				texture.__webglTexture = _gl.createTexture();
	
				_this.info.memory.textures ++;
	
			}
	
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );
	
			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
			texture.image = clampToMaxSize( texture.image, _maxTextureSize );
	
			var image = texture.image,
			isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );
	
			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );
	
			var mipmap, mipmaps = texture.mipmaps;
	
			if ( texture instanceof THREE.DataTexture ) {
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
				}
	
			} else if ( texture instanceof THREE.CompressedTexture ) {
	
				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
					mipmap = mipmaps[ i ];
	
					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
						if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {
	
							_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
						} else {
	
							THREE.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );
	
						}
	
					} else {
	
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
				}
	
			} else { // regular Texture (image, video, canvas)
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );
	
				}
	
			}
	
			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
			texture.needsUpdate = false;
	
			if ( texture.onUpdate ) texture.onUpdate();
	
		};
	
		this.setTexture = function ( texture, slot ) {
	
			_gl.activeTexture( _gl.TEXTURE0 + slot );
	
			if ( texture.needsUpdate ) {
	
				_this.uploadTexture( texture );
	
			} else {
	
				_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );
	
			}
	
		};
	
		function clampToMaxSize ( image, maxSize ) {
	
			if ( image.width > maxSize || image.height > maxSize ) {
	
				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.
	
				var scale = maxSize / Math.max( image.width, image.height );
	
				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );
	
				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
	
				THREE.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
				return canvas;
	
			}
	
			return image;
	
		}
	
		function setCubeTexture ( texture, slot ) {
	
			if ( texture.image.length === 6 ) {
	
				if ( texture.needsUpdate ) {
	
					if ( ! texture.image.__webglTextureCube ) {
	
						texture.addEventListener( 'dispose', onTextureDispose );
	
						texture.image.__webglTextureCube = _gl.createTexture();
	
						_this.info.memory.textures ++;
	
					}
	
					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );
	
					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;
	
					var cubeImage = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {
	
							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );
	
						} else {
	
							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
						}
	
					}
	
					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );
	
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( ! isCompressed ) {
	
							if ( isDataTexture ) {
	
								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
							} else {
	
								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
							}
	
						} else {
	
							var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
								mipmap = mipmaps[ j ];
	
								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
									if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {
	
										_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
									} else {
	
										THREE.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );
	
									}
	
								} else {
	
									_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
								}
	
							}
	
						}
	
					}
	
					if ( texture.generateMipmaps && isImagePowerOfTwo ) {
	
						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
					}
	
					texture.needsUpdate = false;
	
					if ( texture.onUpdate ) texture.onUpdate();
	
				} else {
	
					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );
	
				}
	
			}
	
		}
	
		function setCubeTextureDynamic ( texture, slot ) {
	
			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );
	
		}
	
		// Render targets
	
		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {
	
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );
	
		}
	
		function setupRenderBuffer ( renderbuffer, renderTarget  ) {
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			/* For some reason this is not working. Defaulting to RGBA4.
			} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
			}
	
		}
	
		this.setRenderTarget = function ( renderTarget ) {
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
	
			if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {
	
				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;
	
				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
				renderTarget.__webglTexture = _gl.createTexture();
	
				_this.info.memory.textures ++;
	
				// Setup texture, create render and frame buffers
	
				var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
					glFormat = paramThreeToGL( renderTarget.format ),
					glType = paramThreeToGL( renderTarget.type );
	
				if ( isCube ) {
	
					renderTarget.__webglFramebuffer = [];
					renderTarget.__webglRenderbuffer = [];
	
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
	
						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
	
						setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );
	
					}
	
					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
				} else {
	
					renderTarget.__webglFramebuffer = _gl.createFramebuffer();
	
					if ( renderTarget.shareDepthFrom ) {
	
						renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
	
					} else {
	
						renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();
	
					}
	
					_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );
	
					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
	
					setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );
	
					if ( renderTarget.shareDepthFrom ) {
	
						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );
	
						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );
	
						}
	
					} else {
	
						setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );
	
					}
	
					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				}
	
				// Release everything
	
				if ( isCube ) {
	
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
				} else {
	
					_gl.bindTexture( _gl.TEXTURE_2D, null );
	
				}
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			var framebuffer, width, height, vx, vy;
	
			if ( renderTarget ) {
	
				if ( isCube ) {
	
					framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
				} else {
	
					framebuffer = renderTarget.__webglFramebuffer;
	
				}
	
				width = renderTarget.width;
				height = renderTarget.height;
	
				vx = 0;
				vy = 0;
	
			} else {
	
				framebuffer = null;
	
				width = _viewportWidth;
				height = _viewportHeight;
	
				vx = _viewportX;
				vy = _viewportY;
	
			}
	
			if ( framebuffer !== _currentFramebuffer ) {
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );
	
				_currentFramebuffer = framebuffer;
	
			}
	
			_currentWidth = width;
			_currentHeight = height;
	
		};
	
		this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {
	
			if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {
	
				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;
	
			}
	
			if ( renderTarget.__webglFramebuffer ) {
	
				if ( renderTarget.format !== THREE.RGBAFormat ) {
	
					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
					return;
	
				}
	
				var restore = false;
	
				if ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );
	
					restore = true;
	
				}
	
				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
	
					_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );
	
				} else {
	
					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
				}
	
				if ( restore ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
	
				}
	
			}
	
		};
	
		function updateRenderTargetMipmap ( renderTarget ) {
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
			} else {
	
				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_2D );
				_gl.bindTexture( _gl.TEXTURE_2D, null );
	
			}
	
		}
	
		// Fallback filters for non-power-of-2 textures
	
		function filterFallback ( f ) {
	
			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {
	
				return _gl.NEAREST;
	
			}
	
			return _gl.LINEAR;
	
		}
	
		// Map three.js constants to WebGL constants
	
		function paramThreeToGL ( p ) {
	
			var extension;
	
			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;
	
			extension = extensions.get( 'OES_texture_half_float' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;
	
			}
	
			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
	
			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
			}
	
			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
			}
	
			extension = extensions.get( 'EXT_blend_minmax' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;
	
			}
	
			return 0;
	
		}
	
		// Allocations
	
		function allocateBones ( object ) {
	
			if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {
	
				return 1024;
	
			} else {
	
				// default for when object is not specified
				// ( for example when prebuilding shader
				//   to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)
	
				var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
				var maxBones = nVertexMatrices;
	
				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {
	
					maxBones = Math.min( object.skeleton.bones.length, maxBones );
	
					if ( maxBones < object.skeleton.bones.length ) {
	
						THREE.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );
	
					}
	
				}
	
				return maxBones;
	
			}
	
		}
	
		function allocateLights( lights ) {
	
			var dirLights = 0;
			var pointLights = 0;
			var spotLights = 0;
			var hemiLights = 0;
	
			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {
	
				var light = lights[ l ];
	
				if ( light.onlyShadow || light.visible === false ) continue;
	
				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;
	
			}
	
			return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };
	
		}
	
		function allocateShadows( lights ) {
	
			var maxShadows = 0;
	
			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {
	
				var light = lights[ l ];
	
				if ( ! light.castShadow ) continue;
	
				if ( light instanceof THREE.SpotLight ) maxShadows ++;
				if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;
	
			}
	
			return maxShadows;
	
		}
	
		// DEPRECATED
	
		this.initMaterial = function () {
	
			THREE.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
	
		};
	
		this.addPrePlugin = function () {
	
			THREE.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
	
		};
	
		this.addPostPlugin = function () {
	
			THREE.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
	
		};
	
		this.updateShadowMap = function () {
	
			THREE.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
	
		};
	
	};
	
	// File:src/renderers/WebGLRenderTarget.js
	
	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.WebGLRenderTarget = function ( width, height, options ) {
	
		this.width = width;
		this.height = height;
	
		options = options || {};
	
		this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
		this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
		this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;
	
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	
		this.generateMipmaps = true;
	
		this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;
	
	};
	
	THREE.WebGLRenderTarget.prototype = {
	
		constructor: THREE.WebGLRenderTarget,
	
		setSize: function ( width, height ) {
	
			this.width = width;
			this.height = height;
	
		},
	
		clone: function () {
	
			var tmp = new THREE.WebGLRenderTarget( this.width, this.height );
	
			tmp.wrapS = this.wrapS;
			tmp.wrapT = this.wrapT;
	
			tmp.magFilter = this.magFilter;
			tmp.minFilter = this.minFilter;
	
			tmp.anisotropy = this.anisotropy;
	
			tmp.offset.copy( this.offset );
			tmp.repeat.copy( this.repeat );
	
			tmp.format = this.format;
			tmp.type = this.type;
	
			tmp.depthBuffer = this.depthBuffer;
			tmp.stencilBuffer = this.stencilBuffer;
	
			tmp.generateMipmaps = this.generateMipmaps;
	
			tmp.shareDepthFrom = this.shareDepthFrom;
	
			return tmp;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );
	
	// File:src/renderers/WebGLRenderTargetCube.js
	
	/**
	 * @author alteredq / http://alteredqualia.com
	 */
	
	THREE.WebGLRenderTargetCube = function ( width, height, options ) {
	
		THREE.WebGLRenderTarget.call( this, width, height, options );
	
		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	
	};
	
	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
	
	// File:src/renderers/webgl/WebGLExtensions.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLExtensions = function ( gl ) {
	
		var extensions = {};
	
		this.get = function ( name ) {
	
			if ( extensions[ name ] !== undefined ) {
	
				return extensions[ name ];
	
			}
	
			var extension;
	
			switch ( name ) {
	
				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;
	
				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;
	
				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;
	
				default:
					extension = gl.getExtension( name );
	
			}
	
			if ( extension === null ) {
	
				THREE.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
			}
	
			extensions[ name ] = extension;
	
			return extension;
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLProgram.js
	
	THREE.WebGLProgram = ( function () {
	
		var programIdCount = 0;
	
		var generateDefines = function ( defines ) {
	
			var value, chunk, chunks = [];
	
			for ( var d in defines ) {
	
				value = defines[ d ];
				if ( value === false ) continue;
	
				chunk = '#define ' + d + ' ' + value;
				chunks.push( chunk );
	
			}
	
			return chunks.join( '\n' );
	
		};
	
		var cacheUniformLocations = function ( gl, program, identifiers ) {
	
			var uniforms = {};
	
			for ( var i = 0, l = identifiers.length; i < l; i ++ ) {
	
				var id = identifiers[ i ];
				uniforms[ id ] = gl.getUniformLocation( program, id );
	
			}
	
			return uniforms;
	
		};
	
		var cacheAttributeLocations = function ( gl, program, identifiers ) {
	
			var attributes = {};
	
			for ( var i = 0, l = identifiers.length; i < l; i ++ ) {
	
				var id = identifiers[ i ];
				attributes[ id ] = gl.getAttribLocation( program, id );
	
			}
	
			return attributes;
	
		};
	
		return function ( renderer, code, material, parameters ) {
	
			var _this = renderer;
			var _gl = _this.context;
	
			var defines = material.defines;
			var uniforms = material.__webglShader.uniforms;
			var attributes = material.attributes;
	
			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;
	
			var index0AttributeName = material.index0AttributeName;
	
			if ( index0AttributeName === undefined && parameters.morphTargets === true ) {
	
				// programs with morphTargets displace position out of attribute 0
	
				index0AttributeName = 'position';
	
			}
	
			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
			}
	
			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
			if ( parameters.envMap ) {
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;
	
					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;
	
					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;
	
				}
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;
	
				}
	
				switch ( material.combine ) {
	
					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;
	
					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;
	
					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;
	
				}
	
			}
	
			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
			// console.log( 'building new program ' );
	
			//
	
			var customDefines = generateDefines( defines );
	
			//
	
			var program = _gl.createProgram();
	
			var prefix_vertex, prefix_fragment;
	
			if ( material instanceof THREE.RawShaderMaterial ) {
	
				prefix_vertex = '';
				prefix_fragment = '';
	
			} else {
	
				prefix_vertex = [
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					customDefines,
	
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
					_this.gammaInput ? '#define GAMMA_INPUT' : '',
					_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,
	
					'#define MAX_SHADOWS ' + parameters.maxShadows,
	
					'#define MAX_BONES ' + parameters.maxBones,
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED': '',
	
					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals ? '#define USE_MORPHNORMALS' : '',
					parameters.wrapAround ? '#define WRAP_AROUND' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
	
					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
	
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
	
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
					'attribute vec2 uv2;',
	
					'#ifdef USE_COLOR',
	
					'	attribute vec3 color;',
	
					'#endif',
	
					'#ifdef USE_MORPHTARGETS',
	
					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',
	
					'	#ifdef USE_MORPHNORMALS',
	
					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',
	
					'	#else',
	
					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',
	
					'	#endif',
	
					'#endif',
	
					'#ifdef USE_SKINNING',
	
					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',
	
					'#endif',
	
					''
	
				].join( '\n' );
	
				prefix_fragment = [
	
					parameters.bumpMap || parameters.normalMap || parameters.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					customDefines,
	
					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,
	
					'#define MAX_SHADOWS ' + parameters.maxShadows,
	
					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	
					_this.gammaInput ? '#define GAMMA_INPUT' : '',
					_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED': '',
	
					parameters.metal ? '#define METAL' : '',
					parameters.wrapAround ? '#define WRAP_AROUND' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
					''
	
				].join( '\n' );
	
			}
	
			var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
			var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );
	
			_gl.attachShader( program, glVertexShader );
			_gl.attachShader( program, glFragmentShader );
	
			if ( index0AttributeName !== undefined ) {
	
				// Force a particular attribute to index 0.
				// because potentially expensive emulation is done by browser if attribute 0 is disabled.
				// And, color, for example is often automatically bound to index 0 so disabling it
	
				_gl.bindAttribLocation( program, 0, index0AttributeName );
	
			}
	
			_gl.linkProgram( program );
	
			var programLogInfo = _gl.getProgramInfoLog( program );
	
			if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {
	
				THREE.error( 'THREE.WebGLProgram: shader error: ' + _gl.getError(), 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ), 'gl.getPRogramInfoLog', programLogInfo );
	
			}
	
			if ( programLogInfo !== '' ) {
	
				THREE.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()' + programLogInfo );
				// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
				// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	
			}
	
			// clean up
	
			_gl.deleteShader( glVertexShader );
			_gl.deleteShader( glFragmentShader );
	
			// cache uniform locations
	
			var identifiers = [
	
				'viewMatrix',
				'modelViewMatrix',
				'projectionMatrix',
				'normalMatrix',
				'modelMatrix',
				'cameraPosition',
				'morphTargetInfluences',
				'bindMatrix',
				'bindMatrixInverse'
	
			];
	
			if ( parameters.useVertexTexture ) {
	
				identifiers.push( 'boneTexture' );
				identifiers.push( 'boneTextureWidth' );
				identifiers.push( 'boneTextureHeight' );
	
			} else {
	
				identifiers.push( 'boneGlobalMatrices' );
	
			}
	
			if ( parameters.logarithmicDepthBuffer ) {
	
				identifiers.push('logDepthBufFC');
	
			}
	
	
			for ( var u in uniforms ) {
	
				identifiers.push( u );
	
			}
	
			this.uniforms = cacheUniformLocations( _gl, program, identifiers );
	
			// cache attributes locations
	
			identifiers = [
	
				'position',
				'normal',
				'uv',
				'uv2',
				'tangent',
				'color',
				'skinIndex',
				'skinWeight',
				'lineDistance'
	
			];
	
			for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {
	
				identifiers.push( 'morphTarget' + i );
	
			}
	
			for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {
	
				identifiers.push( 'morphNormal' + i );
	
			}
	
			for ( var a in attributes ) {
	
				identifiers.push( a );
	
			}
	
			this.attributes = cacheAttributeLocations( _gl, program, identifiers );
			this.attributesKeys = Object.keys( this.attributes );
	
			//
	
			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;
	
			return this;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLShader.js
	
	THREE.WebGLShader = ( function () {
	
		var addLineNumbers = function ( string ) {
	
			var lines = string.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
			}
	
			return lines.join( '\n' );
	
		};
	
		return function ( gl, type, string ) {
	
			var shader = gl.createShader( type ); 
	
			gl.shaderSource( shader, string );
			gl.compileShader( shader );
	
			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
	
				THREE.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	
			}
	
			if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
				THREE.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
			return shader;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLState.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLState = function ( gl, paramThreeToGL ) {
	
		var newAttributes = new Uint8Array( 16 );
		var enabledAttributes = new Uint8Array( 16 );
	
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
	
		var currentDepthTest = null;
		var currentDepthWrite = null;
	
		var currentColorWrite = null;
	
		var currentDoubleSided = null;
		var currentFlipSided = null;
	
		var currentLineWidth = null;
	
		var currentPolygonOffset = null;
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;
	
		this.initAttributes = function () {
	
			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
				newAttributes[ i ] = 0;
	
			}
	
		};
	
		this.enableAttribute = function ( attribute ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
		};
	
		this.disableUnusedAttributes = function () {
	
			for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {
	
				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
		};
	
		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {
	
			if ( blending !== currentBlending ) {
	
				if ( blending === THREE.NoBlending ) {
	
					gl.disable( gl.BLEND );
	
				} else if ( blending === THREE.AdditiveBlending ) {
	
					gl.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
	
				} else if ( blending === THREE.SubtractiveBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
					gl.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
	
				} else if ( blending === THREE.MultiplyBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
					gl.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
	
				} else if ( blending === THREE.CustomBlending ) {
	
					gl.enable( gl.BLEND );
	
				} else {
	
					gl.enable( gl.BLEND );
					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
				}
	
				currentBlending = blending;
	
			}
	
			if ( blending === THREE.CustomBlending ) {
	
				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;
	
				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );
	
					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;
	
				}
	
				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
	
					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;
	
				}
	
			} else {
	
				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
	
			}
	
		};
	
		this.setDepthTest = function ( depthTest ) {
	
			if ( currentDepthTest !== depthTest ) {
	
				if ( depthTest ) {
	
					gl.enable( gl.DEPTH_TEST );
	
				} else {
	
					gl.disable( gl.DEPTH_TEST );
	
				}
	
				currentDepthTest = depthTest;
	
			}
	
		};
	
		this.setDepthWrite = function ( depthWrite ) {
	
			if ( currentDepthWrite !== depthWrite ) {
	
				gl.depthMask( depthWrite );
				currentDepthWrite = depthWrite;
	
			}
	
		};
	
		this.setColorWrite = function ( colorWrite ) {
	
			if ( currentColorWrite !== colorWrite ) {
	
				gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
				currentColorWrite = colorWrite;
	
			}
	
		};
	
		this.setDoubleSided = function ( doubleSided ) {
	
			if ( currentDoubleSided !== doubleSided ) {
	
				if ( doubleSided ) {
	
					gl.disable( gl.CULL_FACE );
	
				} else {
	
					gl.enable( gl.CULL_FACE );
	
				}
	
				currentDoubleSided = doubleSided;
	
			}
	
		};
	
		this.setFlipSided = function ( flipSided ) {
	
			if ( currentFlipSided !== flipSided ) {
	
				if ( flipSided ) {
	
					gl.frontFace( gl.CW );
	
				} else {
	
					gl.frontFace( gl.CCW );
	
				}
	
				currentFlipSided = flipSided;
	
			}
	
		};
	
		this.setLineWidth = function ( width ) {
	
			if ( width !== currentLineWidth ) {
	
				gl.lineWidth( width );
	
				currentLineWidth = width;
	
			}
	
		};
	
		this.setPolygonOffset = function ( polygonoffset, factor, units ) {
	
			if ( currentPolygonOffset !== polygonoffset ) {
	
				if ( polygonoffset ) {
	
					gl.enable( gl.POLYGON_OFFSET_FILL );
	
				} else {
	
					gl.disable( gl.POLYGON_OFFSET_FILL );
	
				}
	
				currentPolygonOffset = polygonoffset;
	
			}
	
			if ( polygonoffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {
	
				gl.polygonOffset( factor, units );
	
				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;
	
			}
	
		};
	
		this.reset = function () {
	
			for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
				enabledAttributes[ i ] = 0;
	
			}
	
			currentBlending = null;
			currentDepthTest = null;
			currentDepthWrite = null;
			currentColorWrite = null;
			currentDoubleSided = null;
			currentFlipSided = null;
	
		};
	
	};
	
	// File:src/renderers/webgl/plugins/LensFlarePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlarePlugin = function ( renderer, flares ) {
	
		var gl = renderer.context;
	
		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;
	
		var tempTexture, occlusionTexture;
	
		var init = function () {
	
			var vertices = new Float32Array( [
				-1, -1,  0, 0,
				 1, -1,  1, 0,
				 1,  1,  1, 1,
				-1,  1,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			// buffers
	
			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			// textures
	
			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();
	
			gl.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;
	
			var shader;
	
			if ( hasVertexTexture ) {
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"uniform sampler2D occlusionMap;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if( renderType == 2 ) {",
	
								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							// pink square
	
							"if( renderType == 0 ) {",
	
								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
							// restore
	
							"} else if( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
			} else {
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if( renderType == 2 ) {",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"precision mediump float;",
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
	
						"void main() {",
	
							// pink square
	
							"if( renderType == 0 ) {",
	
								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",
	
							// restore
	
							"} else if( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
			}
	
			program = createProgram( shader );
	
			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			}
	
			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};
	
		};
	
		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */
	
		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {
	
			if ( flares.length === 0 ) return;
	
			var tempPosition = new THREE.Vector3();
	
			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;
	
			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );
	
			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			gl.enableVertexAttribArray( attributes.vertex );
			gl.enableVertexAttribArray( attributes.uv );
	
			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/unforms
	
			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			gl.disable( gl.CULL_FACE );
			gl.depthMask( false );
	
			for ( var i = 0, l = flares.length; i < l; i ++ ) {
	
				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );
	
				// calc object screen position
	
				var flare = flares[ i ];
	
				tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );
	
				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );
	
				// setup arrays for gl programs
	
				screenPosition.copy( tempPosition )
	
				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
	
				// screen cull
	
				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {
	
					// save current RGB to temp texture
	
					gl.activeTexture( gl.TEXTURE1 );
					gl.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// render pink quad
	
					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
					gl.disable( gl.BLEND );
					gl.enable( gl.DEPTH_TEST );
	
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// copy result to occlusionMap
	
					gl.activeTexture( gl.TEXTURE0 );
					gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// restore graphics
	
					gl.uniform1i( uniforms.renderType, 1 );
					gl.disable( gl.DEPTH_TEST );
	
					gl.activeTexture( gl.TEXTURE1 );
					gl.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// update object positions
	
					flare.positionScreen.copy( screenPosition )
	
					if ( flare.customUpdateCallback ) {
	
						flare.customUpdateCallback( flare );
	
					} else {
	
						flare.updateLensFlares();
	
					}
	
					// render flares
	
					gl.uniform1i( uniforms.renderType, 2 );
					gl.enable( gl.BLEND );
	
					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
						var sprite = flare.lensFlares[ j ];
	
						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;
	
							size = sprite.size * sprite.scale / viewportHeight;
	
							scale.x = size * invAspect;
							scale.y = size;
	
							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );
	
							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
							renderer.state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );
	
							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
						}
	
					}
	
				}
	
			}
	
			// restore gl
	
			gl.enable( gl.CULL_FACE );
			gl.enable( gl.DEPTH_TEST );
			gl.depthMask( true );
	
			renderer.resetGLState();
	
		};
	
		function createProgram ( shader ) {
	
			var program = gl.createProgram();
	
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
	
			var prefix = "precision " + renderer.getPrecision() + " float;\n";
	
			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );
	
			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );
	
			gl.linkProgram( program );
	
			return program;
	
		}
	
	};
	
	// File:src/renderers/webgl/plugins/ShadowMapPlugin.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {
	
		var _gl = _renderer.context;
	
		var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,
	
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),
	
		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),
	
		_matrixPosition = new THREE.Vector3(),
	
		_renderList = [];
	
		// init
	
		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
	
		_depthMaterial = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader
		 } );
	
		_depthMaterialMorph = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true
		} );
	
		_depthMaterialSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			skinning: true
		} );
	
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true,
			skinning: true
		} );
	
		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;
	
		this.render = function ( scene, camera ) {
	
			if ( _renderer.shadowMapEnabled === false ) return;
	
			var i, il, j, jl, n,
	
			shadowMap, shadowMatrix, shadowCamera,
			buffer, material,
			webglObject, object, light,
	
			lights = [],
			k = 0,
	
			fog = null;
	
			// set GL state for depth map
	
			_gl.clearColor( 1, 1, 1, 1 );
			_gl.disable( _gl.BLEND );
	
			_gl.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );
	
			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {
	
				_gl.cullFace( _gl.FRONT );
	
			} else {
	
				_gl.cullFace( _gl.BACK );
	
			}
	
			_renderer.state.setDepthTest( true );
	
			// preprocess lights
			// 	- skip lights that are not casting shadows
			//	- create virtual lights for cascaded shadow maps
	
			for ( i = 0, il = _lights.length; i < il; i ++ ) {
	
				light = _lights[ i ];
	
				if ( ! light.castShadow ) continue;
	
				if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {
	
					for ( n = 0; n < light.shadowCascadeCount; n ++ ) {
	
						var virtualLight;
	
						if ( ! light.shadowCascadeArray[ n ] ) {
	
							virtualLight = createVirtualLight( light, n );
							virtualLight.originalCamera = camera;
	
							var gyro = new THREE.Gyroscope();
							gyro.position.copy( light.shadowCascadeOffset );
	
							gyro.add( virtualLight );
							gyro.add( virtualLight.target );
	
							camera.add( gyro );
	
							light.shadowCascadeArray[ n ] = virtualLight;
	
							//console.log( "Created virtualLight", virtualLight );
	
						} else {
	
							virtualLight = light.shadowCascadeArray[ n ];
	
						}
	
						updateVirtualLight( light, n );
	
						lights[ k ] = virtualLight;
						k ++;
	
					}
	
				} else {
	
					lights[ k ] = light;
					k ++;
	
				}
	
			}
	
			// render depth map
	
			for ( i = 0, il = lights.length; i < il; i ++ ) {
	
				light = lights[ i ];
	
				if ( ! light.shadowMap ) {
	
					var shadowFilter = THREE.LinearFilter;
	
					if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {
	
						shadowFilter = THREE.NearestFilter;
	
					}
	
					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };
	
					light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
					light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );
	
					light.shadowMatrix = new THREE.Matrix4();
	
				}
	
				if ( ! light.shadowCamera ) {
	
					if ( light instanceof THREE.SpotLight ) {
	
						light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );
	
					} else if ( light instanceof THREE.DirectionalLight ) {
	
						light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );
	
					} else {
	
						THREE.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
						continue;
	
					}
	
					scene.add( light.shadowCamera );
	
					if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
				}
	
				if ( light.shadowCameraVisible && ! light.cameraHelper ) {
	
					light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
					scene.add( light.cameraHelper );
	
				}
	
				if ( light.isVirtual && virtualLight.originalCamera == camera ) {
	
					updateShadowCamera( camera, light );
	
				}
	
				shadowMap = light.shadowMap;
				shadowMatrix = light.shadowMatrix;
				shadowCamera = light.shadowCamera;
	
				//
	
				shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
				_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _matrixPosition );
				shadowCamera.updateMatrixWorld();
	
				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
				//
	
				if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
				if ( light.shadowCameraVisible ) light.cameraHelper.update();
	
				// compute shadow matrix
	
				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);
	
				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
				// update camera matrices and frustum
	
				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );
	
				// render shadow map
	
				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();
	
				// set object matrices & frustum culling
	
				_renderList.length = 0;
	
				projectObject( scene, scene, shadowCamera );
	
	
				// render regular objects
	
				var objectMaterial, useMorphing, useSkinning;
	
				for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {
	
					webglObject = _renderList[ j ];
	
					object = webglObject.object;
					buffer = webglObject.buffer;
	
					// culling is overriden globally for all objects
					// while rendering depth map
	
					// need to deal with MeshFaceMaterial somehow
					// in that case just use the first of material.materials for now
					// (proper solution would require to break objects by materials
					//  similarly to regular rendering and then set corresponding
					//  depth materials per each chunk instead of just once per object)
	
					objectMaterial = getObjectMaterial( object );
	
					useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
	
					if ( object.customDepthMaterial ) {
	
						material = object.customDepthMaterial;
	
					} else if ( useSkinning ) {
	
						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
	
					} else if ( useMorphing ) {
	
						material = _depthMaterialMorph;
	
					} else {
	
						material = _depthMaterial;
	
					}
	
					_renderer.setMaterialFaces( objectMaterial );
	
					if ( buffer instanceof THREE.BufferGeometry ) {
	
						_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );
	
					} else {
	
						_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );
	
					}
	
				}
	
				// set matrices and render immediate objects
	
				for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {
	
					webglObject = _webglObjectsImmediate[ j ];
					object = webglObject.object;
	
					if ( object.visible && object.castShadow ) {
	
						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
	
						_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );
	
					}
	
				}
	
			}
	
			// restore GL state
	
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
	
			_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
			_gl.enable( _gl.BLEND );
	
			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {
	
				_gl.cullFace( _gl.BACK );
	
			}
	
			_renderer.resetGLState();
	
		};
	
		function projectObject( scene, object, shadowCamera ) {
	
			if ( object.visible ) {
	
				var webglObjects = _webglObjects[ object.id ];
	
				if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {
	
					for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {
	
						var webglObject = webglObjects[ i ];
	
						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( webglObject );
	
					}
	
				}
	
				for ( var i = 0, l = object.children.length; i < l; i ++ ) {
	
					projectObject( scene, object.children[ i ], shadowCamera );
	
				}
	
			}
	
		}
	
		function createVirtualLight( light, cascade ) {
	
			var virtualLight = new THREE.DirectionalLight();
	
			virtualLight.isVirtual = true;
	
			virtualLight.onlyShadow = true;
			virtualLight.castShadow = true;
	
			virtualLight.shadowCameraNear = light.shadowCameraNear;
			virtualLight.shadowCameraFar = light.shadowCameraFar;
	
			virtualLight.shadowCameraLeft = light.shadowCameraLeft;
			virtualLight.shadowCameraRight = light.shadowCameraRight;
			virtualLight.shadowCameraBottom = light.shadowCameraBottom;
			virtualLight.shadowCameraTop = light.shadowCameraTop;
	
			virtualLight.shadowCameraVisible = light.shadowCameraVisible;
	
			virtualLight.shadowDarkness = light.shadowDarkness;
	
			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
			virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
			virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];
	
			virtualLight.pointsWorld = [];
			virtualLight.pointsFrustum = [];
	
			var pointsWorld = virtualLight.pointsWorld,
				pointsFrustum = virtualLight.pointsFrustum;
	
			for ( var i = 0; i < 8; i ++ ) {
	
				pointsWorld[ i ] = new THREE.Vector3();
				pointsFrustum[ i ] = new THREE.Vector3();
	
			}
	
			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];
	
			pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
			pointsFrustum[ 1 ].set(  1, - 1, nearZ );
			pointsFrustum[ 2 ].set( - 1,  1, nearZ );
			pointsFrustum[ 3 ].set(  1,  1, nearZ );
	
			pointsFrustum[ 4 ].set( - 1, - 1, farZ );
			pointsFrustum[ 5 ].set(  1, - 1, farZ );
			pointsFrustum[ 6 ].set( - 1,  1, farZ );
			pointsFrustum[ 7 ].set(  1,  1, farZ );
	
			return virtualLight;
	
		}
	
		// Synchronize virtual light with the original light
	
		function updateVirtualLight( light, cascade ) {
	
			var virtualLight = light.shadowCascadeArray[ cascade ];
	
			virtualLight.position.copy( light.position );
			virtualLight.target.position.copy( light.target.position );
			virtualLight.lookAt( virtualLight.target );
	
			virtualLight.shadowCameraVisible = light.shadowCameraVisible;
			virtualLight.shadowDarkness = light.shadowDarkness;
	
			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
	
			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];
	
			var pointsFrustum = virtualLight.pointsFrustum;
	
			pointsFrustum[ 0 ].z = nearZ;
			pointsFrustum[ 1 ].z = nearZ;
			pointsFrustum[ 2 ].z = nearZ;
			pointsFrustum[ 3 ].z = nearZ;
	
			pointsFrustum[ 4 ].z = farZ;
			pointsFrustum[ 5 ].z = farZ;
			pointsFrustum[ 6 ].z = farZ;
			pointsFrustum[ 7 ].z = farZ;
	
		}
	
		// Fit shadow camera's ortho frustum to camera frustum
	
		function updateShadowCamera( camera, light ) {
	
			var shadowCamera = light.shadowCamera,
				pointsFrustum = light.pointsFrustum,
				pointsWorld = light.pointsWorld;
	
			_min.set( Infinity, Infinity, Infinity );
			_max.set( - Infinity, - Infinity, - Infinity );
	
			for ( var i = 0; i < 8; i ++ ) {
	
				var p = pointsWorld[ i ];
	
				p.copy( pointsFrustum[ i ] );
				p.unproject( camera );
	
				p.applyMatrix4( shadowCamera.matrixWorldInverse );
	
				if ( p.x < _min.x ) _min.x = p.x;
				if ( p.x > _max.x ) _max.x = p.x;
	
				if ( p.y < _min.y ) _min.y = p.y;
				if ( p.y > _max.y ) _max.y = p.y;
	
				if ( p.z < _min.z ) _min.z = p.z;
				if ( p.z > _max.z ) _max.z = p.z;
	
			}
	
			shadowCamera.left = _min.x;
			shadowCamera.right = _max.x;
			shadowCamera.top = _max.y;
			shadowCamera.bottom = _min.y;
	
			// can't really fit near/far
			//shadowCamera.near = _min.z;
			//shadowCamera.far = _max.z;
	
			shadowCamera.updateProjectionMatrix();
	
		}
	
		// For the moment just ignore objects that have multiple materials with different animation methods
		// Only the first material will be taken into account for deciding which depth material to use for shadow maps
	
		function getObjectMaterial( object ) {
	
			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ 0 ]
				: object.material;
	
		};
	
	};
	
	// File:src/renderers/webgl/plugins/SpritePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpritePlugin = function ( renderer, sprites ) {
	
		var gl = renderer.context;
	
		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
	
		var texture;
	
		// decompose matrixWorld
	
		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();
	
		var init = function () {
	
			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			program = createProgram();
	
			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};
	
			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),
	
				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),
	
				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),
	
				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),
	
				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),
	
				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;
	
			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );
	
			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;
	
		};
	
		this.render = function ( scene, camera ) {
	
			if ( sprites.length === 0 ) return;
	
			// setup gl
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			gl.enableVertexAttribArray( attributes.position );
			gl.enableVertexAttribArray( attributes.uv );
	
			gl.disable( gl.CULL_FACE );
			gl.enable( gl.BLEND );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
			gl.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );
	
			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;
	
			if ( fog ) {
	
				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
				if ( fog instanceof THREE.Fog ) {
	
					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );
	
					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;
	
				} else if ( fog instanceof THREE.FogExp2 ) {
	
					gl.uniform1f( uniforms.fogDensity, fog.density );
	
					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;
	
				}
	
			} else {
	
				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;
	
			}
	
	
			// update positions and sort
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
	
				sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite._modelViewMatrix.elements[ 14 ];
	
			}
	
			sprites.sort( painterSortStable );
	
			// render all sprites
	
			var scale = [];
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
				var material = sprite.material;
	
				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );
	
				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
	
				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;
	
				var fogType = 0;
	
				if ( scene.fog && material.fog ) {
	
					fogType = sceneFogType;
	
				}
	
				if ( oldFogType !== fogType ) {
	
					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;
	
				}
	
				if ( material.map !== null ) {
	
					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
				} else {
	
					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );
	
				}
	
				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );
	
				renderer.state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				renderer.state.setDepthTest( material.depthTest );
				renderer.state.setDepthWrite( material.depthWrite );
	
				if ( material.map && material.map.image && material.map.image.width ) {
	
					renderer.setTexture( material.map, 0 );
	
				} else {
	
					renderer.setTexture( texture, 0 );
	
				}
	
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
			}
	
			// restore gl
	
			gl.enable( gl.CULL_FACE );
	
			renderer.resetGLState();
	
		};
	
		function createProgram () {
	
			var program = gl.createProgram();
	
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
	
			gl.shaderSource( vertexShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',
	
				'attribute vec2 position;',
				'attribute vec2 uv;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vUV = uvOffset + uv * uvScale;',
	
					'vec2 alignedPosition = position * scale;',
	
					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
					'vec4 finalPosition;',
	
					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',
	
					'gl_Position = finalPosition;',
	
				'}'
	
			].join( '\n' ) );
	
			gl.shaderSource( fragmentShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',
	
				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vec4 texture = texture2D( map, vUV );',
	
					'if ( texture.a < alphaTest ) discard;',
	
					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
					'if ( fogType > 0 ) {',
	
						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',
	
						'if ( fogType == 1 ) {',
	
							'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
						'} else {',
	
							'const float LOG2 = 1.442695;',
							'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
						'}',
	
						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
					'}',
	
				'}'
	
			].join( '\n' ) );
	
			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );
	
			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );
	
			gl.linkProgram( program );
	
			return program;
	
		};
	
		function painterSortStable ( a, b ) {
	
			if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return b.id - a.id;
	
			}
	
		};
	
	};
	
	// File:src/extras/GeometryUtils.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.GeometryUtils = {
	
		merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
			THREE.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
	
			var matrix;
	
			if ( geometry2 instanceof THREE.Mesh ) {
	
				geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;
	
			}
	
			geometry1.merge( geometry2, matrix, materialIndexOffset );
	
		},
	
		center: function ( geometry ) {
	
			THREE.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();
	
		}
	
	};
	
	// File:src/extras/ImageUtils.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Daosheng Mu / https://github.com/DaoshengMu/
	 */
	
	THREE.ImageUtils = {
	
		crossOrigin: undefined,
	
		loadTexture: function ( url, mapping, onLoad, onError ) {
	
			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;
	
			var texture = new THREE.Texture( undefined, mapping );
	
			loader.load( url, function ( image ) {
	
				texture.image = image;
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture );
	
			}, undefined, function ( event ) {
	
				if ( onError ) onError( event );
	
			} );
	
			texture.sourceFile = url;
	
			return texture;
	
		},
	
		loadTextureCube: function ( array, mapping, onLoad, onError ) {
	
			var images = [];
	
			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;
	
			var texture = new THREE.CubeTexture( images, mapping );
	
			// no flipping needed for cube textures
	
			texture.flipY = false;
	
			var loaded = 0;
	
			var loadTexture = function ( i ) {
	
				loader.load( array[ i ], function ( image ) {
	
					texture.images[ i ] = image;
	
					loaded += 1;
	
					if ( loaded === 6 ) {
	
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, undefined, onError );
	
			}
	
			for ( var i = 0, il = array.length; i < il; ++ i ) {
	
				loadTexture( i );
	
			}
	
			return texture;
	
		},
	
		loadCompressedTexture: function () {
	
			THREE.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )
	
		},
	
		loadCompressedTextureCube: function () {
	
			THREE.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )
	
		},
	
		getNormalMap: function ( image, depth ) {
	
			// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/
	
			var cross = function ( a, b ) {
	
				return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];
	
			}
	
			var subtract = function ( a, b ) {
	
				return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];
	
			}
	
			var normalize = function ( a ) {
	
				var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
				return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];
	
			}
	
			depth = depth | 1;
	
			var width = image.width;
			var height = image.height;
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = width;
			canvas.height = height;
	
			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0 );
	
			var data = context.getImageData( 0, 0, width, height ).data;
			var imageData = context.createImageData( width, height );
			var output = imageData.data;
	
			for ( var x = 0; x < width; x ++ ) {
	
				for ( var y = 0; y < height; y ++ ) {
	
					var ly = y - 1 < 0 ? 0 : y - 1;
					var uy = y + 1 > height - 1 ? height - 1 : y + 1;
					var lx = x - 1 < 0 ? 0 : x - 1;
					var ux = x + 1 > width - 1 ? width - 1 : x + 1;
	
					var points = [];
					var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
					points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );
	
					var normals = [];
					var num_points = points.length;
	
					for ( var i = 0; i < num_points; i ++ ) {
	
						var v1 = points[ i ];
						var v2 = points[ ( i + 1 ) % num_points ];
						v1 = subtract( v1, origin );
						v2 = subtract( v2, origin );
						normals.push( normalize( cross( v1, v2 ) ) );
	
					}
	
					var normal = [ 0, 0, 0 ];
	
					for ( var i = 0; i < normals.length; i ++ ) {
	
						normal[ 0 ] += normals[ i ][ 0 ];
						normal[ 1 ] += normals[ i ][ 1 ];
						normal[ 2 ] += normals[ i ][ 2 ];
	
					}
	
					normal[ 0 ] /= normals.length;
					normal[ 1 ] /= normals.length;
					normal[ 2 ] /= normals.length;
	
					var idx = ( y * width + x ) * 4;
	
					output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
					output[ idx + 3 ] = 255;
	
				}
	
			}
	
			context.putImageData( imageData, 0, 0 );
	
			return canvas;
	
		},
	
		generateDataTexture: function ( width, height, color ) {
	
			var size = width * height;
			var data = new Uint8Array( 3 * size );
	
			var r = Math.floor( color.r * 255 );
			var g = Math.floor( color.g * 255 );
			var b = Math.floor( color.b * 255 );
	
			for ( var i = 0; i < size; i ++ ) {
	
				data[ i * 3 ] 	   = r;
				data[ i * 3 + 1 ] = g;
				data[ i * 3 + 2 ] = b;
	
			}
	
			var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
			texture.needsUpdate = true;
	
			return texture;
	
		}
	
	};
	
	// File:src/extras/SceneUtils.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SceneUtils = {
	
		createMultiMaterialObject: function ( geometry, materials ) {
	
			var group = new THREE.Object3D();
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				group.add( new THREE.Mesh( geometry, materials[ i ] ) );
	
			}
	
			return group;
	
		},
	
		detach: function ( child, parent, scene ) {
	
			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );
	
		},
	
		attach: function ( child, scene, parent ) {
	
			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );
	
			scene.remove( child );
			parent.add( child );
	
		}
	
	};
	
	// File:src/extras/FontUtils.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For Text operations in three.js (See TextGeometry)
	 *
	 * It uses techniques used in:
	 *
	 * 	typeface.js and canvastext
	 * 		For converting fonts and rendering with javascript
	 *		http://typeface.neocracy.org
	 *
	 *	Triangulation ported from AS3
	 *		Simple Polygon Triangulation
	 *		http://actionsnippet.com/?p=1462
	 *
	 * 	A Method to triangulate shapes with holes
	 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
	 *
	 */
	
	THREE.FontUtils = {
	
		faces: {},
	
		// Just for now. face[weight][style]
	
		face: 'helvetiker',
		weight: 'normal',
		style: 'normal',
		size: 150,
		divisions: 10,
	
		getFace: function () {
	
			try {
	
				return this.faces[ this.face ][ this.weight ][ this.style ];
	
			} catch (e) {
	
				throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."
	
			};
	
		},
	
		loadFace: function ( data ) {
	
			var family = data.familyName.toLowerCase();
	
			var ThreeFont = this;
	
			ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};
	
			ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;
	
			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;
	
			return data;
	
		},
	
		drawText: function ( text ) {
	
			// RenderText
	
			var i,
				face = this.getFace(),
				scale = this.size / face.resolution,
				offset = 0,
				chars = String( text ).split( '' ),
				length = chars.length;
	
			var fontPaths = [];
	
			for ( i = 0; i < length; i ++ ) {
	
				var path = new THREE.Path();
	
				var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
				offset += ret.offset;
	
				fontPaths.push( ret.path );
	
			}
	
			// get the width
	
			var width = offset / 2;
			//
			// for ( p = 0; p < allPts.length; p++ ) {
			//
			// 	allPts[ p ].x -= width;
			//
			// }
	
			//var extract = this.extractPoints( allPts, characterPts );
			//extract.contour = allPts;
	
			//extract.paths = fontPaths;
			//extract.offset = width;
	
			return { paths: fontPaths, offset: width };
	
		},
	
	
	
	
		extractGlyphPoints: function ( c, face, scale, offset, path ) {
	
			var pts = [];
	
			var i, i2, divisions,
				outline, action, length,
				scaleX, scaleY,
				x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
				laste,
				glyph = face.glyphs[ c ] || face.glyphs[ '?' ];
	
			if ( ! glyph ) return;
	
			if ( glyph.o ) {
	
				outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
				length = outline.length;
	
				scaleX = scale;
				scaleY = scale;
	
				for ( i = 0; i < length; ) {
	
					action = outline[ i ++ ];
	
					//console.log( action );
	
					switch ( action ) {
	
					case 'm':
	
						// Move To
	
						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;
	
						path.moveTo( x, y );
						break;
	
					case 'l':
	
						// Line To
	
						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;
						path.lineTo( x, y );
						break;
	
					case 'q':
	
						// QuadraticCurveTo
	
						cpx  = outline[ i ++ ] * scaleX + offset;
						cpy  = outline[ i ++ ] * scaleY;
						cpx1 = outline[ i ++ ] * scaleX + offset;
						cpy1 = outline[ i ++ ] * scaleY;
	
						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
	
						laste = pts[ pts.length - 1 ];
	
						if ( laste ) {
	
							cpx0 = laste.x;
							cpy0 = laste.y;
	
							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {
	
								var t = i2 / divisions;
								THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
								THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
							}
	
						}
	
						break;
	
					case 'b':
	
						// Cubic Bezier Curve
	
						cpx  = outline[ i ++ ] *  scaleX + offset;
						cpy  = outline[ i ++ ] *  scaleY;
						cpx1 = outline[ i ++ ] *  scaleX + offset;
						cpy1 = outline[ i ++ ] *  scaleY;
						cpx2 = outline[ i ++ ] *  scaleX + offset;
						cpy2 = outline[ i ++ ] *  scaleY;
	
						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
	
						laste = pts[ pts.length - 1 ];
	
						if ( laste ) {
	
							cpx0 = laste.x;
							cpy0 = laste.y;
	
							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {
	
								var t = i2 / divisions;
								THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
								THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );
	
							}
	
						}
	
						break;
	
					}
	
				}
			}
	
	
	
			return { offset: glyph.ha * scale, path:path };
		}
	
	};
	
	
	THREE.FontUtils.generateShapes = function ( text, parameters ) {
	
		// Parameters 
	
		parameters = parameters || {};
	
		var size = parameters.size !== undefined ? parameters.size : 100;
		var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;
	
		var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
		var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
		var style = parameters.style !== undefined ? parameters.style : 'normal';
	
		THREE.FontUtils.size = size;
		THREE.FontUtils.divisions = curveSegments;
	
		THREE.FontUtils.face = font;
		THREE.FontUtils.weight = weight;
		THREE.FontUtils.style = style;
	
		// Get a Font data json object
	
		var data = THREE.FontUtils.drawText( text );
	
		var paths = data.paths;
		var shapes = [];
	
		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
		}
	
		return shapes;
	
	};
	
	
	/**
	 * This code is a quick port of code written in C++ which was submitted to
	 * flipcode.com by John W. Ratcliff  // July 22, 2000
	 * See original code and more information here:
	 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
	 *
	 * ported to actionscript by Zevan Rosser
	 * www.actionsnippet.com
	 *
	 * ported to javascript by Joshua Koo
	 * http://www.lab4games.net/zz85/blog
	 *
	 */
	
	
	( function ( namespace ) {
	
		var EPSILON = 0.0000000001;
	
		// takes in an contour array and returns
	
		var process = function ( contour, indices ) {
	
			var n = contour.length;
	
			if ( n < 3 ) return null;
	
			var result = [],
				verts = [],
				vertIndices = [];
	
			/* we want a counter-clockwise polygon in verts */
	
			var u, v, w;
	
			if ( area( contour ) > 0.0 ) {
	
				for ( v = 0; v < n; v ++ ) verts[ v ] = v;
	
			} else {
	
				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
	
			}
	
			var nv = n;
	
			/*  remove nv - 2 vertices, creating 1 triangle every time */
	
			var count = 2 * nv;   /* error detection */
	
			for ( v = nv - 1; nv > 2; ) {
	
				/* if we loop, it is probably a non-simple polygon */
	
				if ( ( count -- ) <= 0 ) {
	
					//** Triangulate: ERROR - probable bad polygon!
	
					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					THREE.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );
	
					if ( indices ) return vertIndices;
					return result;
	
				}
	
				/* three consecutive vertices in current polygon, <u,v,w> */
	
				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
				if ( snip( contour, u, v, w, nv, verts ) ) {
	
					var a, b, c, s, t;
	
					/* true names of the vertices */
	
					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];
	
					/* output Triangle */
	
					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );
	
	
					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
					/* remove v from the remaining polygon */
	
					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
	
						verts[ s ] = verts[ t ];
	
					}
	
					nv --;
	
					/* reset error detection counter */
	
					count = 2 * nv;
	
				}
	
			}
	
			if ( indices ) return vertIndices;
			return result;
	
		};
	
		// calculate area of the contour polygon
	
		var area = function ( contour ) {
	
			var n = contour.length;
			var a = 0.0;
	
			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
			}
	
			return a * 0.5;
	
		};
	
		var snip = function ( contour, u, v, w, n, verts ) {
	
			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;
	
			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;
	
			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;
	
			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;
	
			if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;
	
			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;
	
			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;
	
			for ( p = 0; p < n; p ++ ) {
	
				px = contour[ verts[ p ] ].x
				py = contour[ verts[ p ] ].y
	
				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;
	
				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;
	
				// see if p is inside triangle abc
	
				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;
	
				if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;
	
			}
	
			return true;
	
		};
	
	
		namespace.Triangulate = process;
		namespace.Triangulate.area = area;
	
		return namespace;
	
	} )( THREE.FontUtils );
	
	// To use the typeface.js face files, hook up the API
	self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
	THREE.typeface_js = self._typeface_js;
	
	// File:src/extras/audio/Audio.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Audio = function ( listener ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Audio';
	
		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind(this);
	
		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );
	
		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );
	
		this.autoplay = false;
	
		this.startTime = 0;
		this.isPlaying = false;
	
	};
	
	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Audio.prototype.constructor = THREE.Audio;
	
	THREE.Audio.prototype.load = function ( file ) {
	
		var scope = this;
	
		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {
	
			scope.context.decodeAudioData( this.response, function ( buffer ) {
	
				scope.source.buffer = buffer;
	
				if( scope.autoplay ) scope.play();
	
			} );
	
		};
		request.send();
	
		return this;
	
	};
	
	THREE.Audio.prototype.play = function () {
	
		if ( this.isPlaying === true ) {
	
			THREE.warn( 'THREE.Audio: Audio is already playing.' );
			return;
	
		}
	
		var source = this.context.createBufferSource();
	
		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.connect( this.panner );
		source.start( 0, this.startTime );
	
		this.isPlaying = true;
	
		this.source = source;
	
	};
	
	THREE.Audio.prototype.pause = function () {
	
		this.source.stop();
		this.startTime = this.context.currentTime;
	
	};
	
	THREE.Audio.prototype.stop = function () {
	
		this.source.stop();
		this.startTime = 0;
	
	};
	
	THREE.Audio.prototype.onEnded = function() {
	
		this.isPlaying = false;
	
	};
	
	THREE.Audio.prototype.setLoop = function ( value ) {
	
		this.source.loop = value;
	
	};
	
	THREE.Audio.prototype.setRefDistance = function ( value ) {
	
		this.panner.refDistance = value;
	
	};
	
	THREE.Audio.prototype.setRolloffFactor = function ( value ) {
	
		this.panner.rolloffFactor = value;
	
	};
	
	THREE.Audio.prototype.setVolume = function ( value ) {
	
		this.gain.gain.value = value;
	
	};
	
	THREE.Audio.prototype.updateMatrixWorld = ( function () {
	
		var position = new THREE.Vector3();
	
		return function ( force ) {
	
			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
			position.setFromMatrixPosition( this.matrixWorld );
	
			this.panner.setPosition( position.x, position.y, position.z );
	
		};
	
	} )();
	
	// File:src/extras/audio/AudioListener.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioListener = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'AudioListener';
	
		this.context = new ( window.AudioContext || window.webkitAudioContext )();
	
	};
	
	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
	THREE.AudioListener.prototype.constructor = THREE.AudioListener;
	
	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {
	
		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();
	
		var orientation = new THREE.Vector3();
		var velocity = new THREE.Vector3();
	
		var positionPrev = new THREE.Vector3();
	
		return function ( force ) {
	
			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
			var listener = this.context.listener;
			var up = this.up;
	
			this.matrixWorld.decompose( position, quaternion, scale );
	
			orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );
			velocity.subVectors( position, positionPrev );
	
			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
			listener.setVelocity( velocity.x, velocity.y, velocity.z );
	
			positionPrev.copy( position );
	
		};
	
	} )();
	
	// File:src/extras/core/Curve.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/
	
	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/
	
	THREE.Curve = function () {
	
	};
	
	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]
	
	THREE.Curve.prototype.getPoint = function ( t ) {
	
		THREE.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;
	
	};
	
	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]
	
	THREE.Curve.prototype.getPointAt = function ( u ) {
	
		var t = this.getUtoTmapping( u );
		return this.getPoint( t );
	
	};
	
	// Get sequence of points using getPoint( t )
	
	THREE.Curve.prototype.getPoints = function ( divisions ) {
	
		if ( ! divisions ) divisions = 5;
	
		var d, pts = [];
	
		for ( d = 0; d <= divisions; d ++ ) {
	
			pts.push( this.getPoint( d / divisions ) );
	
		}
	
		return pts;
	
	};
	
	// Get sequence of points using getPointAt( u )
	
	THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {
	
		if ( ! divisions ) divisions = 5;
	
		var d, pts = [];
	
		for ( d = 0; d <= divisions; d ++ ) {
	
			pts.push( this.getPointAt( d / divisions ) );
	
		}
	
		return pts;
	
	};
	
	// Get total curve arc length
	
	THREE.Curve.prototype.getLength = function () {
	
		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];
	
	};
	
	// Get list of cumulative segment lengths
	
	THREE.Curve.prototype.getLengths = function ( divisions ) {
	
		if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
	
		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length == divisions + 1 )
			&& ! this.needsUpdate) {
	
			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;
	
		}
	
		this.needsUpdate = false;
	
		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;
	
		cache.push( 0 );
	
		for ( p = 1; p <= divisions; p ++ ) {
	
			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;
	
		}
	
		this.cacheArcLengths = cache;
	
		return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
	};
	
	
	THREE.Curve.prototype.updateArcLengths = function() {
		this.needsUpdate = true;
		this.getLengths();
	};
	
	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance
	
	THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {
	
		var arcLengths = this.getLengths();
	
		var i = 0, il = arcLengths.length;
	
		var targetArcLength; // The targeted u distance value to get
	
		if ( distance ) {
	
			targetArcLength = distance;
	
		} else {
	
			targetArcLength = u * arcLengths[ il - 1 ];
	
		}
	
		//var time = Date.now();
	
		// binary search for the index with largest value smaller than target u distance
	
		var low = 0, high = il - 1, comparison;
	
		while ( low <= high ) {
	
			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
			comparison = arcLengths[ i ] - targetArcLength;
	
			if ( comparison < 0 ) {
	
				low = i + 1;
	
			} else if ( comparison > 0 ) {
	
				high = i - 1;
	
			} else {
	
				high = i;
				break;
	
				// DONE
	
			}
	
		}
	
		i = high;
	
		//console.log('b' , i, low, high, Date.now()- time);
	
		if ( arcLengths[ i ] == targetArcLength ) {
	
			var t = i / ( il - 1 );
			return t;
	
		}
	
		// we could get finer grain at lengths, or use simple interpolatation between two points
	
		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];
	
		var segmentLength = lengthAfter - lengthBefore;
	
	    // determine where we are between the 'before' and 'after' points
	
		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
	    // add that fractional amount to t
	
		var t = ( i + segmentFraction ) / ( il - 1 );
	
		return t;
	
	};
	
	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation
	
	THREE.Curve.prototype.getTangent = function( t ) {
	
		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;
	
		// Capping in case of danger
	
		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;
	
		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );
	
		var vec = pt2.clone().sub(pt1);
		return vec.normalize();
	
	};
	
	
	THREE.Curve.prototype.getTangentAt = function ( u ) {
	
		var t = this.getUtoTmapping( u );
		return this.getTangent( t );
	
	};
	
	
	
	
	
	/**************************************************************
	 *	Utils
	 **************************************************************/
	
	THREE.Curve.Utils = {
	
		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {
	
			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
	
		},
	
		// Puay Bing, thanks for helping with this derivative!
	
		tangentCubicBezier: function (t, p0, p1, p2, p3 ) {
	
			return - 3 * p0 * (1 - t) * (1 - t)  +
				3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
				6 * t *  p2 * (1 - t) - 3 * t * t * p2 +
				3 * t * t * p3;
	
		},
	
		tangentSpline: function ( t, p0, p1, p2, p3 ) {
	
			// To check if my formulas are correct
	
			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 âˆ’ 3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3 âˆ’ 2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	// âˆ’ 2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3 âˆ’ t2
	
			return h00 + h10 + h01 + h11;
	
		},
	
		// Catmull-Rom
	
		interpolate: function( p0, p1, p2, p3, t ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	
	// TODO: Transformation for Curves?
	
	/**************************************************************
	 *	3D Curves
	 **************************************************************/
	
	// A Factory method for creating new curve subclasses
	
	THREE.Curve.create = function ( constructor, getPointFunc ) {
	
		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;
	
		return constructor;
	
	};
	
	// File:src/extras/core/CurvePath.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/
	
	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	
	THREE.CurvePath = function () {
	
		this.curves = [];
		this.bends = [];
		
		this.autoClose = false; // Automatically closes the path
	};
	
	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	THREE.CurvePath.prototype.constructor = THREE.CurvePath;
	
	THREE.CurvePath.prototype.add = function ( curve ) {
	
		this.curves.push( curve );
	
	};
	
	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};
	
	THREE.CurvePath.prototype.closePath = function() {
		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[0].getPoint(0);
		var endPoint = this.curves[this.curves.length - 1].getPoint(1);
		
		if (! startPoint.equals(endPoint)) {
			this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
		}
		
	};
	
	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:
	
	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')
	
	THREE.CurvePath.prototype.getPoint = function( t ) {
	
		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0, diff, curve;
	
		// To think about boundaries points.
	
		while ( i < curveLengths.length ) {
	
			if ( curveLengths[ i ] >= d ) {
	
				diff = curveLengths[ i ] - d;
				curve = this.curves[ i ];
	
				var u = 1 - diff / curve.getLength();
	
				return curve.getPointAt( u );
	
			}
	
			i ++;
	
		}
	
		return null;
	
		// loop where sum != 0, sum > d , sum+1 <d
	
	};
	
	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};*/
	
	
	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength
	
	THREE.CurvePath.prototype.getLength = function() {
	
		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];
	
	};
	
	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.
	
	THREE.CurvePath.prototype.getCurveLengths = function() {
	
		// We use cache values if curves and cache array are same length
	
		if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {
	
			return this.cacheLengths;
	
		};
	
		// Get length of subsurve
		// Push sums into cached array
	
		var lengths = [], sums = 0;
		var i, il = this.curves.length;
	
		for ( i = 0; i < il; i ++ ) {
	
			sums += this.curves[ i ].getLength();
			lengths.push( sums );
	
		}
	
		this.cacheLengths = lengths;
	
		return lengths;
	
	};
	
	
	
	// Returns min and max coordinates
	
	THREE.CurvePath.prototype.getBoundingBox = function () {
	
		var points = this.getPoints();
	
		var maxX, maxY, maxZ;
		var minX, minY, minZ;
	
		maxX = maxY = Number.NEGATIVE_INFINITY;
		minX = minY = Number.POSITIVE_INFINITY;
	
		var p, i, il, sum;
	
		var v3 = points[0] instanceof THREE.Vector3;
	
		sum = v3 ? new THREE.Vector3() : new THREE.Vector2();
	
		for ( i = 0, il = points.length; i < il; i ++ ) {
	
			p = points[ i ];
	
			if ( p.x > maxX ) maxX = p.x;
			else if ( p.x < minX ) minX = p.x;
	
			if ( p.y > maxY ) maxY = p.y;
			else if ( p.y < minY ) minY = p.y;
	
			if ( v3 ) {
	
				if ( p.z > maxZ ) maxZ = p.z;
				else if ( p.z < minZ ) minZ = p.z;
	
			}
	
			sum.add( p );
	
		}
	
		var ret = {
	
			minX: minX,
			minY: minY,
			maxX: maxX,
			maxY: maxY
	
		};
	
		if ( v3 ) {
	
			ret.maxZ = maxZ;
			ret.minZ = minZ;
	
		}
	
		return ret;
	
	};
	
	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/
	
	/// Generate geometry from path points (for Line or Points objects)
	
	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {
	
		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );
	
	};
	
	// Generate geometry from equidistance sampling along the path
	
	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {
	
		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );
	
	};
	
	THREE.CurvePath.prototype.createGeometry = function( points ) {
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0; i < points.length; i ++ ) {
	
			geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );
	
		}
	
		return geometry;
	
	};
	
	
	/**************************************************************
	 *	Bend / Wrap Helper Methods
	 **************************************************************/
	
	// Wrap path / Bend modifiers?
	
	THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {
	
		this.bends.push( bendpath );
	
	};
	
	THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {
	
		var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
		var i, il;
	
		if ( ! bends ) {
	
			bends = this.bends;
	
		}
	
		for ( i = 0, il = bends.length; i < il; i ++ ) {
	
			oldPts = this.getWrapPoints( oldPts, bends[ i ] );
	
		}
	
		return oldPts;
	
	};
	
	THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {
	
		var oldPts = this.getSpacedPoints( segments );
	
		var i, il;
	
		if ( ! bends ) {
	
			bends = this.bends;
	
		}
	
		for ( i = 0, il = bends.length; i < il; i ++ ) {
	
			oldPts = this.getWrapPoints( oldPts, bends[ i ] );
	
		}
	
		return oldPts;
	
	};
	
	// This returns getPoints() bend/wrapped around the contour of a path.
	// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html
	
	THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {
	
		var bounds = this.getBoundingBox();
	
		var i, il, p, oldX, oldY, xNorm;
	
		for ( i = 0, il = oldPts.length; i < il; i ++ ) {
	
			p = oldPts[ i ];
	
			oldX = p.x;
			oldY = p.y;
	
			xNorm = oldX / bounds.maxX;
	
			// If using actual distance, for length > path, requires line extrusions
			//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance
	
			xNorm = path.getUtoTmapping( xNorm, oldX );
	
			// check for out of bounds?
	
			var pathPt = path.getPoint( xNorm );
			var normal = path.getTangent( xNorm );
			normal.set( - normal.y, normal.x ).multiplyScalar( oldY );
	
			p.x = pathPt.x + normal.x;
			p.y = pathPt.y + normal.y;
	
		}
	
		return oldPts;
	
	};
	
	
	// File:src/extras/core/Gyroscope.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Gyroscope = function () {
	
		THREE.Object3D.call( this );
	
	};
	
	THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;
	
	THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {
	
		var translationObject = new THREE.Vector3();
		var quaternionObject = new THREE.Quaternion();
		var scaleObject = new THREE.Vector3();
	
		var translationWorld = new THREE.Vector3();
		var quaternionWorld = new THREE.Quaternion();
		var scaleWorld = new THREE.Vector3();
	
		return function ( force ) {
	
			this.matrixAutoUpdate && this.updateMatrix();
	
			// update matrixWorld
	
			if ( this.matrixWorldNeedsUpdate || force ) {
	
				if ( this.parent ) {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
					this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
					this.matrix.decompose( translationObject, quaternionObject, scaleObject );
	
					this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );
	
	
				} else {
	
					this.matrixWorld.copy( this.matrix );
	
				}
	
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].updateMatrixWorld( force );
	
			}
	
		};
		
	}() );
	
	// File:src/extras/core/Path.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/
	
	THREE.Path = function ( points ) {
	
		THREE.CurvePath.call(this);
	
		this.actions = [];
	
		if ( points ) {
	
			this.fromPoints( points );
	
		}
	
	};
	
	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	THREE.Path.prototype.constructor = THREE.Path;
	
	THREE.PathActions = {
	
		MOVE_TO: 'moveTo',
		LINE_TO: 'lineTo',
		QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
		BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
		CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
		ARC: 'arc',								// Circle
		ELLIPSE: 'ellipse'
	};
	
	// TODO Clean up PATH API
	
	// Create path using straight lines to connect all points
	// - vectors: array of Vector2
	
	THREE.Path.prototype.fromPoints = function ( vectors ) {
	
		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
		for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {
	
			this.lineTo( vectors[ v ].x, vectors[ v ].y );
	
		};
	
	};
	
	// startPath() endPath()?
	
	THREE.Path.prototype.moveTo = function ( x, y ) {
	
		var args = Array.prototype.slice.call( arguments );
		this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.lineTo = function ( x, y ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
													new THREE.Vector2( aCPx, aCPy ),
													new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
												   aCP2x, aCP2y,
												   aX, aY ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCP1x, aCP1y ),
												new THREE.Vector2( aCP2x, aCP2y ),
												new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {
	
		var args = Array.prototype.slice.call( arguments );
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	//---
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );
	
		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );
	
	};
	
	// FUTURE: Change the API or follow canvas API?
	
	THREE.Path.prototype.arc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
	
		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absarc(aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
		this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	 };
	
	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
	
		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
			aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	
	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
	
		var args = Array.prototype.slice.call( arguments );
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
										aStartAngle, aEndAngle, aClockwise );
		this.curves.push( curve );
	
		var lastPoint = curve.getPoint(1);
		args.push(lastPoint.x);
		args.push(lastPoint.y);
	
		this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );
	
	 };
	
	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {
	
		if ( ! divisions ) divisions = 40;
	
		var points = [];
	
		for ( var i = 0; i < divisions; i ++ ) {
	
			points.push( this.getPoint( i / divisions ) );
	
			//if( !this.getPoint( i / divisions ) ) throw "DIE";
	
		}
	
		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }
	
		return points;
	
	};
	
	/* Return an array of vectors based on contour of the path */
	
	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {
	
		if (this.useSpacedPoints) {
			console.log('tata');
			return this.getSpacedPoints( divisions, closedPath );
		}
	
		divisions = divisions || 12;
	
		var points = [];
	
		var i, il, item, action, args;
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, j,
			t, tx, ty;
	
		for ( i = 0, il = this.actions.length; i < il; i ++ ) {
	
			item = this.actions[ i ];
	
			action = item.action;
			args = item.args;
	
			switch ( action ) {
	
			case THREE.PathActions.MOVE_TO:
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case THREE.PathActions.LINE_TO:
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case THREE.PathActions.QUADRATIC_CURVE_TO:
	
				cpx  = args[ 2 ];
				cpy  = args[ 3 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
				for ( j = 1; j <= divisions; j ++ ) {
	
					t = j / divisions;
	
					tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
					ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case THREE.PathActions.BEZIER_CURVE_TO:
	
				cpx  = args[ 4 ];
				cpy  = args[ 5 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
	
				for ( j = 1; j <= divisions; j ++ ) {
	
					t = j / divisions;
	
					tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
					ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case THREE.PathActions.CSPLINE_THRU:
	
				laste = this.actions[ i - 1 ].args;
	
				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];
	
				var n = divisions * args[ 0 ].length;
	
				spts = spts.concat( args[ 0 ] );
	
				var spline = new THREE.SplineCurve( spts );
	
				for ( j = 1; j <= n; j ++ ) {
	
					points.push( spline.getPointAt( j / n ) ) ;
	
				}
	
				break;
	
			case THREE.PathActions.ARC:
	
				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				for ( j = 1; j <= tdivisions; j ++ ) {
	
					t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
				break;
			  
			case THREE.PathActions.ELLIPSE:
	
				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ];
	
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				for ( j = 1; j <= tdivisions; j ++ ) {
	
					t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
				break;
	
			} // end switch
	
		}
	
	
	
		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1];
		var EPSILON = 0.0000000001;
		if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
				 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
			points.splice( points.length - 1, 1);
		if ( closedPath ) {
	
			points.push( points[ 0 ] );
	
		}
	
		return points;
	
	};
	
	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//
	
	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {
	
		function extractSubpaths( inActions ) {
	
			var i, il, item, action, args;
	
			var subPaths = [], lastPath = new THREE.Path();
	
			for ( i = 0, il = inActions.length; i < il; i ++ ) {
	
				item = inActions[ i ];
	
				args = item.args;
				action = item.action;
	
				if ( action == THREE.PathActions.MOVE_TO ) {
	
					if ( lastPath.actions.length != 0 ) {
	
						subPaths.push( lastPath );
						lastPath = new THREE.Path();
	
					}
	
				}
	
				lastPath[ action ].apply( lastPath, args );
	
			}
	
			if ( lastPath.actions.length != 0 ) {
	
				subPaths.push( lastPath );
	
			}
	
			// console.log(subPaths);
	
			return	subPaths;
		}
	
		function toShapesNoHoles( inSubpaths ) {
	
			var shapes = [];
	
			for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {
	
				var tmpPath = inSubpaths[ i ];
	
				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;
	
				shapes.push( tmpShape );
			}
	
			//console.log("shape", shapes);
	
			return shapes;
		};
	
		function isPointInsidePolygon( inPt, inPolygon ) {
			var EPSILON = 0.0000000001;
	
			var polyLen = inPolygon.length;
	
			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];
	
				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
				if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
					if ( edgeDy < 0 ) {
						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
					if ( inPt.y == edgeLowPt.y ) {
						if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!
					} else {
						var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
						if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt
					}
				} else {		// parallel or colinear
					if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
					// egde lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;
				}
			}
	
			return	inside;
		}
	
	
		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length == 0 ) return [];
	
		if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
		var solid, tmpPath, tmpShape, shapes = [];
	
		if ( subPaths.length == 1) {
	
			tmpPath = subPaths[0];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;
	
		}
	
		var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;
	
		// console.log("Holes first", holesFirst);
		
		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;
	
		newShapes[mainIdx] = undefined;
		newShapeHoles[mainIdx] = [];
	
		var i, il;
	
		for ( i = 0, il = subPaths.length; i < il; i ++ ) {
	
			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = THREE.Shape.Utils.isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;
	
			if ( solid ) {
	
				if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx ++;
	
				newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[mainIdx].s.actions = tmpPath.actions;
				newShapes[mainIdx].s.curves = tmpPath.curves;
				
				if ( holesFirst )	mainIdx ++;
				newShapeHoles[mainIdx] = [];
	
				//console.log('cw', i);
	
			} else {
	
				newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );
	
				//console.log('ccw', i);
	
			}
	
		}
	
		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[0] )	return	toShapesNoHoles( subPaths );
	
	
		if ( newShapes.length > 1 ) {
			var ambigious = false;
			var toChange = [];
	
			for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				betterShapeHoles[sIdx] = [];
			}
			for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				var sho = newShapeHoles[sIdx];
				for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
					var ho = sho[hIdx];
					var hole_unassigned = true;
					for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
						if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
							if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {
								hole_unassigned = false;
								betterShapeHoles[s2Idx].push( ho );
							} else {
								ambigious = true;
							}
						}
					}
					if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
				}
			}
			// console.log("ambigious: ", ambigious);
			if ( toChange.length > 0 ) {
				// console.log("to change: ", toChange);
				if (! ambigious)	newShapeHoles = betterShapeHoles;
			}
		}
	
		var tmpHoles, j, jl;
		for ( i = 0, il = newShapes.length; i < il; i ++ ) {
			tmpShape = newShapes[i].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[i];
			for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
				tmpShape.holes.push( tmpHoles[j].h );
			}
		}
	
		//console.log("shape", shapes);
	
		return shapes;
	
	};
	
	// File:src/extras/core/Shape.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/
	
	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
	
	THREE.Shape = function () {
	
		THREE.Path.apply( this, arguments );
		this.holes = [];
	
	};
	
	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	THREE.Shape.prototype.constructor = THREE.Shape;
	
	// Convenience method to return ExtrudeGeometry
	
	THREE.Shape.prototype.extrude = function ( options ) {
	
		var extruded = new THREE.ExtrudeGeometry( this, options );
		return extruded;
	
	};
	
	// Convenience method to return ShapeGeometry
	
	THREE.Shape.prototype.makeGeometry = function ( options ) {
	
		var geometry = new THREE.ShapeGeometry( this, options );
		return geometry;
	
	};
	
	// Get points of holes
	
	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {
	
		var i, il = this.holes.length, holesPts = [];
	
		for ( i = 0; i < il; i ++ ) {
	
			holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );
	
		}
	
		return holesPts;
	
	};
	
	// Get points of holes (spaced by regular distance)
	
	THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {
	
		var i, il = this.holes.length, holesPts = [];
	
		for ( i = 0; i < il; i ++ ) {
	
			holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );
	
		}
	
		return holesPts;
	
	};
	
	
	// Get points of shape and holes (keypoints based on segments parameter)
	
	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {
	
		return {
	
			shape: this.getTransformedPoints( divisions ),
			holes: this.getPointsHoles( divisions )
	
		};
	
	};
	
	THREE.Shape.prototype.extractPoints = function ( divisions ) {
	
		if (this.useSpacedPoints) {
			return this.extractAllSpacedPoints(divisions);
		}
	
		return this.extractAllPoints(divisions);
	
	};
	
	//
	// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
	//
	// 	return {
	//
	// 		shape: this.transform( bend, divisions ),
	// 		holes: this.getPointsHoles( divisions, bend )
	//
	// 	};
	//
	// };
	
	// Get points of shape and holes (spaced by regular distance)
	
	THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {
	
		return {
	
			shape: this.getTransformedSpacedPoints( divisions ),
			holes: this.getSpacedPointsHoles( divisions )
	
		};
	
	};
	
	/**************************************************************
	 *	Utils
	 **************************************************************/
	
	THREE.Shape.Utils = {
	
		triangulateShape: function ( contour, holes ) {
	
			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
				// inOtherPt needs to be colinear to the inSegment
				if ( inSegPt1.x != inSegPt2.x ) {
					if ( inSegPt1.x < inSegPt2.x ) {
						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
					} else {
						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
					}
				} else {
					if ( inSegPt1.y < inSegPt2.y ) {
						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
					} else {
						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
					}
				}
			}
	
			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
				var EPSILON = 0.0000000001;
	
				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	
				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	
				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	
				if ( Math.abs(limit) > EPSILON ) {			// not parallel
	
					var perpSeg2;
					if ( limit > 0 ) {
						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
					} else {
						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
					}
	
					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 == 0 ) {
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
						return [ inSeg1Pt1 ];
					}
					if ( perpSeg2 == limit ) {
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
						return [ inSeg1Pt2 ];
					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 == 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 == limit )	return [ inSeg2Pt2 ];
	
					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
	
				} else {		// parallel or colinear
					if ( ( perpSeg1 != 0 ) ||
						 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];
	
					// they are collinear or degenerate
					var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
					var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {
						if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
							 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
						return [ inSeg1Pt1 ];                 					// they are the same point
					}
					// segment#1  is a single point
					if ( seg1Pt ) {
						if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];
					}
					// segment#2  is a single point
					if ( seg2Pt ) {
						if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];
					}
	
					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if (seg1dx != 0) {		// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
						} else {
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
						} else {
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
						}
					} else {				// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
						} else {
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
						} else {
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
						}
					}
					if ( seg1minVal <= seg2minVal ) {
						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal == seg2minVal )	{
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];
					} else {
						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal == seg2maxVal )	{
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];
					}
				}
			}
	
			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
				// The order of legs is important
	
				var EPSILON = 0.0000000001;
	
				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;
	
				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
	
				if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.
	
					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	
					if ( from2toAngle > 0 ) {				// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
					} else {								// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
					}
				} else {										// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );
				}
			}
	
	
			function removeHoles( contour, holes ) {
	
				var shape = contour.concat(); // work on this shape
				var hole;
	
				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;
	
					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
	
					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
	
					var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
					if (! insideAngle ) {
						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;
					}
	
					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;
	
					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
	
					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
	
					insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
					if (! insideAngle ) {
						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;
					}
	
					return	true;
				}
	
				function intersectsShapeEdge( inShapePt, inHolePt ) {
					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}
	
					return	false;
				}
	
				var indepHoles = [];
	
				function intersectsHoleEdge( inShapePt, inHolePt ) {
					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
						chkHole = holes[indepHoles[ihIdx]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
							if ( intersection.length > 0 )		return	true;
						}
					}
					return	false;
				}
	
				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;
	
				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
					indepHoles.push( h );
	
				}
	
				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {
					counter --;
					if ( counter < 0 ) {
						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;
					}
	
					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
	
						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;
	
						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {
							holeIdx = indepHoles[h];
	
							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[cutKey] !== undefined )			continue;
	
							hole = holes[holeIdx];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
								holePt = hole[ h2 ];
								if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
	
								holeIndex = h2;
								indepHoles.splice(h, 1);
	
								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );
	
								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
								minShapeIndex = shapeIndex;
	
								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );
	
								break;
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found
	
							failedCuts[cutKey] = true;			// remember failure
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found
					}
				}
	
				return shape; 			/* shape with no holes */
			}
	
	
			var i, il, f, face,
				key, index,
				allPointsMap = {};
	
			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
			var allpoints = contour.concat();
	
			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
				Array.prototype.push.apply( allpoints, holes[h] );
	
			}
	
			//console.log( "allpoints",allpoints, allpoints.length );
	
			// prepare all points map
	
			for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
				key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
				if ( allPointsMap[ key ] !== undefined ) {
	
					THREE.warn( "THREE.Shape: Duplicate point", key );
	
				}
	
				allPointsMap[ key ] = i;
	
			}
	
			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );
	
			var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );
	
			// check all face vertices against all points map
	
			for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
				face = triangles[ i ];
	
				for ( f = 0; f < 3; f ++ ) {
	
					key = face[ f ].x + ":" + face[ f ].y;
	
					index = allPointsMap[ key ];
	
					if ( index !== undefined ) {
	
						face[ f ] = index;
	
					}
	
				}
	
			}
	
			return triangles.concat();
	
		},
	
		isClockWise: function ( pts ) {
	
			return THREE.FontUtils.Triangulate.area( pts ) < 0;
	
		},
	
		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve
	
		// Quad Bezier Functions
	
		b2p0: function ( t, p ) {
	
			var k = 1 - t;
			return k * k * p;
	
		},
	
		b2p1: function ( t, p ) {
	
			return 2 * ( 1 - t ) * t * p;
	
		},
	
		b2p2: function ( t, p ) {
	
			return t * t * p;
	
		},
	
		b2: function ( t, p0, p1, p2 ) {
	
			return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );
	
		},
	
		// Cubic Bezier Functions
	
		b3p0: function ( t, p ) {
	
			var k = 1 - t;
			return k * k * k * p;
	
		},
	
		b3p1: function ( t, p ) {
	
			var k = 1 - t;
			return 3 * k * k * t * p;
	
		},
	
		b3p2: function ( t, p ) {
	
			var k = 1 - t;
			return 3 * k * t * t * p;
	
		},
	
		b3p3: function ( t, p ) {
	
			return t * t * t * p;
	
		},
	
		b3: function ( t, p0, p1, p2, p3 ) {
	
			return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );
	
		}
	
	};
	
	
	// File:src/extras/curves/LineCurve.js
	
	/**************************************************************
	 *	Line
	 **************************************************************/
	
	THREE.LineCurve = function ( v1, v2 ) {
	
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;
	
	THREE.LineCurve.prototype.getPoint = function ( t ) {
	
		var point = this.v2.clone().sub(this.v1);
		point.multiplyScalar( t ).add( this.v1 );
	
		return point;
	
	};
	
	// Line curve is linear, so we can overwrite default getPointAt
	
	THREE.LineCurve.prototype.getPointAt = function ( u ) {
	
		return this.getPoint( u );
	
	};
	
	THREE.LineCurve.prototype.getTangent = function( t ) {
	
		var tangent = this.v2.clone().sub(this.v1);
	
		return tangent.normalize();
	
	};
	
	// File:src/extras/curves/QuadraticBezierCurve.js
	
	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/
	
	
	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
	
	
	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
		var vector = new THREE.Vector2();
	
		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
	
		return vector;
	
	};
	
	
	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {
	
		var vector = new THREE.Vector2();
	
		vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );
	
		// returns unit vector
	
		return vector.normalize();
	
	};
	
	// File:src/extras/curves/CubicBezierCurve.js
	
	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/
	
	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	
	};
	
	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
	
	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {
	
		var tx, ty;
	
		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
	
		return new THREE.Vector2( tx, ty );
	
	};
	
	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {
	
		var tx, ty;
	
		tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
	
		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();
	
		return tangent;
	
	};
	
	// File:src/extras/curves/SplineCurve.js
	
	/**************************************************************
	 *	Spline curve
	 **************************************************************/
	
	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {
	
		this.points = ( points == undefined ) ? [] : points;
	
	};
	
	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
	
	THREE.SplineCurve.prototype.getPoint = function ( t ) {
	
		var points = this.points;
		var point = ( points.length - 1 ) * t;
	
		var intPoint = Math.floor( point );
		var weight = point - intPoint;
	
		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]
		var point1 = points[ intPoint ]
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]
	
		var vector = new THREE.Vector2();
	
		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
	
		return vector;
	
	};
	
	// File:src/extras/curves/EllipseCurve.js
	
	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/
	
	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		this.aX = aX;
		this.aY = aY;
	
		this.xRadius = xRadius;
		this.yRadius = yRadius;
	
		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;
	
		this.aClockwise = aClockwise;
	
	};
	
	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
	
	THREE.EllipseCurve.prototype.getPoint = function ( t ) {
	
		var deltaAngle = this.aEndAngle - this.aStartAngle;
	
		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;
	
		var angle;
	
		if ( this.aClockwise === true ) {
	
			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );
	
		} else {
	
			angle = this.aStartAngle + t * deltaAngle;
	
		}
		
		var vector = new THREE.Vector2();
	
		vector.x = this.aX + this.xRadius * Math.cos( angle );
		vector.y = this.aY + this.yRadius * Math.sin( angle );
	
		return vector;
	
	};
	
	// File:src/extras/curves/ArcCurve.js
	
	/**************************************************************
	 *	Arc curve
	 **************************************************************/
	
	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	};
	
	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
	
	// File:src/extras/curves/LineCurve3.js
	
	/**************************************************************
	 *	Line3D
	 **************************************************************/
	
	THREE.LineCurve3 = THREE.Curve.create(
	
		function ( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var vector = new THREE.Vector3();
	
			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );
	
			return vector;
	
		}
	
	);
	
	// File:src/extras/curves/QuadraticBezierCurve3.js
	
	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/
	
	THREE.QuadraticBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var vector = new THREE.Vector3();
	
			vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
			vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
			vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );
	
			return vector;
	
		}
	
	);
	
	// File:src/extras/curves/CubicBezierCurve3.js
	
	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/
	
	THREE.CubicBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		},
	
		function ( t ) {
	
			var vector = new THREE.Vector3();
	
			vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
			vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
			vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );
	
			return vector;
	
		}
	
	);
	
	// File:src/extras/curves/SplineCurve3.js
	
	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/
	
	
	THREE.SplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */) {
	
			this.points = ( points == undefined ) ? [] : points;
	
		},
	
		function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 1 ) * t;
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
			var vector = new THREE.Vector3();
	
			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );
	
			return vector;
	
		}
	
	);
	
	// File:src/extras/curves/ClosedSplineCurve3.js
	
	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/
	
	
	THREE.ClosedSplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */) {
	
			this.points = ( points == undefined ) ? [] : points;
	
		},
	
		function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	
			var point0 = points[ ( intPoint - 1 ) % points.length ];
			var point1 = points[ ( intPoint     ) % points.length ];
			var point2 = points[ ( intPoint + 1 ) % points.length ];
			var point3 = points[ ( intPoint + 2 ) % points.length ];
	
			var vector = new THREE.Vector3();
	
			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );
	
			return vector;
	
		}
	
	);
	
	// File:src/extras/animation/AnimationHandler.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	THREE.AnimationHandler = {
	
		LINEAR: 0,
		CATMULLROM: 1,
		CATMULLROM_FORWARD: 2,
	
		//
	
		add: function () { THREE.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
		get: function () { THREE.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
		remove: function () { THREE.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },
	
		//
	
		animations: [],
	
		init: function ( data ) {
	
			if ( data.initialized === true ) return data;
	
			// loop through all keys
	
			for ( var h = 0; h < data.hierarchy.length; h ++ ) {
	
				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
					// remove minus times
	
					if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {
	
						 data.hierarchy[ h ].keys[ k ].time = 0;
	
					}
	
					// create quaternions
	
					if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
					  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {
	
						var quat = data.hierarchy[ h ].keys[ k ].rot;
						data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );
	
					}
	
				}
	
				// prepare morph target keys
	
				if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {
	
					// get all used
	
					var usedMorphTargets = {};
	
					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {
	
							var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
							usedMorphTargets[ morphTargetName ] = - 1;
	
						}
	
					}
	
					data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;
	
	
					// set all used on all frames
	
					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
						var influences = {};
	
						for ( var morphTargetName in usedMorphTargets ) {
	
							for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {
	
								if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {
	
									influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
									break;
	
								}
	
							}
	
							if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {
	
								influences[ morphTargetName ] = 0;
	
							}
	
						}
	
						data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;
	
					}
	
				}
	
	
				// remove all keys that are on the same time
	
				for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
					if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {
	
						data.hierarchy[ h ].keys.splice( k, 1 );
						k --;
	
					}
	
				}
	
	
				// set index
	
				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
					data.hierarchy[ h ].keys[ k ].index = k;
	
				}
	
			}
	
			data.initialized = true;
	
			return data;
	
		},
	
		parse: function ( root ) {
	
			var parseRecurseHierarchy = function ( root, hierarchy ) {
	
				hierarchy.push( root );
	
				for ( var c = 0; c < root.children.length; c ++ )
					parseRecurseHierarchy( root.children[ c ], hierarchy );
	
			};
	
			// setup hierarchy
	
			var hierarchy = [];
	
			if ( root instanceof THREE.SkinnedMesh ) {
	
				for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {
	
					hierarchy.push( root.skeleton.bones[ b ] );
	
				}
	
			} else {
	
				parseRecurseHierarchy( root, hierarchy );
	
			}
	
			return hierarchy;
	
		},
	
		play: function ( animation ) {
	
			if ( this.animations.indexOf( animation ) === - 1 ) {
	
				this.animations.push( animation );
	
			}
	
		},
	
		stop: function ( animation ) {
	
			var index = this.animations.indexOf( animation );
	
			if ( index !== - 1 ) {
	
				this.animations.splice( index, 1 );
	
			}
	
		},
	
		update: function ( deltaTimeMS ) {
	
			for ( var i = 0; i < this.animations.length; i ++ ) {
	
				this.animations[ i ].resetBlendWeights( );
	
			}
	
			for ( var i = 0; i < this.animations.length; i ++ ) {
	
				this.animations[ i ].update( deltaTimeMS );
	
			}
	
		}
	
	};
	
	// File:src/extras/animation/Animation.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Animation = function ( root, data ) {
	
		this.root = root;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( root );
	
		this.currentTime = 0;
		this.timeScale = 1;
	
		this.isPlaying = false;
		this.loop = true;
		this.weight = 0;
	
		this.interpolationType = THREE.AnimationHandler.LINEAR;
	
	};
	
	THREE.Animation.prototype = {
	
		constructor: THREE.Animation,
	
		keyTypes:  [ "pos", "rot", "scl" ],
	
		play: function ( startTime, weight ) {
	
			this.currentTime = startTime !== undefined ? startTime : 0;
			this.weight = weight !== undefined ? weight : 1;
	
			this.isPlaying = true;
	
			this.reset();
	
			THREE.AnimationHandler.play( this );
	
		},
	
		stop: function() {
	
			this.isPlaying = false;
	
			THREE.AnimationHandler.stop( this );
	
		},
	
		reset: function () {
	
			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {
	
				var object = this.hierarchy[ h ];
	
				if ( object.animationCache === undefined ) {
	
					object.animationCache = {
						animations: {},
						blending: {
							positionWeight: 0.0,
							quaternionWeight: 0.0,
							scaleWeight: 0.0
						}
					};
				}
	
				var name = this.data.name;
				var animations = object.animationCache.animations;
				var animationCache = animations[ name ];
	
				if ( animationCache === undefined ) {
	
					animationCache = {
						prevKey: { pos: 0, rot: 0, scl: 0 },
						nextKey: { pos: 0, rot: 0, scl: 0 },
						originalMatrix: object.matrix
					};
	
					animations[ name ] = animationCache;
	
				}
	
				// Get keys to match our current time
	
				for ( var t = 0; t < 3; t ++ ) {
	
					var type = this.keyTypes[ t ];
	
					var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					var nextKey = this.getNextKeyWith( type, h, 1 );
	
					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {
	
						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );
	
					}
	
					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;
	
				}
	
			}
	
		},
	
		resetBlendWeights: function () {
	
			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {
	
				var object = this.hierarchy[ h ];
				var animationCache = object.animationCache;
	
				if ( animationCache !== undefined ) {
	
					var blending = animationCache.blending;
	
					blending.positionWeight = 0.0;
					blending.quaternionWeight = 0.0;
					blending.scaleWeight = 0.0;
	
				}
	
			}
	
		},
	
		update: ( function() {
	
			var points = [];
			var target = new THREE.Vector3();
			var newVector = new THREE.Vector3();
			var newQuat = new THREE.Quaternion();
	
			// Catmull-Rom spline
	
			var interpolateCatmullRom = function ( points, scale ) {
	
				var c = [], v3 = [],
				point, intPoint, weight, w2, w3,
				pa, pb, pc, pd;
	
				point = ( points.length - 1 ) * scale;
				intPoint = Math.floor( point );
				weight = point - intPoint;
	
				c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
				c[ 1 ] = intPoint;
				c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
				c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
	
				pa = points[ c[ 0 ] ];
				pb = points[ c[ 1 ] ];
				pc = points[ c[ 2 ] ];
				pd = points[ c[ 3 ] ];
	
				w2 = weight * weight;
				w3 = weight * w2;
	
				v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
				v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
				v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );
	
				return v3;
	
			};
	
			var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {
	
				var v0 = ( p2 - p0 ) * 0.5,
					v1 = ( p3 - p1 ) * 0.5;
	
				return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
			};
	
			return function ( delta ) {
	
				if ( this.isPlaying === false ) return;
	
				this.currentTime += delta * this.timeScale;
	
				if ( this.weight === 0 )
					return;
	
				//
	
				var duration = this.data.length;
	
				if ( this.currentTime > duration || this.currentTime < 0 ) {
	
					if ( this.loop ) {
	
						this.currentTime %= duration;
	
						if ( this.currentTime < 0 )
							this.currentTime += duration;
	
						this.reset();
	
					} else {
	
						this.stop();
	
					}
	
				}
	
				for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {
	
					var object = this.hierarchy[ h ];
					var animationCache = object.animationCache.animations[this.data.name];
					var blending = object.animationCache.blending;
	
					// loop through pos/rot/scl
	
					for ( var t = 0; t < 3; t ++ ) {
	
						// get keys
	
						var type    = this.keyTypes[ t ];
						var prevKey = animationCache.prevKey[ type ];
						var nextKey = animationCache.nextKey[ type ];
	
						if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
							( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {
	
							prevKey = this.data.hierarchy[ h ].keys[ 0 ];
							nextKey = this.getNextKeyWith( type, h, 1 );
	
							while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {
	
								prevKey = nextKey;
								nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );
	
							}
	
							animationCache.prevKey[ type ] = prevKey;
							animationCache.nextKey[ type ] = nextKey;
	
						}
	
						var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );
	
						var prevXYZ = prevKey[ type ];
						var nextXYZ = nextKey[ type ];
	
						if ( scale < 0 ) scale = 0;
						if ( scale > 1 ) scale = 1;
	
						// interpolate
	
						if ( type === "pos" ) {
	
							if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {
	
								newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
								newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
								newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
								// blend
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								object.position.lerp( newVector, proportionalWeight );
								blending.positionWeight += this.weight;
	
							} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
										this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
								points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
								points[ 1 ] = prevXYZ;
								points[ 2 ] = nextXYZ;
								points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];
	
								scale = scale * 0.33 + 0.33;
	
								var currentPoint = interpolateCatmullRom( points, scale );
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								blending.positionWeight += this.weight;
	
								// blend
	
								var vector = object.position;
	
								vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
								vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
								vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;
	
								if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
									var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );
	
									target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
									target.sub( vector );
									target.y = 0;
									target.normalize();
	
									var angle = Math.atan2( target.x, target.z );
									object.rotation.set( 0, angle, 0 );
	
								}
	
							}
	
						} else if ( type === "rot" ) {
	
							THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );
	
							// Avoid paying the cost of an additional slerp if we don't have to
							if ( blending.quaternionWeight === 0 ) {
	
								object.quaternion.copy(newQuat);
								blending.quaternionWeight = this.weight;
	
							} else {
	
								var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
								THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
								blending.quaternionWeight += this.weight;
	
							}
	
						} else if ( type === "scl" ) {
	
							newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
							newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
							newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
							var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
							object.scale.lerp( newVector, proportionalWeight );
							blending.scaleWeight += this.weight;
	
						}
	
					}
	
				}
	
				return true;
	
			};
	
		} )(),
	
		getNextKeyWith: function ( type, h, key ) {
	
			var keys = this.data.hierarchy[ h ].keys;
	
			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
				key = key < keys.length - 1 ? key : keys.length - 1;
	
			} else {
	
				key = key % keys.length;
	
			}
	
			for ( ; key < keys.length; key ++ ) {
	
				if ( keys[ key ][ type ] !== undefined ) {
	
					return keys[ key ];
	
				}
	
			}
	
			return this.data.hierarchy[ h ].keys[ 0 ];
	
		},
	
		getPrevKeyWith: function ( type, h, key ) {
	
			var keys = this.data.hierarchy[ h ].keys;
	
			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
				key = key > 0 ? key : 0;
	
			} else {
	
				key = key >= 0 ? key : key + keys.length;
	
			}
	
	
			for ( ; key >= 0; key -- ) {
	
				if ( keys[ key ][ type ] !== undefined ) {
	
					return keys[ key ];
	
				}
	
			}
	
			return this.data.hierarchy[ h ].keys[ keys.length - 1 ];
	
		}
	
	};
	
	// File:src/extras/animation/KeyFrameAnimation.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author khang duong
	 * @author erik kitson
	 */
	
	THREE.KeyFrameAnimation = function ( data ) {
	
		this.root = data.node;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( this.root );
		this.currentTime = 0;
		this.timeScale = 0.001;
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;
	
		// initialize to first keyframes
	
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {
	
			var keys = this.data.hierarchy[h].keys,
				sids = this.data.hierarchy[h].sids,
				obj = this.hierarchy[h];
	
			if ( keys.length && sids ) {
	
				for ( var s = 0; s < sids.length; s ++ ) {
	
					var sid = sids[ s ],
						next = this.getNextKeyWith( sid, h, 0 );
	
					if ( next ) {
	
						next.apply( sid );
	
					}
	
				}
	
				obj.matrixAutoUpdate = false;
				this.data.hierarchy[h].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;
	
			}
	
		}
	
	};
	
	THREE.KeyFrameAnimation.prototype = {
	
		constructor: THREE.KeyFrameAnimation,
	
		play: function ( startTime ) {
	
			this.currentTime = startTime !== undefined ? startTime : 0;
	
			if ( this.isPlaying === false ) {
	
				this.isPlaying = true;
	
				// reset key cache
	
				var h, hl = this.hierarchy.length,
					object,
					node;
	
				for ( h = 0; h < hl; h ++ ) {
	
					object = this.hierarchy[ h ];
					node = this.data.hierarchy[ h ];
	
					if ( node.animationCache === undefined ) {
	
						node.animationCache = {};
						node.animationCache.prevKey = null;
						node.animationCache.nextKey = null;
						node.animationCache.originalMatrix = object.matrix;
	
					}
	
					var keys = this.data.hierarchy[h].keys;
	
					if (keys.length) {
	
						node.animationCache.prevKey = keys[ 0 ];
						node.animationCache.nextKey = keys[ 1 ];
	
						this.startTime = Math.min( keys[0].time, this.startTime );
						this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );
	
					}
	
				}
	
				this.update( 0 );
	
			}
	
			this.isPaused = false;
	
			THREE.AnimationHandler.play( this );
	
		},
	
		stop: function () {
	
			this.isPlaying = false;
			this.isPaused  = false;
	
			THREE.AnimationHandler.stop( this );
	
			// reset JIT matrix and remove cache
	
			for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {
	
				var obj = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];
	
				if ( node.animationCache !== undefined ) {
	
					var original = node.animationCache.originalMatrix;
	
					original.copy( obj.matrix );
					obj.matrix = original;
	
					delete node.animationCache;
	
				}
	
			}
	
		},
	
		update: function ( delta ) {
	
			if ( this.isPlaying === false ) return;
	
			this.currentTime += delta * this.timeScale;
	
			//
	
			var duration = this.data.length;
	
			if ( this.loop === true && this.currentTime > duration ) {
	
				this.currentTime %= duration;
	
			}
	
			this.currentTime = Math.min( this.currentTime, duration );
	
			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {
	
				var object = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];
	
				var keys = node.keys,
					animationCache = node.animationCache;
	
	
				if ( keys.length ) {
	
					var prevKey = animationCache.prevKey;
					var nextKey = animationCache.nextKey;
	
					if ( nextKey.time <= this.currentTime ) {
	
						while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {
	
							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];
	
						}
	
						animationCache.prevKey = prevKey;
						animationCache.nextKey = nextKey;
	
					}
	
					if ( nextKey.time >= this.currentTime ) {
	
						prevKey.interpolate( nextKey, this.currentTime );
	
					} else {
	
						prevKey.interpolate( nextKey, nextKey.time );
	
					}
	
					this.data.hierarchy[ h ].node.updateMatrix();
					object.matrixWorldNeedsUpdate = true;
	
				}
	
			}
	
		},
	
		getNextKeyWith: function ( sid, h, key ) {
	
			var keys = this.data.hierarchy[ h ].keys;
			key = key % keys.length;
	
			for ( ; key < keys.length; key ++ ) {
	
				if ( keys[ key ].hasTarget( sid ) ) {
	
					return keys[ key ];
	
				}
	
			}
	
			return keys[ 0 ];
	
		},
	
		getPrevKeyWith: function ( sid, h, key ) {
	
			var keys = this.data.hierarchy[ h ].keys;
			key = key >= 0 ? key : key + keys.length;
	
			for ( ; key >= 0; key -- ) {
	
				if ( keys[ key ].hasTarget( sid ) ) {
	
					return keys[ key ];
	
				}
	
			}
	
			return keys[ keys.length - 1 ];
	
		}
	
	};
	
	// File:src/extras/animation/MorphAnimation.js
	
	/**
	 * @author mrdoob / http://mrdoob.com
	 * @author willy-vvu / http://willy-vvu.github.io
	 */
	
	THREE.MorphAnimation = function ( mesh ) {
	
		this.mesh = mesh;
		this.frames = mesh.morphTargetInfluences.length;
		this.currentTime = 0;
		this.duration = 1000;
		this.loop = true;
		this.lastFrame = 0;
		this.currentFrame = 0;
	
		this.isPlaying = false;
	
	};
	
	THREE.MorphAnimation.prototype = {
	
		constructor: THREE.MorphAnimation,
	
		play: function () {
	
			this.isPlaying = true;
	
		},
	
		pause: function () {
	
			this.isPlaying = false;
	
		},
	
		update: function ( delta ) {
	
			if ( this.isPlaying === false ) return;
	
			this.currentTime += delta;
	
			if ( this.loop === true && this.currentTime > this.duration ) {
	
				this.currentTime %= this.duration;
	
			}
	
			this.currentTime = Math.min( this.currentTime, this.duration );
	
			var interpolation = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / interpolation );
	
			var influences = this.mesh.morphTargetInfluences;
	
			if ( frame != this.currentFrame ) {
	
				influences[ this.lastFrame ] = 0;
				influences[ this.currentFrame ] = 1;
				influences[ frame ] = 0;
	
				this.lastFrame = this.currentFrame;
				this.currentFrame = frame;
	
			}
	
			influences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
			influences[ this.lastFrame ] = 1 - influences[ frame ];
	
		}
	
	};
	
	// File:src/extras/geometries/BoxGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */
	
	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'BoxGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
	
		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;
	
		var scope = this;
	
		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;
	
		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz
	
		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {
	
			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;
	
			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {
	
				w = 'z';
	
			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {
	
				w = 'y';
				gridY = scope.depthSegments;
	
			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {
	
				w = 'x';
				gridX = scope.depthSegments;
	
			}
	
			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();
	
			normal[ w ] = depth > 0 ? 1 : - 1;
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;
	
					scope.vertices.push( vector );
	
				}
	
			}
	
			for ( iy = 0; iy < gridY; iy ++ ) {
	
				for ( ix = 0; ix < gridX; ix ++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );
	
					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
				}
	
			}
	
		}
	
		this.mergeVertices();
	
	};
	
	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
	
	// File:src/extras/geometries/CircleGeometry.js
	
	/**
	 * @author hughes
	 */
	
	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CircleGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		var i, uvs = [],
		center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );
	
		this.vertices.push(center);
		uvs.push( centerUV );
	
		for ( i = 0; i <= segments; i ++ ) {
	
			var vertex = new THREE.Vector3();
			var segment = thetaStart + i / segments * thetaLength;
	
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );
	
			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );
	
		}
	
		var n = new THREE.Vector3( 0, 0, 1 );
	
		for ( i = 1; i <= segments; i ++ ) {
	
			this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );
	
		}
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
	
	// File:src/extras/geometries/CubeGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		THREE.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );
		return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );
	
	 };
	
	// File:src/extras/geometries/CylinderGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CylinderGeometry';
	
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;
	
		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;
	
		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
	
		var heightHalf = height / 2;
	
		var x, y, vertices = [], uvs = [];
	
		for ( y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
			var uvsRow = [];
	
			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
			for ( x = 0; x <= radialSegments; x ++ ) {
	
				var u = x / radialSegments;
	
				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );
	
				this.vertices.push( vertex );
	
				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );
	
			}
	
			vertices.push( verticesRow );
			uvs.push( uvsRow );
	
		}
	
		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;
	
		for ( x = 0; x < radialSegments; x ++ ) {
	
			if ( radiusTop !== 0 ) {
	
				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();
	
			} else {
	
				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();
	
			}
	
			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();
	
			for ( y = 0; y < heightSegments; y ++ ) {
	
				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];
	
				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();
	
				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();
	
				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );
	
				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );
	
			}
	
		}
	
		// top cap
	
		if ( openEnded === false && radiusTop > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );
	
				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		// bottom cap
	
		if ( openEnded === false && radiusBottom > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ heightSegments ][ x + 1 ];
				var v2 = vertices[ heightSegments ][ x ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );
	
				var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
				var uv2 = uvs[ heightSegments ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
	};
	
	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
	
	// File:src/extras/geometries/ExtrudeGeometry.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  material: <int> // material index for front and back faces
	 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ExtrudeGeometry = function ( shapes, options ) {
	
		if ( typeof( shapes ) === "undefined" ) {
			shapes = [];
			return;
		}
	
		THREE.Geometry.call( this );
	
		this.type = 'ExtrudeGeometry';
	
		shapes = shapes instanceof Array ? shapes : [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides
	
		//this.computeVertexNormals();
	
		//console.log( "took", ( Date.now() - startTime ) );
	
	};
	
	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
	
	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
		var sl = shapes.length;
	
		for ( var s = 0; s < sl; s ++ ) {
			var shape = shapes[ s ];
			this.addShape( shape, options );
		}
	};
	
	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
		var amount = options.amount !== undefined ? options.amount : 100;
	
		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var steps = options.steps !== undefined ? options.steps : 1;
	
		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;
	
		var material = options.material;
		var extrudeMaterial = options.extrudeMaterial;
	
		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
	
		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {
	
			extrudePts = extrudePath.getSpacedPoints( steps );
	
			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion
	
			// SETUP TNB variables
	
			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?
	
			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
	
			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();
	
		}
	
		// Safeguards if bevels are not enabled
	
		if ( ! bevelEnabled ) {
	
			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;
	
		}
	
		// Variables initalization
	
		var ahole, h, hl; // looping of holes
		var scope = this;
	
		var shapesOffset = this.vertices.length;
	
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				if ( THREE.Shape.Utils.isClockWise( ahole ) ) {
	
					holes[ h ] = ahole.reverse();
	
				}
	
			}
	
			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
		}
	
	
		var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );
	
		/* Vertices */
	
		var contour = vertices; // vertices has all points but contour has only points of circumference
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			vertices = vertices.concat( ahole );
	
		}
	
	
		function scalePt2 ( pt, vec, size ) {
	
			if ( ! vec ) THREE.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
			return vec.clone().multiplyScalar( size ).add( pt );
	
		}
	
		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;
	
	
		// Find directions for point movement
	
	
		function getBevelVec( inPt, inPrev, inNext ) {
	
			var EPSILON = 0.0000000001;
			
			// computes for inPt the corresponding point inPt' on a new contour
			//   shiftet by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.
			
			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt
	
			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html
	
			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
			
			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
			
			// check for colinear edges
			var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
			
			if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
				
				// length of vectors for normalizing
		
				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
				
				// shift adjacent points by unit vectors to the left
		
				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
				
				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
		
				// scaling factor for v_prev to intersection point
		
				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
				// vector from inPt to intersection point
		
				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
		
				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
				if ( v_trans_lensq <= 2 ) {
					return	new THREE.Vector2( v_trans_x, v_trans_y );
				} else {
					shrink_by = Math.sqrt( v_trans_lensq / 2 );
				}
				
			} else {		// handle special case of colinear edges
	
				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > EPSILON ) {
					if ( v_next_x > EPSILON ) { direction_eq = true; }
				} else {
					if ( v_prev_x < - EPSILON ) {
						if ( v_next_x < - EPSILON ) { direction_eq = true; }
					} else {
						if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }
					}
				}
	
				if ( direction_eq ) {
					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );
				} else {
					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );
				}
	
			}
	
			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
		}
	
	
		var contourMovements = [];
	
		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
			if ( j === il ) j = 0;
			if ( k === il ) k = 0;
	
			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)
	
			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
		}
	
		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			oneHoleMovements = [];
	
			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
			}
	
			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );
	
		}
	
	
		// Loop bevelSegments, 1 for the front, 1 for the back
	
		for ( b = 0; b < bevelSegments; b ++ ) {
		//for ( b = bevelSegments; b > 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
	
			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ) ; // curved
			//bs = bevelSize * t ; // linear
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
				v( vert.x, vert.y,  - z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					v( vert.x, vert.y,  - z );
	
				}
	
			}
	
		}
	
		bs = bevelSize;
	
		// Back facing vertices
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
			if ( ! extrudeByPath ) {
	
				v( vert.x, vert.y, 0 );
	
			} else {
	
				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
				normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
				binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);
	
				position2.copy( extrudePts[0] ).add(normal).add(binormal);
	
				v( position2.x, position2.y, position2.z );
	
			}
	
		}
	
		// Add stepped vertices...
		// Including front facing vertices
	
		var s;
	
		for ( s = 1; s <= steps; s ++ ) {
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, amount / steps * s );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
					normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[s] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
		}
	
	
		// Add bevel segments planes
	
		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 ) ;
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y,  amount + z );
	
					} else {
	
						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
					}
	
				}
	
			}
	
		}
	
		/* Faces */
	
		// Top and bottom faces
	
		buildLidFaces();
	
		// Sides faces
	
		buildSideFaces();
	
	
		/////  Internal functions
	
		function buildLidFaces() {
	
			if ( bevelEnabled ) {
	
				var layer = 0 ; // steps + 1
				var offset = vlen * layer;
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
				}
	
				layer = steps + bevelSegments * 2;
				offset = vlen * layer;
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
				}
	
			} else {
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
				}
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
				}
			}
	
		}
	
		// Create faces for the z-sides of the shape
	
		function buildSideFaces() {
	
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );
	
				//, true
				layeroffset += ahole.length;
	
			}
	
		}
	
		function sidewalls( contour, layeroffset ) {
	
			var j, k;
			i = contour.length;
	
			while ( -- i >= 0 ) {
	
				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;
	
				//console.log('b', i,j, i-1, k,vertices.length);
	
				var s = 0, sl = steps  + bevelSegments * 2;
	
				for ( s = 0; s < sl; s ++ ) {
	
					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );
	
					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;
	
					f4( a, b, c, d, contour, s, sl, j, k );
	
				}
			}
	
		}
	
	
		function v( x, y, z ) {
	
			scope.vertices.push( new THREE.Vector3( x, y, z ) );
	
		}
	
		function f3( a, b, c ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
	
			// normal, color, material
			scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
	
			var uvs = uvgen.generateTopUV( scope, a, b, c );
	
			scope.faceVertexUvs[ 0 ].push( uvs );
	
		}
	
		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;
	
			scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
			scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );
	
			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );
	
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.WorldUVGenerator = {
	
		generateTopUV: function ( geometry, indexA, indexB, indexC ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
	
			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];
	
		},
	
		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];
	
			if ( Math.abs( a.y - b.y ) < 0.01 ) {
				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];
			} else {
				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];
			}
		}
	};
	
	// File:src/extras/geometries/ShapeGeometry.js
	
	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ShapeGeometry = function ( shapes, options ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ShapeGeometry';
	
		if ( shapes instanceof Array === false ) shapes = [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
	};
	
	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
	
	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
			this.addShape( shapes[ i ], options );
	
		}
	
		return this;
	
	};
	
	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {
	
		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	
		//
	
		var i, l, hole;
	
		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.Shape.Utils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe...
	
			for ( i = 0, l = holes.length; i < l; i ++ ) {
	
				hole = holes[ i ];
	
				if ( THREE.Shape.Utils.isClockWise( hole ) ) {
	
					holes[ i ] = hole.reverse();
	
				}
	
			}
	
			reverse = false;
	
		}
	
		var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );
	
		// Vertices
	
		var contour = vertices;
	
		for ( i = 0, l = holes.length; i < l; i ++ ) {
	
			hole = holes[ i ];
			vertices = vertices.concat( hole );
	
		}
	
		//
	
		var vert, vlen = vertices.length;
		var face, flen = faces.length;
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = vertices[ i ];
	
			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );
	
		}
	
		for ( i = 0; i < flen; i ++ ) {
	
			face = faces[ i ];
	
			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;
	
			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );
	
		}
	
	};
	
	// File:src/extras/geometries/LatheGeometry.js
	
	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 */
	
	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.
	
	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'LatheGeometry';
	
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
	
		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;
	
		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;
	
		for ( var i = 0, il = segments; i <= il; i ++ ) {
	
			var phi = phiStart + i * inverseSegments * phiLength;
	
			var c = Math.cos( phi ),
				s = Math.sin( phi );
	
			for ( var j = 0, jl = points.length; j < jl; j ++ ) {
	
				var pt = points[ j ];
	
				var vertex = new THREE.Vector3();
	
				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;
	
				this.vertices.push( vertex );
	
			}
	
		}
	
		var np = points.length;
	
		for ( var i = 0, il = segments; i < il; i ++ ) {
	
			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {
	
				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;
	
				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;
	
				this.faces.push( new THREE.Face3( a, b, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
	
			}
	
		}
	
		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
	
	// File:src/extras/geometries/PlaneGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );
	
		THREE.Geometry.call( this );
	
		this.type = 'PlaneGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	
	};
	
	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
	
	// File:src/extras/geometries/PlaneBufferGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'PlaneBufferGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		var width_half = width / 2;
		var height_half = height / 2;
	
		var gridX = widthSegments || 1;
		var gridY = heightSegments || 1;
	
		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;
	
		var segment_width = width / gridX;
		var segment_height = height / gridY;
	
		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );
	
		var offset = 0;
		var offset2 = 0;
	
		for ( var iy = 0; iy < gridY1; iy ++ ) {
	
			var y = iy * segment_height - height_half;
	
			for ( var ix = 0; ix < gridX1; ix ++ ) {
	
				var x = ix * segment_width - width_half;
	
				vertices[ offset     ] = x;
				vertices[ offset + 1 ] = - y;
	
				normals[ offset + 2 ] = 1;
	
				uvs[ offset2     ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );
	
				offset += 3;
				offset2 += 2;
	
			}
	
		}
	
		offset = 0;
	
		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );
	
		for ( var iy = 0; iy < gridY; iy ++ ) {
	
			for ( var ix = 0; ix < gridX; ix ++ ) {
	
				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;
	
				indices[ offset     ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;
	
				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;
	
				offset += 6;
	
			}
	
		}
	
		this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
	};
	
	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
	
	// File:src/extras/geometries/RingGeometry.js
	
	/**
	 * @author Kaleb Murphy
	 */
	
	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'RingGeometry';
	
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;
	
		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	
		for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring
	
			for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle
	
				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
	
				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
			}
	
			radius += radiusStep;
	
		}
	
		var n = new THREE.Vector3( 0, 0, 1 );
	
		for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring
	
			var thetaSegment = i * (thetaSegments + 1);
	
			for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle
	
				var segment = o + thetaSegment;
	
				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);
	
				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);
	
			}
		}
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
	
	
	// File:src/extras/geometries/SphereGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'SphereGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength 
		};
	
		radius = radius || 50;
	
		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
		var x, y, vertices = [], uvs = [];
	
		for ( y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
			var uvsRow = [];
	
			for ( x = 0; x <= widthSegments; x ++ ) {
	
				var u = x / widthSegments;
				var v = y / heightSegments;
	
				var vertex = new THREE.Vector3();
				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
				this.vertices.push( vertex );
	
				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );
	
			}
	
			vertices.push( verticesRow );
			uvs.push( uvsRow );
	
		}
	
		for ( y = 0; y < heightSegments; y ++ ) {
	
			for ( x = 0; x < widthSegments; x ++ ) {
	
				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];
	
				var n1 = this.vertices[ v1 ].clone().normalize();
				var n2 = this.vertices[ v2 ].clone().normalize();
				var n3 = this.vertices[ v3 ].clone().normalize();
				var n4 = this.vertices[ v4 ].clone().normalize();
	
				var uv1 = uvs[ y ][ x + 1 ].clone();
				var uv2 = uvs[ y ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x ].clone();
				var uv4 = uvs[ y + 1 ][ x + 1 ].clone();
	
				if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {
	
					uv1.x = ( uv1.x + uv2.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );
	
				} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {
	
					uv3.x = ( uv3.x + uv4.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
				} else {
	
					this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );
	
					this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );
	
				}
	
			}
	
		}
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
	
	// File:src/extras/geometries/TextGeometry.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For creating 3D text geometry in three.js
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  size: 			<float>, 	// size of the text
	 *  height: 		<float>, 	// thickness to extrude text
	 *  curveSegments: 	<int>,		// number of points on the curves
	 *
	 *  font: 			<string>,		// font name
	 *  weight: 		<string>,		// font weight (normal, bold)
	 *  style: 			<string>,		// font style  (normal, italics)
	 *
	 *  bevelEnabled:	<bool>,			// turn on bevel
	 *  bevelThickness: <float>, 		// how deep into text bevel goes
	 *  bevelSize:		<float>, 		// how far from text outline is bevel
	 *  }
	 *
	 */
	
	/*	Usage Examples
	
		// TextGeometry wrapper
	
		var text3d = new TextGeometry( text, options );
	
		// Complete manner
	
		var textShapes = THREE.FontUtils.generateShapes( text, options );
		var text3d = new ExtrudeGeometry( textShapes, options );
	
	*/
	
	
	THREE.TextGeometry = function ( text, parameters ) {
	
		parameters = parameters || {};
	
		var textShapes = THREE.FontUtils.generateShapes( text, parameters );
	
		// translate parameters to ExtrudeGeometry API
	
		parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
		// defaults
	
		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
		THREE.ExtrudeGeometry.call( this, textShapes, parameters );
	
		this.type = 'TextGeometry';
	
	};
	
	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
	
	// File:src/extras/geometries/TorusGeometry.js
	
	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */
	
	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
	
		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;
	
		var center = new THREE.Vector3(), uvs = [], normals = [];
	
		for ( var j = 0; j <= radialSegments; j ++ ) {
	
			for ( var i = 0; i <= tubularSegments; i ++ ) {
	
				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;
	
				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
	
				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );
	
				this.vertices.push( vertex );
	
				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );
	
			}
	
		}
	
		for ( var j = 1; j <= radialSegments; j ++ ) {
	
			for ( var i = 1; i <= tubularSegments; i ++ ) {
	
				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;
	
				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );
	
				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
	};
	
	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
	
	// File:src/extras/geometries/TorusKnotGeometry.js
	
	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */
	
	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusKnotGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};
	
		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;
		
		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();
	
		for ( var i = 0; i < radialSegments; ++ i ) {
	
			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );
	
			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();
	
			for ( var j = 0; j < tubularSegments; ++ j ) {
	
				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );
	
				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;
	
				grid[ i ][ j ] = this.vertices.push( pos ) - 1;
	
			}
	
		}
	
		for ( var i = 0; i < radialSegments; ++ i ) {
	
			for ( var j = 0; j < tubularSegments; ++ j ) {
	
				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;
	
				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];
	
				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
		}
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
		function getPos( u, in_q, in_p, radius, heightScale ) {
	
			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );
	
			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	};
	
	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
	
	// File:src/extras/geometries/TubeGeometry.js
	
	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */
	
	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TubeGeometry';
	
		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};
	
		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;
	
		var grid = [];
	
		var scope = this,
	
			tangent,
			normal,
			binormal,
	
			numpoints = segments + 1,
	
			u, v, r,
	
			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;
	
		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;
	
		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		function vert( x, y, z ) {
	
			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;
	
		}
	
		// consruct the grid
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			grid[ i ] = [];
	
			u = i / ( numpoints - 1 );
	
			pos = path.getPointAt( u );
	
			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];
	
			r = radius * taper( u );
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				v = j / radialSegments * 2 * Math.PI;
	
				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );
	
				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;
	
				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );
	
			}
		}
	
	
		// construct the mesh
	
		for ( i = 0; i < segments; i ++ ) {
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				ip = ( closed ) ? (i + 1) % segments : i + 1;
				jp = (j + 1) % radialSegments;
	
				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];
	
				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
		}
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
	
	THREE.TubeGeometry.NoTaper = function ( u ) {
	
		return 1;
	
	};
	
	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {
	
		return Math.sin( Math.PI * u );
	
	};
	
	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {
	
		var	normal = new THREE.Vector3(),
	
			tangents = [],
			normals = [],
			binormals = [],
	
			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),
	
			numpoints = segments + 1,
			theta,
			epsilon = 0.0001,
			smallest,
	
			tx, ty, tz,
			i, u;
	
	
		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		// compute the tangent vectors for each segment on the path
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			u = i / ( numpoints - 1 );
	
			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();
	
		}
	
		initialNormal3();
	
		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}
	
		function initialNormal2() {
	
			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );
	
			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );
	
			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	
		}
		*/
	
		function initialNormal3() {
			// select an initial normal vector perpenicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component
	
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );
	
			if ( tx <= smallest ) {
				smallest = tx;
				normal.set( 1, 0, 0 );
			}
	
			if ( ty <= smallest ) {
				smallest = ty;
				normal.set( 0, 1, 0 );
			}
	
			if ( tz <= smallest ) {
				normal.set( 0, 0, 1 );
			}
	
			vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
		}
	
	
		// compute the slowly-varying normal and binormal vectors for each segment on the path
	
		for ( i = 1; i < numpoints; i ++ ) {
	
			normals[ i ] = normals[ i - 1 ].clone();
	
			binormals[ i ] = binormals[ i - 1 ].clone();
	
			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
			if ( vec.length() > epsilon ) {
	
				vec.normalize();
	
				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
			}
	
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
		}
	
	
		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
		if ( closed ) {
	
			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );
	
			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {
	
				theta = - theta;
	
			}
	
			for ( i = 1; i < numpoints; i ++ ) {
	
				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
			}
	
		}
	};
	
	// File:src/extras/geometries/PolyhedronGeometry.js
	
	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'PolyhedronGeometry';
	
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};
	
		radius = radius || 1;
		detail = detail || 0;
	
		var that = this;
	
		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {
	
			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );
	
		}
	
		var p = this.vertices;
	
		var faces = [];
	
		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {
	
			var v1 = p[ indices[ i     ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];
	
			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
	
		}
	
		var centroid = new THREE.Vector3();
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			subdivide( faces[ i ], detail );
	
		}
	
	
		// Handle case when face straddles the seam
	
		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {
	
			var uvs = this.faceVertexUvs[ 0 ][ i ];
	
			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;
	
			var max = Math.max( x0, Math.max( x1, x2 ) );
			var min = Math.min( x0, Math.min( x1, x2 ) );
	
			if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary
	
				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;
	
			}
	
		}
	
	
		// Apply radius
	
		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {
	
			this.vertices[ i ].multiplyScalar( radius );
	
		}
	
	
		// Merge vertices
	
		this.mergeVertices();
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	
		// Project vector onto sphere's surface
	
		function prepare( vector ) {
	
			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;
	
			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.
	
			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );
	
			return vertex;
	
		}
	
	
		// Approximate a curved face with recursively sub-divided triangles.
	
		function make( v1, v2, v3 ) {
	
			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
			that.faces.push( face );
	
			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
	
			var azi = azimuth( centroid );
	
			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );
	
		}
	
	
		// Analytically subdivide a face to the required detail level.
	
		function subdivide( face, detail ) {
	
			var cols = Math.pow(2, detail);
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];
	
			// Construct all of the vertices for this subdivision.
	
			for ( var i = 0 ; i <= cols; i ++ ) {
	
				v[ i ] = [];
	
				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;
	
				for ( var j = 0; j <= rows; j ++) {
	
					if ( j == 0 && i == cols ) {
	
						v[ i ][ j ] = aj;
	
					} else {
	
						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );
	
					}
	
				}
	
			}
	
			// Construct all of the faces.
	
			for ( var i = 0; i < cols ; i ++ ) {
	
				for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {
	
					var k = Math.floor( j / 2 );
	
					if ( j % 2 == 0 ) {
	
						make(
							v[ i ][ k + 1],
							v[ i + 1 ][ k ],
							v[ i ][ k ]
						);
	
					} else {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1][ k + 1],
							v[ i + 1 ][ k ]
						);
	
					}
	
				}
	
			}
	
		}
	
	
		// Angle around the Y axis, counter-clockwise when looking from above.
	
		function azimuth( vector ) {
	
			return Math.atan2( vector.z, - vector.x );
	
		}
	
	
		// Angle above the XZ plane.
	
		function inclination( vector ) {
	
			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
		}
	
	
		// Texture fixing helper. Spheres have some odd behaviours.
	
		function correctUV( uv, vector, azimuth ) {
	
			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();
	
		}
	
	
	};
	
	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
	
	// File:src/extras/geometries/DodecahedronGeometry.js
	
	/**
	 * @author Abe Pazos / https://hamoid.com
	 */
	
	THREE.DodecahedronGeometry = function ( radius, detail ) {
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;
	
		var vertices = [
	
			// (Â±1, Â±1, Â±1)
			-1, -1, -1,    -1, -1,  1,
			-1,  1, -1,    -1,  1,  1,
			 1, -1, -1,     1, -1,  1,
			 1,  1, -1,     1,  1,  1,
	
			// (0, Â±1/Ï†, Â±Ï†)
			 0, -r, -t,     0, -r,  t,
			 0,  r, -t,     0,  r,  t,
	
			// (Â±1/Ï†, Â±Ï†, 0)
			-r, -t,  0,    -r,  t,  0,
			 r, -t,  0,     r,  t,  0,
	
			// (Â±Ï†, 0, Â±1/Ï†)
			-t,  0, -r,     t,  0, -r,
			-t,  0,  r,     t,  0,  r
		];
	
		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
	};
	
	THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
	
	// File:src/extras/geometries/IcosahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.IcosahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];
	
		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'IcosahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	};
	
	THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
	
	// File:src/extras/geometries/OctahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.OctahedronGeometry = function ( radius, detail ) {
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
		];
	
		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'OctahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	};
	
	THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
	
	// File:src/extras/geometries/TetrahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.TetrahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];
	
		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'TetrahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
	
	// File:src/extras/geometries/ParametricGeometry.js
	
	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */
	
	THREE.ParametricGeometry = function ( func, slices, stacks ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ParametricGeometry';
	
		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};
	
		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];
	
		var i, j, p;
		var u, v;
	
		var sliceCount = slices + 1;
	
		for ( i = 0; i <= stacks; i ++ ) {
	
			v = i / stacks;
	
			for ( j = 0; j <= slices; j ++ ) {
	
				u = j / slices;
	
				p = func( u, v );
				verts.push( p );
	
			}
		}
	
		var a, b, c, d;
		var uva, uvb, uvc, uvd;
	
		for ( i = 0; i < stacks; i ++ ) {
	
			for ( j = 0; j < slices; j ++ ) {
	
				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = (i + 1) * sliceCount + j + 1;
				d = (i + 1) * sliceCount + j;
	
				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );
	
				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );
	
				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		// console.log(this);
	
		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
	
	// File:src/extras/helpers/AxisHelper.js
	
	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AxisHelper = function ( size ) {
	
		size = size || 1;
	
		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );
	
		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );
	
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		THREE.Line.call( this, geometry, material, THREE.LinePieces );
	
	};
	
	THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
	
	// File:src/extras/helpers/ArrowHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */
	
	THREE.ArrowHelper = ( function () {
	
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );
	
		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
	
		return function ( dir, origin, length, color, headLength, headWidth ) {
	
			// dir is assumed to be normalized
	
			THREE.Object3D.call( this );
	
			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.position.copy( origin );
	
			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
	
			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );
	
			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );
	
		}
	
	}() );
	
	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
	
	THREE.ArrowHelper.prototype.setDirection = ( function () {
	
		var axis = new THREE.Vector3();
		var radians;
	
		return function ( dir ) {
	
			// dir is assumed to be normalized
	
			if ( dir.y > 0.99999 ) {
	
				this.quaternion.set( 0, 0, 0, 1 );
	
			} else if ( dir.y < - 0.99999 ) {
	
				this.quaternion.set( 1, 0, 0, 0 );
	
			} else {
	
				axis.set( dir.z, 0, - dir.x ).normalize();
	
				radians = Math.acos( dir.y );
	
				this.quaternion.setFromAxisAngle( axis, radians );
	
			}
	
		};
	
	}() );
	
	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
		this.line.scale.set( 1, length - headLength, 1 );
		this.line.updateMatrix();
	
		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();
	
	};
	
	THREE.ArrowHelper.prototype.setColor = function ( color ) {
	
		this.line.material.color.set( color );
		this.cone.material.color.set( color );
	
	};
	
	// File:src/extras/helpers/BoxHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BoxHelper = function ( object ) {
	
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );
	
		if ( object !== undefined ) {
	
			this.update( object );
	
		}
	
	};
	
	THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
	
	THREE.BoxHelper.prototype.update = function ( object ) {
	
		var geometry = object.geometry;
	
		if ( geometry.boundingBox === null ) {
	
			geometry.computeBoundingBox();
	
		}
	
		var min = geometry.boundingBox.min;
		var max = geometry.boundingBox.max;
	
		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/
	
		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/
	
		var vertices = this.geometry.attributes.position.array;
	
		vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
		vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;
	
		vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
		vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;
	
		vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
		vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;
	
		vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
		vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;
	
		//
	
		vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
		vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;
	
		vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
		vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;
	
		vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
		vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;
	
		vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
		vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;
	
		//
	
		vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
		vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;
	
		vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
		vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;
	
		vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
		vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;
	
		vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
		vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;
	
		this.geometry.attributes.position.needsUpdate = true;
	
		this.geometry.computeBoundingSphere();
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	// File:src/extras/helpers/BoundingBoxHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	// a helper to show the world-axis-aligned bounding box for an object
	
	THREE.BoundingBoxHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0x888888;
	
		this.object = object;
	
		this.box = new THREE.Box3();
	
		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );
	
	};
	
	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
	
	THREE.BoundingBoxHelper.prototype.update = function () {
	
		this.box.setFromObject( this.object );
	
		this.box.size( this.scale );
	
		this.box.center( this.position );
	
	};
	
	// File:src/extras/helpers/CameraHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */
	
	THREE.CameraHelper = function ( camera ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
	
		var pointMap = {};
	
		// colors
	
		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;
	
		// near
	
		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );
	
		// far
	
		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );
	
		// sides
	
		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );
	
		// cone
	
		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );
	
		// up
	
		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );
	
		// target
	
		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );
	
		// cross
	
		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );
	
		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );
	
		function addLine( a, b, hex ) {
	
			addPoint( a, hex );
			addPoint( b, hex );
	
		}
	
		function addPoint( id, hex ) {
	
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );
	
			if ( pointMap[ id ] === undefined ) {
	
				pointMap[ id ] = [];
	
			}
	
			pointMap[ id ].push( geometry.vertices.length - 1 );
	
		}
	
		THREE.Line.call( this, geometry, material, THREE.LinePieces );
	
		this.camera = camera;
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.pointMap = pointMap;
	
		this.update();
	
	};
	
	THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
	
	THREE.CameraHelper.prototype.update = function () {
	
		var geometry, pointMap;
		
		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();
	
		var setPoint = function ( point, x, y, z ) {
	
			vector.set( x, y, z ).unproject( camera );
	
			var points = pointMap[ point ];
	
			if ( points !== undefined ) {
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					geometry.vertices[ points[ i ] ].copy( vector );
	
				}
	
			}
	
		};
	
		return function () {
	
			geometry = this.geometry;
			pointMap = this.pointMap;
	
			var w = 1, h = 1;
	
			// we need just camera projection matrix
			// world matrix must be identity
	
			camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
			// center / target
	
			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );
	
			// near
	
			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );
	
			// far
	
			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );
	
			// up
	
			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );
	
			// cross
	
			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );
	
			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );
	
			geometry.verticesNeedUpdate = true;
	
		};
	
	}();
	
	// File:src/extras/helpers/DirectionalLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.DirectionalLightHelper = function ( light, size ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		size = size || 1;
	
		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);
	
		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );
	
		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);
	
		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );
	
		this.update();
	
	};
	
	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
	
	THREE.DirectionalLightHelper.prototype.dispose = function () {
	
		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	};
	
	THREE.DirectionalLightHelper.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();
	
		return function () {
	
			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );
	
			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );
	
		};
	
	}();
	
	// File:src/extras/helpers/EdgesHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimim angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */
	
	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
		var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );
	
		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };
	
		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();
	
		var geometry2;
	
		if ( object.geometry instanceof THREE.BufferGeometry ) {
	
			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( object.geometry );
	
		} else {
	
			geometry2 = object.geometry.clone();
	
		}
	
		geometry2.mergeVertices();
		geometry2.computeFaceNormals();
	
		var vertices = geometry2.vertices;
		var faces = geometry2.faces;
		var numEdges = 0;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0; j < 3; j ++ ) {
	
				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );
	
				var key = edge.toString();
	
				if ( hash[ key ] === undefined ) {
	
					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
					numEdges ++;
	
				} else {
	
					hash[ key ].face2 = i;
	
				}
	
			}
	
		}
	
		var coords = new Float32Array( numEdges * 2 * 3 );
	
		var index = 0;
	
		for ( var key in hash ) {
	
			var h = hash[ key ];
	
			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {
	
				var vertex = vertices[ h.vert1 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;
	
				vertex = vertices[ h.vert2 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;
	
			}
	
		}
	
		geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
	
	// File:src/extras/helpers/FaceNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xffff00;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		var geometry = new THREE.Geometry();
	
		var faces = this.object.geometry.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );
	
		}
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );
	
		this.matrixAutoUpdate = false;
	
		this.normalMatrix = new THREE.Matrix3();
	
		this.update();
	
	};
	
	THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
	
	THREE.FaceNormalsHelper.prototype.update = function () {
	
		var vertices = this.geometry.vertices;
	
		var object = this.object;
		var objectVertices = object.geometry.vertices;
		var objectFaces = object.geometry.faces;
		var objectWorldMatrix = object.matrixWorld;
	
		object.updateMatrixWorld( true );
	
		this.normalMatrix.getNormalMatrix( objectWorldMatrix );
	
		for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {
	
			var face = objectFaces[ i ];
	
			vertices[ i2 ].copy( objectVertices[ face.a ] )
				.add( objectVertices[ face.b ] )
				.add( objectVertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( objectWorldMatrix );
	
			vertices[ i2 + 1 ].copy( face.normal )
				.applyMatrix3( this.normalMatrix )
				.normalize()
				.multiplyScalar( this.size )
				.add( vertices[ i2 ] );
	
		}
	
		this.geometry.verticesNeedUpdate = true;
	
		return this;
	
	};
	
	
	// File:src/extras/helpers/GridHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.GridHelper = function ( size, step ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );
	
		for ( var i = - size; i <= size; i += step ) {
	
			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);
	
			var color = i === 0 ? this.color1 : this.color2;
	
			geometry.colors.push( color, color, color, color );
	
		}
	
		THREE.Line.call( this, geometry, material, THREE.LinePieces );
	
	};
	
	THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;
	
	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {
	
		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );
	
		this.geometry.colorsNeedUpdate = true;
	
	}
	
	// File:src/extras/helpers/HemisphereLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.HemisphereLightHelper = function ( light, sphereSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.colors = [ new THREE.Color(), new THREE.Color() ];
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
	
		for ( var i = 0, il = 8; i < il; i ++ ) {
	
			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];
	
		}
	
		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );
	
		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );
	
		this.update();
	
	};
	
	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
	
	THREE.HemisphereLightHelper.prototype.dispose = function () {
		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();
	};
	
	THREE.HemisphereLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
	
		return function () {
	
			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );
	
			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;
	
		}
	
	}();
	
	// File:src/extras/helpers/PointLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PointLightHelper = function ( light, sphereSize ) {
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		THREE.Mesh.call( this, geometry, material );
	
		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
		var d = light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.scale.set( d, d, d );
	
		}
	
		this.add( this.lightDistance );
		*/
	
	};
	
	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
	
	THREE.PointLightHelper.prototype.dispose = function () {
	
		this.geometry.dispose();
		this.material.dispose();
	};
	
	THREE.PointLightHelper.prototype.update = function () {
	
		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		/*
		var d = this.light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
	
		}
		*/
	
	};
	
	// File:src/extras/helpers/SkeletonHelper.js
	
	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkeletonHelper = function ( object ) {
	
		this.bones = this.getBoneList( object );
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );
	
			}
	
		}
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
		THREE.Line.call( this, geometry, material, THREE.LinePieces );
	
		this.root = object;
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	
	THREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
	
	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {
	
		var boneList = [];
	
		if ( object instanceof THREE.Bone ) {
	
			boneList.push( object );
	
		}
	
		for ( var i = 0; i < object.children.length; i ++ ) {
	
			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );
	
		}
	
		return boneList;
	
	};
	
	THREE.SkeletonHelper.prototype.update = function () {
	
		var geometry = this.geometry;
	
		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );
	
		var boneMatrix = new THREE.Matrix4();
	
		var j = 0;
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );
	
				j += 2;
	
			}
	
		}
	
		geometry.verticesNeedUpdate = true;
	
		geometry.computeBoundingSphere();
	
	};
	
	// File:src/extras/helpers/SpotLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.SpotLightHelper = function ( light ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );
	
		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
	
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	
		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );
	
		this.update();
	
	};
	
	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
	
	THREE.SpotLightHelper.prototype.dispose = function () {
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	};
	
	THREE.SpotLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();
	
		return function () {
	
			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );
	
			this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
			this.cone.lookAt( vector2.sub( vector ) );
	
			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		};
	
	}();
	
	// File:src/extras/helpers/VertexNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xff0000;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		var geometry = new THREE.Geometry();
	
		var faces = object.geometry.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
				geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );
	
			}
	
		}
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );
	
		this.matrixAutoUpdate = false;
	
		this.normalMatrix = new THREE.Matrix3();
	
		this.update();
	
	};
	
	THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
	
	THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {
	
		var v1 = new THREE.Vector3();
	
		return function( object ) {
	
			var keys = [ 'a', 'b', 'c', 'd' ];
	
			this.object.updateMatrixWorld( true );
	
			this.normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var vertices = this.geometry.vertices;
	
			var verts = this.object.geometry.vertices;
	
			var faces = this.object.geometry.faces;
	
			var worldMatrix = this.object.matrixWorld;
	
			var idx = 0;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];
	
					var normal = face.vertexNormals[ j ];
	
					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );
	
					v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );
	
					v1.add( vertices[ idx ] );
					idx = idx + 1;
	
					vertices[ idx ].copy( v1 );
					idx = idx + 1;
	
				}
	
			}
	
			this.geometry.verticesNeedUpdate = true;
	
			return this;
	
		}
	
	}());
	
	// File:src/extras/helpers/VertexTangentsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0x0000ff;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		var geometry = new THREE.Geometry();
	
		var faces = object.geometry.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {
	
				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
	
			}
	
		}
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );
	
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;
	
	THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {
	
		var v1 = new THREE.Vector3();
	
		return function( object ) {
	
			var keys = [ 'a', 'b', 'c', 'd' ];
	
			this.object.updateMatrixWorld( true );
	
			var vertices = this.geometry.vertices;
	
			var verts = this.object.geometry.vertices;
	
			var faces = this.object.geometry.faces;
	
			var worldMatrix = this.object.matrixWorld;
	
			var idx = 0;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {
	
					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];
	
					var tangent = face.vertexTangents[ j ];
	
					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );
	
					v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );
	
					v1.add( vertices[ idx ] );
					idx = idx + 1;
	
					vertices[ idx ].copy( v1 );
					idx = idx + 1;
	
				}
	
			}
	
			this.geometry.verticesNeedUpdate = true;
	
			return this;
	
		}
	
	}());
	
	// File:src/extras/helpers/WireframeHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };
	
		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();
	
		if ( object.geometry instanceof THREE.Geometry ) {
	
			var vertices = object.geometry.vertices;
			var faces = object.geometry.faces;
			var numEdges = 0;
	
			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );
	
					var key = edge.toString();
	
					if ( hash[ key ] === undefined ) {
	
						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;
	
					}
	
				}
	
			}
	
			var coords = new Float32Array( numEdges * 2 * 3 );
	
			for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
				for ( var j = 0; j < 2; j ++ ) {
	
					var vertex = vertices[ edges [ 2 * i + j] ];
	
					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;
	
				}
	
			}
	
			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
		} else if ( object.geometry instanceof THREE.BufferGeometry ) {
	
			if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry
	
				var vertices = object.geometry.attributes.position.array;
				var indices = object.geometry.attributes.index.array;
				var drawcalls = object.geometry.drawcalls;
				var numEdges = 0;
	
				if ( drawcalls.length === 0 ) {
	
					drawcalls = [ { count : indices.length, index : 0, start : 0 } ];
	
				}
	
				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );
	
				for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {
	
					var start = drawcalls[ o ].start;
					var count = drawcalls[ o ].count;
					var index = drawcalls[ o ].index;
	
					for ( var i = start, il = start + count; i < il; i += 3 ) {
	
						for ( var j = 0; j < 3; j ++ ) {
	
							edge[ 0 ] = index + indices[ i + j ];
							edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );
	
							var key = edge.toString();
	
							if ( hash[ key ] === undefined ) {
	
								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;
	
							}
	
						}
	
					}
	
				}
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
					for ( var j = 0; j < 2; j ++ ) {
	
						var index = 6 * i + 3 * j;
						var index2 = 3 * edges[ 2 * i + j];
						coords[ index + 0 ] = vertices[ index2 ];
						coords[ index + 1 ] = vertices[ index2 + 1 ];
						coords[ index + 2 ] = vertices[ index2 + 2 ];
	
					}
	
				}
	
				geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			} else { // non-indexed BufferGeometry
	
				var vertices = object.geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numTris; i < l; i ++ ) {
	
					for ( var j = 0; j < 3; j ++ ) {
	
						var index = 18 * i + 6 * j;
	
						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];
	
						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];
	
					}
	
				}
	
				geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			}
	
		}
	
		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
	
	// File:src/extras/objects/ImmediateRenderObject.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ImmediateRenderObject = function () {
	
		THREE.Object3D.call( this );
	
		this.render = function ( renderCallback ) {};
	
	};
	
	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
	
	// File:src/extras/objects/MorphBlendMesh.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphBlendMesh = function( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.animationsMap = {};
		this.animationsList = [];
	
		// prepare default animation
		// (all frames played together in 1 second)
	
		var numFrames = this.geometry.morphTargets.length;
	
		var name = "__default";
	
		var startFrame = 0;
		var endFrame = numFrames - 1;
	
		var fps = numFrames / 1;
	
		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );
	
	};
	
	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
	
	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
		var animation = {
	
			startFrame: start,
			endFrame: end,
	
			length: end - start + 1,
	
			fps: fps,
			duration: ( end - start ) / fps,
	
			lastFrame: 0,
			currentFrame: 0,
	
			active: false,
	
			time: 0,
			direction: 1,
			weight: 1,
	
			directionBackwards: false,
			mirroredLoop: false
	
		};
	
		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );
	
	};
	
	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
		var pattern = /([a-z]+)_?(\d+)/;
	
		var firstAnimation, frameRanges = {};
	
		var geometry = this.geometry;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );
	
			if ( chunks && chunks.length > 1 ) {
	
				var name = chunks[ 1 ];
	
				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };
	
				var range = frameRanges[ name ];
	
				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;
	
				if ( ! firstAnimation ) firstAnimation = name;
	
			}
	
		}
	
		for ( var name in frameRanges ) {
	
			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );
	
		}
	
		this.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = 1;
			animation.directionBackwards = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = - 1;
			animation.directionBackwards = true;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.weight = weight;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = time;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
		var time = 0;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			time = animation.time;
	
		}
	
		return time;
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
		var duration = - 1;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			duration = animation.duration;
	
		}
	
		return duration;
	
	};
	
	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = 0;
			animation.active = true;
	
		} else {
	
			THREE.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.active = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.update = function ( delta ) {
	
		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
			var animation = this.animationsList[ i ];
	
			if ( ! animation.active ) continue;
	
			var frameTime = animation.duration / animation.length;
	
			animation.time += animation.direction * delta;
	
			if ( animation.mirroredLoop ) {
	
				if ( animation.time > animation.duration || animation.time < 0 ) {
	
					animation.direction *= - 1;
	
					if ( animation.time > animation.duration ) {
	
						animation.time = animation.duration;
						animation.directionBackwards = true;
	
					}
	
					if ( animation.time < 0 ) {
	
						animation.time = 0;
						animation.directionBackwards = false;
	
					}
	
				}
	
			} else {
	
				animation.time = animation.time % animation.duration;
	
				if ( animation.time < 0 ) animation.time += animation.duration;
	
			}
	
			var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;
	
			if ( keyframe !== animation.currentFrame ) {
	
				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
				this.morphTargetInfluences[ keyframe ] = 0;
	
				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;
	
			}
	
			var mix = ( animation.time % frameTime ) / frameTime;
	
			if ( animation.directionBackwards ) mix = 1 - mix;
	
			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
		}
	
	};
	


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.EffectComposer = function ( renderer, renderTarget ) {
	
		this.renderer = renderer;
	
		if ( renderTarget === undefined ) {
	
			var pixelRatio = renderer.getPixelRatio();
	
			var width  = Math.floor( renderer.context.canvas.width  / pixelRatio ) || 1;
			var height = Math.floor( renderer.context.canvas.height / pixelRatio ) || 1;
			var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };
	
			renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
	
		}
	
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
	
		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;
	
		this.passes = [];
	
		if ( THREE.CopyShader === undefined )
			console.error( "THREE.EffectComposer relies on THREE.CopyShader" );
	
		this.copyPass = new THREE.ShaderPass( THREE.CopyShader );
	
	};
	
	THREE.EffectComposer.prototype = {
	
		swapBuffers: function() {
	
			var tmp = this.readBuffer;
			this.readBuffer = this.writeBuffer;
			this.writeBuffer = tmp;
	
		},
	
		addPass: function ( pass ) {
	
			this.passes.push( pass );
	
		},
	
		insertPass: function ( pass, index ) {
	
			this.passes.splice( index, 0, pass );
	
		},
	
		render: function ( delta ) {
	
			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;
	
			var maskActive = false;
	
			var pass, i, il = this.passes.length;
	
			for ( i = 0; i < il; i ++ ) {
	
				pass = this.passes[ i ];
	
				if ( !pass.enabled ) continue;
	
				pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );
	
				if ( pass.needsSwap ) {
	
					if ( maskActive ) {
	
						var context = this.renderer.context;
	
						context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
	
						this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );
	
						context.stencilFunc( context.EQUAL, 1, 0xffffffff );
	
					}
	
					this.swapBuffers();
	
				}
	
				if ( pass instanceof THREE.MaskPass ) {
	
					maskActive = true;
	
				} else if ( pass instanceof THREE.ClearMaskPass ) {
	
					maskActive = false;
	
				}
	
			}
	
		},
	
		reset: function ( renderTarget ) {
	
			if ( renderTarget === undefined ) {
	
				renderTarget = this.renderTarget1.clone();
	
				var pixelRatio = this.renderer.getPixelRatio();
	
				renderTarget.width  = Math.floor( this.renderer.context.canvas.width  / pixelRatio );
				renderTarget.height = Math.floor( this.renderer.context.canvas.height / pixelRatio );
	
			}
	
			this.renderTarget1 = renderTarget;
			this.renderTarget2 = renderTarget.clone();
	
			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;
	
		},
	
		setSize: function ( width, height ) {
	
			var renderTarget = this.renderTarget1.clone();
	
			renderTarget.width = width;
			renderTarget.height = height;
	
			this.reset( renderTarget );
	
		}
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(64)))

/***/ },
/* 66 */
/***/ function(module, exports) {

	var Animator = (function () {
	    function Animator() {
	        this.animation = [];
	    }
	    Animator.prototype.play = function (_a) {
	        var _b = _a.func, func = _b === void 0 ? function (dt) { return null; } : _b, _c = _a.duration, duration = _c === void 0 ? 1000 : _c, _d = _a.object, object = _d === void 0 ? null : _d, _e = _a.loop, loop = _e === void 0 ? false : _e, _f = _a.timer, timer = _f === void 0 ? false : _f;
	        var animation = this.animation;
	        return new Promise(function (resolve, reject) {
	            if (object && animation.filter(function (o) { return o.object == object; }).length)
	                return reject("object already in use");
	            animation.push({ start: Date.now(), func: func, duration: duration, resolve: resolve, object: object, loop: loop, timer: timer });
	        }).catch(function (error) { return null; });
	    };
	    Animator.prototype.stop = function (object) {
	        var i = this.animation.map(function (o) { return o.object; }).indexOf(object);
	        if (i >= 0)
	            this.animation.splice(i, 1);
	    };
	    Animator.prototype.step = function () {
	        for (var i = 0, len = this.animation.length; i < len; i++) {
	            var dt = Date.now() - this.animation[i].start;
	            if (dt <= this.animation[i].duration) {
	                if (!this.animation[i].timer)
	                    this.animation[i].func(dt / this.animation[i].duration);
	            }
	            else if (this.animation[i].loop) {
	                if (this.animation[i].timer)
	                    this.animation[i].func(1);
	                this.animation[i].start = Date.now();
	            }
	            else {
	                this.animation[i].func(1);
	                this.animation[i].resolve();
	                this.animation.splice(i, 1);
	                i--;
	                len--;
	            }
	        }
	    };
	    return Animator;
	})();
	exports.Animator = Animator;
	//# sourceMappingURL=animator.js.map

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {__webpack_require__(68);
	var HeadObject = (function () {
	    function HeadObject() {
	        this.materialWire = new THREE.MeshBasicMaterial({
	            wireframe: true,
	            color: 0,
	            fog: true
	        });
	        this.materialSolid = new THREE.MeshLambertMaterial({
	            shading: THREE.FlatShading,
	            vertexColors: THREE.FaceColors,
	            fog: true
	        });
	    }
	    HeadObject.prototype.colorize = function () {
	        var len = this.geometry.faces.length;
	        for (var i = 0; i < len; i++)
	            this.geometry.faces[i].color.setHSL(0, 0, Math.random() / 5 + .8);
	        this.geometry.colorsNeedUpdate = true;
	    };
	    HeadObject.prototype.blink = function (n, dt) {
	        var len = this.geometry.faces.length;
	        for (var i = 0; i < len; i++)
	            if (i >= (n - dt / 2) * len && i <= (n + dt / 2) * len)
	                this.geometry.faces[i].color.setHSL(Math.random(), .5, .5);
	            else
	                this.geometry.faces[i].color.setHSL(1, 1, 1);
	        this.geometry.colorsNeedUpdate = true;
	    };
	    HeadObject.prototype.load = function () {
	        var _this = this;
	        var loader = new THREE.JSONLoader(true);
	        return Promise.all([
	            window.fetch('media/lowpolymap.txt').then(function (d) { return d.text(); }).then(function (d) { return _this.reduceMap = d.split(",").map(function (x) { return parseInt(x); }); }),
	            new Promise(function (resolve, reject) {
	                loader.load('media/lowpolyhead.js', function (geometry) {
	                    _this.geometry = geometry;
	                    _this.origGeometry = geometry.clone();
	                    _this.mesh = new THREE.Mesh(_this.geometry, _this.materialWire);
	                    resolve();
	                });
	            })
	        ]);
	    };
	    HeadObject.prototype.lowpoly = function (t) {
	        var face, oldFace;
	        for (var i = 0; i < this.geometry.faces.length; i++) {
	            face = this.geometry.faces[i];
	            oldFace = this.origGeometry.faces[i];
	            face.a = oldFace.a;
	            face.b = oldFace.b;
	            face.c = oldFace.c;
	            while (face.a > t)
	                face.a = this.reduceMap[face.a];
	            while (face.b > t)
	                face.b = this.reduceMap[face.b];
	            while (face.c > t)
	                face.c = this.reduceMap[face.c];
	        }
	        this.geometry.verticesNeedUpdate = true;
	        this.geometry.elementsNeedUpdate = true;
	    };
	    HeadObject.prototype.getMorphTargets = function (n) {
	        return this.origGeometry.vertices.slice(0, n);
	    };
	    return HeadObject;
	})();
	exports.HeadObject = HeadObject;
	//# sourceMappingURL=end.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(64)))

/***/ },
/* 68 */
/***/ function(module, exports) {

	(function() {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = name.toString();
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = value.toString();
	    }
	    return value
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  var support = {
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob();
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (!body) {
	        this._bodyText = ''
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(url, options) {
	    options = options || {}
	    this.url = url
	
	    this.credentials = options.credentials || 'omit'
	    this.headers = new Headers(options.headers)
	    this.method = normalizeMethod(options.method || 'GET')
	    this.mode = options.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && options.body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(options.body)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this._initBody(bodyInit)
	    this.type = 'default'
	    this.url = null
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	  }
	
	  Body.call(Response.prototype)
	
	  self.Headers = Headers;
	  self.Request = Request;
	  self.Response = Response;
	
	  self.fetch = function(input, init) {
	    // TODO: Request constructor should accept input, init
	    var request
	    if (Request.prototype.isPrototypeOf(input) && !init) {
	      request = input
	    } else {
	      request = new Request(input, init)
	    }
	
	    return new Promise(function(resolve, reject) {
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return;
	      }
	
	      xhr.onload = function() {
	        var status = (xhr.status === 1223) ? 204 : xhr.status
	        if (status < 100 || status > 599) {
	          reject(new TypeError('Network request failed'))
	          return
	        }
	        var options = {
	          status: status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText;
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})();


/***/ },
/* 69 */
/***/ function(module, exports) {

	exports.spaceVertexShader = "\n  varying vec2 vUV;\n  void main(void){\n    gl_Position = projectionMatrix *modelViewMatrix  * vec4(position,1.0);\n    vUV = gl_Position.xy / gl_Position.w;\n  }\n";
	exports.spaceFragmentShader = "\n  // https://www.shadertoy.com/view/XlfGRj\n  // Star Nest by Pablo Rom\u00E1n Andrioli\n  // This content is under the MIT License.\n\n  #define iterations 17\n  #define formuparam 0.53\n\n  #define volsteps 5\n  #define stepsize 0.33\n\n  #define zoom   0.800\n  #define tile   0.850\n  #define speed  0.004 \n\n  #define brightness 0.0015\n  #define darkmatter 0.300\n  #define distfading 0.730\n  #define saturation 0.850\n\n  varying vec2 vUV;\n  uniform float iGlobalTime;\n  uniform vec2 iResolution;\n  uniform float fogDensity;\n  uniform vec3 fogColor;\n\n  void main(void)\n  {\n    vec2 uv=vUV;//fragCoord.xy/iResolution.xy-.5;\n    uv.y*=iResolution.y/iResolution.x;\n    vec3 dir=vec3(uv*zoom,1.);\n    float time=iGlobalTime*speed+.25;\n\n    //mouse rotation\n    float a1=.5+.1;\n    float a2=.8+.2;\n    mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n    mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n    dir.xz*=rot1;\n    dir.xy*=rot2;\n    vec3 from=vec3(1.,.5,0.5);\n    from+=vec3(time*2.,time,-2.);\n    from.xz*=rot1;\n    from.xy*=rot2;\n    \n    //volumetric rendering\n    float s=0.1,fade=1.;\n    vec3 v=vec3(0.);\n    for (int r=0; r<volsteps; r++) {\n      vec3 p=from+s*dir*.5;\n      p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n      float pa,a=pa=0.;\n      for (int i=0; i<iterations; i++) { \n        p=abs(p)/dot(p,p)-formuparam; // the magic formula\n        a+=abs(length(p)-pa); // absolute sum of average change\n        pa=length(p);\n      }\n      float dm=max(0.,darkmatter-a*a*.001); //dark matter\n      a*=a*a; // add contrast\n      if (r>6) fade*=1.-dm; // dark matter, don't render near\n      //v+=vec3(dm,dm*.5,0.);\n      v+=fade;\n      v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n      fade*=distfading; // distance fading\n      s+=stepsize;\n    }\n    v=mix(vec3(length(v)),v,saturation); //color adjust\n    gl_FragColor = vec4(v*.01,1.);\n    \n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    const float LOG2 = 1.442695;    \n    float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n    fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n  }\n";
	//# sourceMappingURL=shaders.js.map

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Full-screen textured quad shader
	 */
	
	THREE.CopyShader = {
	
		uniforms: {
	
			"tDiffuse": { type: "t", value: null },
			"opacity":  { type: "f", value: 1.0 }
	
		},
	
		vertexShader: [
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
			"}"
	
		].join("\n"),
	
		fragmentShader: [
	
			"uniform float opacity;",
	
			"uniform sampler2D tDiffuse;",
	
			"varying vec2 vUv;",
	
			"void main() {",
	
				"vec4 texel = texture2D( tDiffuse, vUv );",
				"gl_FragColor = opacity * texel;",
	
			"}"
	
		].join("\n")
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(64)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author felixturner / http://airtight.cc/
	 *
	 * RGB Shift Shader
	 * Shifts red and blue channels from center in opposite directions
	 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
	 * by Tom Butterworth / http://kriss.cx/tom/
	 *
	 * amount: shift distance (1 is width of input)
	 * angle: shift angle in radians
	 */
	
	THREE.DigitalGlitch = {
	
		uniforms: {
	
			"tDiffuse":		{ type: "t", value: null },//diffuse texture
			"tDisp":		{ type: "t", value: null },//displacement texture for digital glitch squares
			"byp":			{ type: "i", value: 0 },//apply the glitch ?
			"amount":		{ type: "f", value: 0.08 },
			"angle":		{ type: "f", value: 0.02 },
			"seed":			{ type: "f", value: 0.02 },
			"seed_x":		{ type: "f", value: 0.02 },//-1,1
			"seed_y":		{ type: "f", value: 0.02 },//-1,1
			"distortion_x":	{ type: "f", value: 0.5 },
			"distortion_y":	{ type: "f", value: 0.6 },
			"col_s":		{ type: "f", value: 0.05 }
		},
	
		vertexShader: [
	
			"varying vec2 vUv;",
			"void main() {",
				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
			"}"
		].join("\n"),
	
		fragmentShader: [
			"uniform int byp;",//should we apply the glitch ?
			
			"uniform sampler2D tDiffuse;",
			"uniform sampler2D tDisp;",
			
			"uniform float amount;",
			"uniform float angle;",
			"uniform float seed;",
			"uniform float seed_x;",
			"uniform float seed_y;",
			"uniform float distortion_x;",
			"uniform float distortion_y;",
			"uniform float col_s;",
				
			"varying vec2 vUv;",
			
			
			"float rand(vec2 co){",
				"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);",
			"}",
					
			"void main() {",
				"if(byp<1) {",
					"vec2 p = vUv;",
					"float xs = floor(gl_FragCoord.x / 0.5);",
					"float ys = floor(gl_FragCoord.y / 0.5);",
					//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch
					"vec4 normal = texture2D (tDisp, p*seed*seed);",
					"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {",
						"if(seed_x>0.){",
							"p.y = 1. - (p.y + distortion_y);",
						"}",
						"else {",
							"p.y = distortion_y;",
						"}",
					"}",
					"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {",
						"if(seed_y>0.){",
							"p.x=distortion_x;",
						"}",
						"else {",
							"p.x = 1. - (p.x + distortion_x);",
						"}",
					"}",
					"p.x+=normal.x*seed_x*(seed/5.);",
					"p.y+=normal.y*seed_y*(seed/5.);",
					//base from RGB shift shader
					"vec2 offset = amount * vec2( cos(angle), sin(angle));",
					"vec4 cr = texture2D(tDiffuse, p + offset);",
					"vec4 cga = texture2D(tDiffuse, p);",
					"vec4 cb = texture2D(tDiffuse, p - offset);",
					"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
					//add noise
					"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);",
					"gl_FragColor = gl_FragColor+ snow;",
				"}",
				"else {",
					"gl_FragColor=texture2D (tDiffuse, vUv);",
				"}",
			"}"
	
		].join("\n")
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(64)))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {
	
		this.scene = scene;
		this.camera = camera;
	
		this.overrideMaterial = overrideMaterial;
	
		this.clearColor = clearColor;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;
	
		this.oldClearColor = new THREE.Color();
		this.oldClearAlpha = 1;
	
		this.enabled = true;
		this.clear = true;
		this.needsSwap = false;
	
	};
	
	THREE.RenderPass.prototype = {
	
		render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
			this.scene.overrideMaterial = this.overrideMaterial;
	
			if ( this.clearColor ) {
	
				this.oldClearColor.copy( renderer.getClearColor() );
				this.oldClearAlpha = renderer.getClearAlpha();
	
				renderer.setClearColor( this.clearColor, this.clearAlpha );
	
			}
	
			renderer.render( this.scene, this.camera, readBuffer, this.clear );
	
			if ( this.clearColor ) {
	
				renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
	
			}
	
			this.scene.overrideMaterial = null;
	
		}
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(64)))

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MaskPass = function ( scene, camera ) {
	
		this.scene = scene;
		this.camera = camera;
	
		this.enabled = true;
		this.clear = true;
		this.needsSwap = false;
	
		this.inverse = false;
	
	};
	
	THREE.MaskPass.prototype = {
	
		render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
			var context = renderer.context;
	
			// don't update color or depth
	
			context.colorMask( false, false, false, false );
			context.depthMask( false );
	
			// set up stencil
	
			var writeValue, clearValue;
	
			if ( this.inverse ) {
	
				writeValue = 0;
				clearValue = 1;
	
			} else {
	
				writeValue = 1;
				clearValue = 0;
	
			}
	
			context.enable( context.STENCIL_TEST );
			context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
			context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
			context.clearStencil( clearValue );
	
			// draw into the stencil buffer
	
			renderer.render( this.scene, this.camera, readBuffer, this.clear );
			renderer.render( this.scene, this.camera, writeBuffer, this.clear );
	
			// re-enable update of color and depth
	
			context.colorMask( true, true, true, true );
			context.depthMask( true );
	
			// only render where stencil is set to 1
	
			context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
			context.stencilOp( context.KEEP, context.KEEP, context.KEEP );
	
		}
	
	};
	
	
	THREE.ClearMaskPass = function () {
	
		this.enabled = true;
	
	};
	
	THREE.ClearMaskPass.prototype = {
	
		render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
			var context = renderer.context;
	
			context.disable( context.STENCIL_TEST );
	
		}
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(64)))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ShaderPass = function ( shader, textureID ) {
	
		this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";
	
		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
		this.material = new THREE.ShaderMaterial( {
	
	        	defines: shader.defines || {},
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader
	
		} );
	
		this.renderToScreen = false;
	
		this.enabled = true;
		this.needsSwap = true;
		this.clear = false;
	
	
		this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
		this.scene  = new THREE.Scene();
	
		this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
		this.scene.add( this.quad );
	
	};
	
	THREE.ShaderPass.prototype = {
	
		render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
			if ( this.uniforms[ this.textureID ] ) {
	
				this.uniforms[ this.textureID ].value = readBuffer;
	
			}
	
			this.quad.material = this.material;
	
			if ( this.renderToScreen ) {
	
				renderer.render( this.scene, this.camera );
	
			} else {
	
				renderer.render( this.scene, this.camera, writeBuffer, this.clear );
	
			}
	
		}
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(64)))

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(THREE) {/**
	 
	 */
	
	THREE.GlitchPass = function ( dt_size ) {
	
		if ( THREE.DigitalGlitch === undefined ) console.error( "THREE.GlitchPass relies on THREE.DigitalGlitch" );
		
		var shader = THREE.DigitalGlitch;
		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
		if (dt_size == undefined) dt_size = 64;
		
		
		this.uniforms[ "tDisp"].value = this.generateHeightmap(dt_size);
		
	
		this.material = new THREE.ShaderMaterial({
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader
		});
	
		//console.log(this.material);
		
		this.enabled = true;
		this.renderToScreen = false;
		this.needsSwap = true;
	
	
		this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
		this.scene  = new THREE.Scene();
	
		this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
		this.scene.add( this.quad );
		
		this.goWild = false;
		this.curF = 0;
		this.generateTrigger();
		
	};
	
	THREE.GlitchPass.prototype = {
	
		render: function ( renderer, writeBuffer, readBuffer, delta ) 
		{
			this.uniforms[ "tDiffuse" ].value = readBuffer;
			this.uniforms[ 'seed' ].value = Math.random();//default seeding
			this.uniforms[ 'byp' ].value = 0;
			
			if (this.curF % this.randX == 0 || this.goWild == true)
			{
				this.uniforms[ 'amount' ].value = Math.random() / 30;
				this.uniforms[ 'angle' ].value = THREE.Math.randFloat(-Math.PI, Math.PI);
				this.uniforms[ 'seed_x' ].value = THREE.Math.randFloat(-1, 1);
				this.uniforms[ 'seed_y' ].value = THREE.Math.randFloat(-1, 1);
				this.uniforms[ 'distortion_x' ].value = THREE.Math.randFloat(0, 1);
				this.uniforms[ 'distortion_y' ].value = THREE.Math.randFloat(0, 1);
				this.curF = 0;
				this.generateTrigger();
			}
			else if (this.curF % this.randX < this.randX / 5)
			{
				this.uniforms[ 'amount' ].value = Math.random() / 90;
				this.uniforms[ 'angle' ].value = THREE.Math.randFloat(-Math.PI, Math.PI);
				this.uniforms[ 'distortion_x' ].value = THREE.Math.randFloat(0, 1);
				this.uniforms[ 'distortion_y' ].value = THREE.Math.randFloat(0, 1);
				this.uniforms[ 'seed_x' ].value = THREE.Math.randFloat(-0.3, 0.3);
				this.uniforms[ 'seed_y' ].value = THREE.Math.randFloat(-0.3, 0.3);
			}
			else if (this.goWild == false)
			{
				this.uniforms[ 'byp' ].value = 1;
			}
			this.curF ++;
			
			this.quad.material = this.material;
			if ( this.renderToScreen ) 
			{
				renderer.render( this.scene, this.camera );
			} 
			else 
			{
				renderer.render( this.scene, this.camera, writeBuffer, false );
			}
		},
		generateTrigger:function()
		{
			this.randX = THREE.Math.randInt(120, 240);
		},
		generateHeightmap:function(dt_size)
		{
			var data_arr = new Float32Array( dt_size * dt_size * 3 );
			//console.log(dt_size);
			var length = dt_size * dt_size;
			
			for ( var i = 0; i < length; i ++) 
			{
				var val = THREE.Math.randFloat(0, 1);
				data_arr[ i * 3 + 0 ] = val;
				data_arr[ i * 3 + 1 ] = val;
				data_arr[ i * 3 + 2 ] = val;
			}
			
			var texture = new THREE.DataTexture( data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType );
			//console.log(texture);
			//console.log(dt_size);
			texture.minFilter = THREE.NearestFilter;
			texture.magFilter = THREE.NearestFilter;
			texture.needsUpdate = true;
			texture.flipY = false;
			return texture;
		}
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(64)))

/***/ },
/* 76 */
/***/ function(module, exports) {

	var Controls = (function () {
	    function Controls() {
	        this.turn = 0;
	        this.up = 0;
	        if (!Controls.isMobile())
	            this.listenDesktopEvents();
	        else
	            this.listenMobileEvents();
	    }
	    Controls.prototype.listenDesktopEvents = function () {
	        var _this = this;
	        window.onkeydown = function (e) {
	            if (e.keyCode == 37)
	                _this.turn = -1;
	            if (e.keyCode == 38)
	                _this.up = 1;
	            if (e.keyCode == 39)
	                _this.turn = 1;
	        };
	        window.onkeyup = function (e) {
	            if (e.keyCode == 37 || e.keyCode == 39)
	                _this.turn = 0;
	            if (e.keyCode == 38)
	                _this.up = 0;
	        };
	    };
	    Controls.prototype.listenMobileEvents = function () {
	        var _this = this;
	        window.addEventListener("deviceorientation", function (e) {
	            if (window.innerHeight > window.innerWidth) {
	                _this.turn = e.gamma / 45;
	                if (e.beta < 75)
	                    _this.up = Math.min((75 - e.beta) / 60, 1);
	                else
	                    _this.up = 0;
	            }
	            else {
	                if (e.gamma < 0) {
	                    _this.turn = e.beta / 45;
	                    if (e.gamma >= -60)
	                        _this.up = Math.min((e.gamma + 60) / 40, 1);
	                    else
	                        _this.up = 0;
	                }
	                else {
	                    _this.turn = -e.beta / 45;
	                    if (e.gamma <= 60)
	                        _this.up = Math.min((60 - e.gamma) / 40, 1);
	                    else
	                        _this.up = 0;
	                }
	            }
	        }, true);
	    };
	    Controls.isMobile = function () {
	        return typeof window.orientation !== 'undefined';
	    };
	    return Controls;
	})();
	exports.Controls = Controls;
	//# sourceMappingURL=controls.js.map

/***/ },
/* 77 */
/***/ function(module, exports) {

	//algorithm http://www.neocomputer.org/projects/eller.html
	function EllerMaze(width, height) {
	    if (width === void 0) { width = 16; }
	    if (height === void 0) { height = 16; }
	    var curstr = [];
	    var map = [];
	    var ls = width * 2 + 1;
	    for (var i = 0; i < width; i++)
	        curstr[i] = i;
	    border();
	    for (var n = 0; n < height; n++) {
	        drawline(line1(), false);
	        drawline(line2(), true);
	        unnull();
	    }
	    drawline(last(), false);
	    border();
	    return map;
	    function log() {
	        for (var n_1 = 0; n_1 < map.length; n_1++)
	            console.log(map[n_1].map(function (el) { return el ? "#" : "-"; }).join(""));
	    }
	    function line1() {
	        var result = [], v1, v2;
	        for (var i = 0; i < width - 1; i++) {
	            result[i] = false;
	            if (curstr[i] == curstr[i + 1])
	                result[i] = true;
	            else {
	                if (Math.random() > .5)
	                    result[i] = true;
	                else {
	                    v1 = curstr[i];
	                    v2 = curstr[i + 1];
	                    curstr = curstr.map(function (x) {
	                        if (x == v2)
	                            return v1;
	                        else
	                            return x;
	                    });
	                }
	            }
	        }
	        return result;
	    }
	    function line2() {
	        var result = [];
	        for (var i = 0; i < width; i++) {
	            result[i] = false;
	            var l = curstr.filter(function (x) { return x == curstr[i]; }).length;
	            if (l > 1 && Math.random() > .5) {
	                result[i] = true;
	                curstr[i] = null;
	            }
	        }
	        return result;
	    }
	    function unique() {
	        for (var i = 0;; i++)
	            if (curstr.filter(function (x) { return x == i; }).length == 0)
	                return i;
	    }
	    function unnull() {
	        for (var i = 0; i < width; i++)
	            if (curstr[i] == null)
	                curstr[i] = unique();
	    }
	    function last() {
	        var result = line1();
	        for (var i = 0; i < width - 1; i++)
	            if (curstr[i] != curstr[i + 1])
	                result[i] = false;
	        return result;
	    }
	    function drawline(l, isline2) {
	        var outl = [];
	        outl.push(true);
	        for (var i = 0; i < width - 1; i++) {
	            if (isline2)
	                outl.push(l[i], Math.random() > .3);
	            else
	                outl.push(false, l[i]);
	        }
	        outl.push(l[width - 1]);
	        outl.push(true);
	        map.push(outl);
	    }
	    function border() {
	        var l = [];
	        for (var i = 0; i < ls; i++)
	            l.push(true);
	        map.push(l);
	    }
	}
	exports.EllerMaze = EllerMaze;
	//# sourceMappingURL=ellermaze.js.map

/***/ }
/******/ ]);
//# sourceMappingURL=main.bundle.js.map