<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<script src="../../list.js"></script>
		<script src="../../page.js"></script>
		<link type="text/css" rel="stylesheet" href="../../page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<div class="desc">A two dimensional surface that extends infinitely in 3d space.</div>


		<h2>Constructor</h2>


		<h3>[name]([page:Vector3 normal], [page:Float constant])</h3>
		<div>
		normal -- ([Page:Vector3]) normal vector defining the plane pointing towards the origin <br />
		constant -- ([Page:Float]) the negative distance from the origin to the plane along the normal vector
		</div>


		<h2>Properties</h2>

		<h3>[property:Vector3 normal]</h3>

		<h3>[property:Float constant]</h3>
		
		<h2>Methods</h2>



		<h3>[method:Plane normalize]() [page:Plane this]</h3>
		<div>
		Normalizes the normal vector, and adjusts the constant value accordingly.
		</div>

		<h3>[method:Plane set]([page:Vector3 normal], [page:Float constant]) [page:Plane this]</h3>
		<div>
		normal -- [Page:Vector3] <br />
		constant -- [Page:Float]
		</div>
		<div>
		Sets the plane's values.
		</div>

		<h3>[method:Plane copy]([page:Plane plane]) [page:Plane this]</h3>
		<div>
		plane -- [page:Plane] to copy
		</div>
		<div>
		Copies the values of the passed plane to this plane.
		</div>

		<h3>[method:Plane applyMatrix4]([page:Matrix4 matrix], [page:Matrix3 optionalNormalMatrix]) [page:Plane this]</h3>
		<div>
		matrix -- [Page:Matrix4] to apply <br />
		optionalNormalMatrix -- (optional) pre-computed normal [Page:Matrix3] of the Matrix4 to apply
		</div>
		<div>
		Apply a Matrix4 to the plane. The second parameter is optional.
		
		<code>
		var optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix ) 
		</code>
		</div>

		<h3>[method:Vector3 orthoPoint]([page:Vector3 point], [page:Vector3 optionalTarget])</h3>
		<div>
		point -- [page:Vector3] <br />
		optionalTarget -- [page:Vector3]
		</div>
		<div>
		Returns a vector in the same direction as the Plane's normal, but the magnitude is passed point's original distance to the plane.
		</div>

		<h3>[method:Boolean isIntersectionLine]([page:Line3 line])</h3>
		<div>
		line -- [page:Line3]
		</div>
		<div>
		Tests whether a line segment intersects with the plane. (Do not mistake this for a collinear check.)
		</div>

		<h3>[method:Vector3 intersectLine]([page:Line3 line], [page:Vector3 optionalTarget]) or [page:undefined]</h3>
		<div>
		line -- [page:Line3] <br />
		optionalTarget -- [page:Vector3]
		</div>
		<div>
		Returns the intersection point of the passed line and the plane. Returns undefined if the line does not intersect. Returns the line's starting point if the line is coplanar with the plane.
		</div>

		<h3>[method:Vector3 setFromNormalAndCoplanarPoint]([page:Vector3 normal], [page:Vector3 point]) [page:Vector3 this]</h3>
		<div>
		normal -- [page:Vector3] <br />
		point -- [page:Vector3]
		</div>
		<div>
		Sets the plane's values as defined by a normal and arbitrary coplanar point.
		</div>

		<h3>[method:Plane clone]()</h3>
		<div>
		Returns a new copy of this plane.
		</div>

		<h3>[method:Float distanceToPoint]([page:Vector3 point])</h3>
		<div>
		point -- [page:Vector3]
		</div>
		<div>
		Returns the smallest distance from the point to the plane.
		</div>

		<h3>[method:Boolean equals]([page:Plane plane])</h3>
		<div>
		plane -- [page:Planen]
		</div>
		<div>
		Checks to see if two planes are equal (their normals and constants match)
		</div>

		<h3>[method:Plane setComponents]([page:Float x], [page:Float y], [page:Float z], [page:Float w]) [page:Plane this]</h3>
		<div>
		x -- [page:Float] x of the normal vector <br />
		y -- [page:Float] y of the normal vector<br />
		z -- [page:Float] z of the normal vector<br />
		w -- [page:Float] distance of the plane from the origin along the normal vector
		</div>
		<div>
		Set the individual components that make up the plane.
		</div>

		<h3>[method:Float distanceToSphere]([page:Sphere sphere])</h3>
		<div>
		sphere -- [Page:Sphere]
		</div>
		<div>
		Returns the smallest distance from an edge of the sphere to the plane.
		</div>

		<h3>[method:Plane setFromCoplanarPoints]([page:Vector3 a], [page:Vector3 b], [page:Vector3 c]) [page:Plane this]</h3>
		<div>
		a -- [page:Vector3] <br />
		b -- [page:Vector3] <br />
		c -- [page:Vector3]
		</div>
		<div>
		Defines the plane based on the 3 provided points. The winding order is counter clockwise, and determines which direction the normal will point.
		</div>

		<h3>[method:Vector3 projectPoint]([page:Vector3 point], [page:Vector3 optionalTarget])</h3>
		<div>
		point -- [page:Vector3] <br />
		optionalTarget -- [page:Vector3]
		</div>
		<div>
		Projects a point onto the plane. The projected point is the closest point on the plane to the passed point, so a line drawn from the projected point and the passed point would be orthogonal to the plane.
		</div>

		<h3>[method:Plane negate]() [page:Plane this]</h3>
		<div>
		Negates both the normal vector and constant, effectively mirroring the plane across the origin.
		</div>

		<h3>[method:Plane translate]([page:Vector3 offset]) [page:Plane this]</h3>
		<div>
		offset -- [page:Vector3]
		</div>
		<div>
		Translates the plane the distance defined by the vector. Note that this only affects the constant (distance from origin) and will not affect the normal vector.
		</div>

		<h3>[method:Vector3 coplanarPoint]([page:Vector3 optionalTarget])</h3>
		<div>
		optionalTarget -- [page:Vector3]
		</div>
		<div>
		Returns a coplanar point. (The projection of the normal vector at the origin onto the plane.)
		</div>

		<h2>Source</h2>

		[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
	</body>
</html>
